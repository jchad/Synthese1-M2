<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gKit2 light: openGL 4.3 : storage buffers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">gKit2 light
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">openGL 4.3 : storage buffers</div>  </div>
</div><!--header-->
<div class="contents">
<p>cf <a class="el" href="tuto__storage_8cpp.html">tuto_storage.cpp</a> et <a class="el" href="tuto__storage__buffer_8cpp.html">tuto_storage_buffer.cpp</a></p>
<p>Les uniforms déclarés dans les shaders permettent de manipuler des tableaux de structures de manière assez directe, mais leur taille est très limitée (32Ko ou 64Ko), ce qui les rend assez peu pratiques.</p>
<p>Mais il est possible d'associer un buffer à un block d'uniforms et d'éliminer la limite de taille. La déclaration dans le shader ressemble à celle d'une structure : </p><div class="fragment"><div class="line"><span class="preprocessor">#version 430</span></div>
<div class="line"> </div>
<div class="line">buffer vertexData </div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> positions[];</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">uniform mat4 mvpMatrix;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main( )</div>
<div class="line">{</div>
<div class="line">    gl_Position= mvpMatrix * <a class="code" href="structvec4.html">vec4</a>(positions[gl_VertexID], 1);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Autre fonctionnalité interressante, les shaders peuvent écrire dans ces buffers. Il est recommandé de préciser l'utilisation du contenu du buffer : lecture seule, écriture seule ou mixte, avec les mots-clés <code>readonly</code>, <code>writeonly</code>, et <code>coherent</code> en général, pour les accès mixtes. Pour que l'application puisse associer un buffer à la déclaration dans le shader, il faut nommer le block, cf <code>vertexData</code> dans l'exemple précédent. Et comme il est possible d'utiliser plusieurs storage buffers, ils sont numérotés.</p>
<p>L'application peut utiliser le nom du block pour connaître son identifiant, cf <code>glGetProgramResourceIndex()</code> et lui associer un numéro de block, cf <code>glShaderStorgeBlockBinding()</code>et enfin, un buffer, cf <code>glBindbufferBase()</code>: </p><div class="fragment"><div class="line">GLuint program= { ... };</div>
<div class="line">GLuint buffer= { ... };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// recupere l&#39;identifiant du block</span></div>
<div class="line">GLuint index= glGetProgramResourceIndex(program, GL_SHADER_STORAGE_BLOCK, <span class="stringliteral">&quot;vertexData&quot;</span>);</div>
<div class="line"><span class="comment">// affecte le numero 0 au block</span></div>
<div class="line">glShaderStorageBlockBinding(program, index, <span class="comment">/* binding */</span> 0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// selectionne un buffer pour le block numero 0</span></div>
<div class="line">glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, buffer);</div>
</div><!-- fragment --><p>En pratique, il est plus simple de déclarer le numéro du block dans le shader avec <code>layout(binding= xxx)</code>, ce qui permet à application d'associer un buffer au block directement avec <code>glBindBufferBase(GL_SHADER_STORAGE_BUFFER, xxx, buffer)</code>, sans utiliser <code>glShaderStorageBlockBinding( )</code> : </p><div class="fragment"><div class="line"><span class="preprocessor">#version 430</span></div>
<div class="line"> </div>
<div class="line">layout(binding= 0) readonly buffer vertexData </div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> positions[];</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">uniform mat4 mvpMatrix;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main( )</div>
<div class="line">{</div>
<div class="line">    gl_Position= mvpMatrix * <a class="code" href="structvec4.html">vec4</a>(positions[gl_VertexID], 1);</div>
<div class="line">}</div>
</div><!-- fragment --><p>ce qui permettra, dans l'application, de créer un buffer contenant les données et de le sélectionner sur <code>GL_SHADER_STORAGE_BUFFER</code> numero 0 : </p><div class="fragment"><div class="line">GLuint buffer;</div>
<div class="line">glGenBuffers(1, &amp;buffer);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// selectionner le buffer comme le storage buffer numero 0</span></div>
<div class="line">glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, buffer);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// dimensionner le buffer et l&#39;initialiser</span></div>
<div class="line">glBufferData(GL_SHADER_STORAGE_BUFFER, <span class="comment">/* size */</span>, <span class="comment">/* data */</span>, GL_STATIC_READ);</div>
</div><!-- fragment --><p><b>attention :</b> <code>glBindBufferBase()</code> sélectionne le buffer à la fois sur <code>GL_SHADER_STORAGE_BUFFER</code> et sur la version numérotée <code>GL_SHADER_STORAGE_BUFFER 0</code>.</p>
<h2><a class="anchor" id="autotoc_md110"></a>
alignement des données...</h2>
<p>L'utilisation des storage buffers est assez directe, mais il y a une grosse différence par rapport aux uniforms classiques, il n'y a pas d'interface (cf <code>glUniform())</code> permettant d'affecter des valeurs aux variables déclarées dans le block. Il faut le faire "à la main" en remplissant <em>correctement</em> le buffer qui sera associé au block. Un cpu et un gpu sont des processeurs conçus différemment, et ils n'accèdent pas à la mémoire de la même manière... Il faut donc placer les données au bon endroit dans le buffer pour que les shaders relisent correctement toutes les valeurs. Ce n'est pas très compliqué, voici quelques exemples, pour mieux comprendre les diférences.</p>
<p>Quelle est l'organisation mémoire d'une structure <code><a class="el" href="structTriangle.html">Triangle</a></code> pour un cpu ? </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structTriangle.html">Triangle</a></div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> a;</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> b;</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> <a class="code" href="structTriangleData.html#a2b8f37f18e7b3bcec20bb38e6d7d7595">c</a>;</div>
<div class="line">};</div>
</div><!-- fragment --><p><code>offsetof(type, field)</code> du c++ renvoie la position en octets d'un champ à l'intérieur d'une structure : </p><div class="fragment"><div class="line">offsetof(<a class="code" href="structTriangle.html">Triangle</a>, a)  = 0;</div>
<div class="line">offsetof(<a class="code" href="structTriangle.html">Triangle</a>, a.x)= 0;</div>
<div class="line">offsetof(<a class="code" href="structTriangle.html">Triangle</a>, a.y)= 4;</div>
<div class="line">offsetof(<a class="code" href="structTriangle.html">Triangle</a>, a.z)= 8;</div>
<div class="line">offsetof(<a class="code" href="structTriangle.html">Triangle</a>, b)  = 12;</div>
<div class="line">offsetof(<a class="code" href="structTriangle.html">Triangle</a>, c)  = 24;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">sizeof</span>(<a class="code" href="structTriangle.html">Triangle</a>)       = 36;</div>
</div><!-- fragment --><p>ce qui correspond à : </p><div class="fragment"><div class="line"> 0  a.x</div>
<div class="line"> 4  a.y</div>
<div class="line"> 8  a.z</div>
<div class="line">12  b.x</div>
<div class="line">16  b.y</div>
<div class="line">20  b.z</div>
<div class="line">24  c.x</div>
<div class="line">28  c.y</div>
<div class="line">32  c.z</div>
</div><!-- fragment --><p>Les types de base <code>int</code> et <code>float</code> du c++ occupent 4 octets et les structures <code><a class="el" href="structvec3.html" title="vecteur generique, utilitaire.">vec3</a></code> sont rangées les unes à la suite des autres :</p><ul>
<li>4 octets par float,</li>
<li>4x3= 12 octets par <a class="el" href="structvec3.html" title="vecteur generique, utilitaire.">vec3</a></li>
<li>et 12x3= 36 octets au total.</li>
</ul>
<p>Pour un shader, la structure triangle est organisée différement : </p><div class="fragment"><div class="line">offsetof(<a class="code" href="structTriangle.html">Triangle</a>, a)  = 0;</div>
<div class="line">offsetof(<a class="code" href="structTriangle.html">Triangle</a>, a.x)= 0;</div>
<div class="line">offsetof(<a class="code" href="structTriangle.html">Triangle</a>, a.y)= 4;</div>
<div class="line">offsetof(<a class="code" href="structTriangle.html">Triangle</a>, a.z)= 8;</div>
<div class="line">offsetof(<a class="code" href="structTriangle.html">Triangle</a>, b)  = 16;</div>
<div class="line">offsetof(<a class="code" href="structTriangle.html">Triangle</a>, c)  = 32;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">sizeof</span>(<a class="code" href="structTriangle.html">Triangle</a>)       = 48;</div>
</div><!-- fragment --><p>ce qui correspond à cette organisation mémoire : </p><div class="fragment"><div class="line"> 0  a.x</div>
<div class="line"> 4  a.y</div>
<div class="line"> 8  a.z</div>
<div class="line">12  ...</div>
<div class="line">16  b.x</div>
<div class="line">20  b.y</div>
<div class="line">24  b.z</div>
<div class="line">28  ...</div>
<div class="line">32  c.x</div>
<div class="line">36  c.y</div>
<div class="line">40  c.z</div>
<div class="line">44  ...</div>
</div><!-- fragment --><p>Les <code><a class="el" href="structvec3.html" title="vecteur generique, utilitaire.">vec3</a></code> occupent la place de 4 <code>float</code>, soit 16 octets. De manière générale, dans un shader :</p><ul>
<li>4 octets pour les <code>int</code>, <code>float</code> et <code>bool</code>,</li>
<li>2x<code>float</code> pour les <code><a class="el" href="structvec2.html" title="vecteur generique, utilitaire.">vec2</a></code>, ou 2x type de base pour ivec2, uvec2 et bvec2,</li>
<li>4x<code>float</code> pour les <code><a class="el" href="structvec3.html" title="vecteur generique, utilitaire.">vec3</a></code>, ou 4x type de base pour ivec3, uvec3 et bvec3</li>
<li>4x<code>float</code> pour les <code><a class="el" href="structvec4.html" title="vecteur generique 4d, ou 3d homogene, utilitaire.">vec4</a></code>, ou 4x type de base pour ivec4, uvec4 et bvec4</li>
</ul>
<p>Par défaut les éléments d'un tableau sont alignés sur 16 octets, quelque soit le type de l'élement. un <code>int t[1]</code> ou <code>int t[2]</code> occupent 16 octets dans un buffer... Mais il est aussi possible de choisir un alignement un peu plus économique en mémoire, il faut décorer la déclaration avec <code>layout(std430)</code>, les éléments d'un tableau sont alignés normalement, en fonction de leur type, mais la taille de la structure doit être un multiple de son membre le plus important, pour que toutes les variables du tableau restent alignées correctement pour le gpu.</p>
<div class="fragment"><div class="line">layout(std430) readonly buffer triangleData </div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structTriangle.html">Triangle</a> triangles[];</div>
<div class="line">};</div>
</div><!-- fragment --><p><code>triangles[0].a</code> et <code>triangle[1].a</code> doivent être tous les deux alignés sur un multiple de 16 octets (4x<code>float</code>), donc la taille de la structure doit être aussi un multiple de 16.</p>
<h2><a class="anchor" id="autotoc_md111"></a>
preparer des données alignées...</h2>
<p>Question pratique, comment remplir simplement un buffer avec les variables organisées correctement pour les shaders, et comment vérifier que tout est correct ?</p>
<h3><a class="anchor" id="autotoc_md112"></a>
à la main...</h3>
<p>Une solution directe consiste tout simplement à ne pas utiliser de vecteurs à 3 composantes. Dans le cas général, ce n'est pas suffisant, il peut être nécessaire de déclarer une ou plusieurs variables supplémentaires dans la structure pour respecter l'alignement gpu : </p><div class="fragment"><div class="line"><span class="comment">// alignement std430 sur cpu</span></div>
<div class="line"><span class="keyword">struct </span>Triangle430</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a> a;</div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a> b;</div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a> c;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ou en gardant vec3 + une variable supplementaire </span></div>
<div class="line"><span class="keyword">struct </span>Triangle430pad</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> a;</div>
<div class="line">    <span class="keywordtype">float</span> pad0;</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> b;</div>
<div class="line">    <span class="keywordtype">float</span> pad1;</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> c;</div>
<div class="line">    <span class="keywordtype">float</span> pad2;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// remarque: ces 2 solutions sont équivalentes, elles construisent la même organisation mémoire</span></div>
</div><!-- fragment --><p>autre exemple : </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Data</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a> a;</div>
<div class="line">    <a class="code" href="structvec2.html">vec2</a> b;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">layout(std430, binding= 0) readonly buffer bufferData</div>
<div class="line">{</div>
<div class="line">    Data data[];</div>
<div class="line">};</div>
</div><!-- fragment --><p>La taille de la structure <code>Data</code> est de 4x4 + 4x2 = 24 octets. Pour que toutes les cellules du tableau <code>data[]</code> soient alignées correctement, il faut que la taille de la structure Data soit elle aussi un multiple de 16 (alignement nécessaire pour le champ <code><a class="el" href="structvec4.html" title="vecteur generique 4d, ou 3d homogene, utilitaire.">vec4</a> a</code>), il faut donc ajouter 2 float supplémentaires pour que data[0].a et data[1].a restent alignés sur un multiple de 16. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Data</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a> a;</div>
<div class="line">    <a class="code" href="structvec2.html">vec2</a> b;</div>
<div class="line">    <span class="keywordtype">float</span> pad0;</div>
<div class="line">    <span class="keywordtype">float</span> pad1;</div>
<div class="line">    <span class="comment">// ou</span></div>
<div class="line">    <span class="comment">// vec2 pad;</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>cf <a class="el" href="tuto__storage__buffer_8cpp.html">tuto_storage_buffer.cpp</a> pour une version plus complète.</p>
<h3><a class="anchor" id="autotoc_md113"></a>
en utilisant le compilateur C++</h3>
<p>Les compilateurs C et C++ permettent de modifier l'alignement des variables en c++11 avec : <code>alignas(n)</code> avec <code>n</code> l'alignement d'une variable en octets.</p>
<p>on peut donc déclarer une structure glsl::vec3, compatible avec les shaders : </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>glsl {</div>
<div class="line">    <span class="keyword">struct </span><span class="keyword">alignas</span>(16) <a class="code" href="structvec3.html">vec3</a></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">float</span> x, y, z;</div>
<div class="line">    };</div>
<div class="line">}</div>
</div><!-- fragment --><p>et l'utiliser directement : </p><div class="fragment"><div class="line"><span class="keyword">struct </span>TriangleGLSL</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structglsl_1_1gvec3.html">glsl::vec3</a> a;</div>
<div class="line">    <a class="code" href="structglsl_1_1gvec3.html">glsl::vec3</a> b;</div>
<div class="line">    <a class="code" href="structglsl_1_1gvec3.html">glsl::vec3</a> c;</div>
<div class="line">};</div>
</div><!-- fragment --><p>cf <a class="el" href="tuto__storage__buffer_8cpp.html">tuto_storage_buffer.cpp</a> pour une version plus complète qui aligne le block suivant : </p><div class="fragment"><div class="line"><span class="keyword">struct </span>vertex</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> position;</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> normal;</div>
<div class="line">    <a class="code" href="structvec2.html">vec2</a> texcoord;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">layout(std430, binding= 0) readonly buffer vertexData</div>
<div class="line">{</div>
<div class="line">    vertex data[];</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md114"></a>
exemple d'utilisation</h3>
<p>La solution directe consiste à préparer un <code>std::vector</code> d'une structure utilisant des membres alignés et à allouer le buffer : </p><div class="fragment"><div class="line"><span class="keyword">struct </span>TriangleGLSL</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structglsl_1_1gvec3.html">glsl::vec3</a> a;</div>
<div class="line">    <a class="code" href="structglsl_1_1gvec3.html">glsl::vec3</a> b;</div>
<div class="line">    <a class="code" href="structglsl_1_1gvec3.html">glsl::vec3</a> c;</div>
<div class="line"> </div>
<div class="line">    TriangleGLSL( <span class="keyword">const</span> <a class="code" href="structPoint.html">Point</a>&amp; _a, <span class="keyword">const</span> <a class="code" href="structPoint.html">Point</a>&amp; _b, <span class="keyword">const</span> <a class="code" href="structPoint.html">Point</a>&amp; _c ) : a(_a), b(_b), c(_c) {}</div>
<div class="line">    TriangleGLSL( <span class="keyword">const</span> <a class="code" href="structvec3.html">vec3</a>&amp; _a, <span class="keyword">const</span> <a class="code" href="structvec3.html">vec3</a>&amp; _b, <span class="keyword">const</span> <a class="code" href="structvec3.html">vec3</a>&amp; _c ) : a(_a), b(_b), c(_c) {}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">std::vector&lt;TriangleGLSL&gt; triangles;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i= 0; i &lt; n; i++)</div>
<div class="line">    triangles.push_back( TriangleGLSL( {...}, {...}, {...} ) );</div>
<div class="line"> </div>
<div class="line">GLuint buffer;</div>
<div class="line">glGenBuffers(1, &amp;buffer);</div>
<div class="line"> </div>
<div class="line">glBindBuffer(GL_SHADER_STORAGE_BUFFER, buffer);</div>
<div class="line">glBufferData(GL_SHADER_STORAGE_BUFFER, <span class="keyword">sizeof</span>(TriangleGLSL) * triangles.size(), triangles.data(), GL_STATIC_READ);</div>
</div><!-- fragment --><p>cf <a class="el" href="tuto__storage__buffer_8cpp.html">tuto_storage_buffer.cpp</a></p>
<h3><a class="anchor" id="autotoc_md115"></a>
vérifier l'alignement</h3>
<p>En cas de doute sur l'organisation mémoire d'un block, comment connaître la position des variables ? openGL 4.3 a introduit 2 fonctions <code>glGetProgramInterface( ) / glGetProgramResource( )</code> permettant d'énumérer les blocks associés à des buffers et de récupérer l'organisation mémoire des variables déclarées dans ces blocks. Comme d'habitude, il faut commencer par récupérer le nombre de blocks et le nombre de variables du block afin de pouvoir itérer sur les variables.</p>
<div class="fragment"><div class="line"><span class="comment">// recupere le nombre de blocks</span></div>
<div class="line">GLint buffer_count= 0;</div>
<div class="line">glGetProgramInterfaceiv(program, GL_SHADER_STORAGE_BLOCK, GL_ACTIVE_RESOURCES, &amp;buffer_count);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// pour chaque block</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i= 0; i &lt; buffer_count; i++)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// recupere le nombre de variables</span></div>
<div class="line">    GLint variable_count= 0;</div>
<div class="line">    {</div>
<div class="line">        GLenum prop[]= { GL_NUM_ACTIVE_VARIABLES };</div>
<div class="line">        glGetProgramResourceiv(program, GL_SHADER_STORAGE_BLOCK, i, 1, prop, 1, NULL, &amp;variable_count);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// recupere les indices des variables du block</span></div>
<div class="line">    std::vector&lt;GLint&gt; variables(variable_count);</div>
<div class="line">    {</div>
<div class="line">        GLenum prop[]= { GL_ACTIVE_VARIABLES };</div>
<div class="line">        glGetProgramResourceiv(program, GL_SHADER_STORAGE_BLOCK, i, 1, prop, variable_count, NULL, variables.data());</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// recupere l&#39;organisation mémoire d&#39;une variable / la position de la variable dans le buffer.</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k= 0; k &lt; variable_count; k++)</div>
<div class="line">    {</div>
<div class="line">        GLint offset= 0;</div>
<div class="line">        GLenum props[]= { GL_OFFSET };</div>
<div class="line">        glGetProgramResourceiv(program, GL_BUFFER_VARIABLE, variables[k], 1, props, 1, NULL, &amp;offset);</div>
<div class="line">        </div>
<div class="line">        <a class="code" href="group__application.html#ga6efbb9298a8f73b9a17959b56ec20267">printf</a>(<span class="stringliteral">&quot;offset %d\n&quot;</span>, offset);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>cf <a class="el" href="tuto__storage_8cpp.html">tuto_storage.cpp</a> pour une version plus complète, qui récupère aussi le nom, le type de chaque variable ainsi que l'organisation des tableaux et des matrices.</p>
<div class="fragment"><div class="line">loading program <span class="stringliteral">&#39;tutos/storage.glsl&#39;</span>...</div>
<div class="line">  buffer <span class="stringliteral">&#39;vertexData&#39;</span> binding 0</div>
<div class="line">    <span class="stringliteral">&#39;vec3 triangles[0].a&#39;</span>: offset 0, top level stride 48</div>
<div class="line">    <span class="stringliteral">&#39;vec3 triangles[0].b&#39;</span>: offset 16, top level stride 48</div>
<div class="line">    <span class="stringliteral">&#39;vec3 triangles[0].c&#39;</span>: offset 32, top level stride 48</div>
</div><!-- fragment --> </div><!-- contents -->
<div class="ttc" id="astructTriangle_html"><div class="ttname"><a href="structTriangle.html">Triangle</a></div><div class="ttdef"><b>Definition:</b> <a href="tuto__is_8cpp_source.html#l00050">tuto_is.cpp:50</a></div></div>
<div class="ttc" id="astructPoint_html"><div class="ttname"><a href="structPoint.html">Point</a></div><div class="ttdoc">representation d'un point 3d.</div><div class="ttdef"><b>Definition:</b> <a href="vec_8h_source.html#l00020">vec.h:20</a></div></div>
<div class="ttc" id="astructvec3_html"><div class="ttname"><a href="structvec3.html">vec3</a></div><div class="ttdoc">vecteur generique, utilitaire.</div><div class="ttdef"><b>Definition:</b> <a href="vec_8h_source.html#l00144">vec.h:144</a></div></div>
<div class="ttc" id="astructvec2_html"><div class="ttname"><a href="structvec2.html">vec2</a></div><div class="ttdoc">vecteur generique, utilitaire.</div><div class="ttdef"><b>Definition:</b> <a href="vec_8h_source.html#l00129">vec.h:129</a></div></div>
<div class="ttc" id="astructvec4_html"><div class="ttname"><a href="structvec4.html">vec4</a></div><div class="ttdoc">vecteur generique 4d, ou 3d homogene, utilitaire.</div><div class="ttdef"><b>Definition:</b> <a href="vec_8h_source.html#l00166">vec.h:166</a></div></div>
<div class="ttc" id="agroup__application_html_ga6efbb9298a8f73b9a17959b56ec20267"><div class="ttname"><a href="group__application.html#ga6efbb9298a8f73b9a17959b56ec20267">printf</a></div><div class="ttdeci">void printf(Text &amp;text, const int px, const int py, const char *format,...)</div><div class="ttdoc">affiche un texte a la position x, y. meme utilisation que printf().</div><div class="ttdef"><b>Definition:</b> <a href="text_8cpp_source.html#l00140">text.cpp:140</a></div></div>
<div class="ttc" id="astructglsl_1_1gvec3_html"><div class="ttname"><a href="structglsl_1_1gvec3.html">glsl::gvec3</a></div><div class="ttdef"><b>Definition:</b> <a href="tuto__storage_8cpp_source.html#l00032">tuto_storage.cpp:32</a></div></div>
<div class="ttc" id="astructTriangleData_html_a2b8f37f18e7b3bcec20bb38e6d7d7595"><div class="ttname"><a href="structTriangleData.html#a2b8f37f18e7b3bcec20bb38e6d7d7595">TriangleData::c</a></div><div class="ttdeci">vec3 c</div><div class="ttdoc">positions</div><div class="ttdef"><b>Definition:</b> <a href="mesh_8h_source.html#l00101">mesh.h:101</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 9 2019 15:39:11 for gKit2 light by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
