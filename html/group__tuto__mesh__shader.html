<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gKit2 light: tuto9.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">gKit2 light
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">tuto9.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<p>cf <a class="el" href="tuto9_8cpp.html">tuto9.cpp</a></p>
<p><a class="el" href="classMesh.html#a8ff099e922cde829f1d93adcada045cd">Mesh::draw( )</a> et les utilitaires <a class="el" href="classDrawParam.html">DrawParam</a> de <a class="el" href="draw_8h.html">draw.h</a> dessinent l'objet avec un shader crée en fonction de la description de l'objet et des paramètres. Il est aussi très simple de continuer à utiliser <a class="el" href="classMesh.html" title="representation d&#39;un objet / maillage.">Mesh</a> pour décrire l'objet et de le dessiner avec un shader différent, cf Mesh::draw( const GLuint program, ... ). Il faut par contre créer et configurer le shader avant de pouvoir dessiner l'objet, ainsi que respecter la même convention que <a class="el" href="classMesh.html" title="representation d&#39;un objet / maillage.">Mesh</a> pour décrire les sommets.</p>
<p>repassez dans <a class="el" href="group__intro3d.html">introduction api 3d, openGL et pipeline graphique</a> et <a class="el" href="group__glsl.html">shaders et GLSL</a>, si nécessaire.</p>
<h2><a class="anchor" id="autotoc_md93"></a>
créer un shader program</h2>
<p>les détails sont dans <a class="el" href="group__tuto2GL.html">compiler et linker un shader program</a>, le plus simple est d'utiliser l'utilitaire <a class="el" href="group__openGL.html#ga2d6e7b012b252577cc04bf9abdc4c5ba">read_program()</a> fournit par <a class="el" href="program_8h.html">program.h</a> :</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="program_8h.html">program.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line">GLuint program= 0;</div>
<div class="line"> </div>
<div class="line">program= <a class="code" href="group__openGL.html#ga2d6e7b012b252577cc04bf9abdc4c5ba">read_program</a>(<span class="stringliteral">&quot;...&quot;</span>);</div>
<div class="line"><a class="code" href="group__openGL.html#ga873fe3eb898a9ffe19c8274f83116b8a">program_print_errors</a>(program);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md94"></a>
configurer un shader program</h2>
<p>les shaders sont des fonctions comme les autres, pour produire leurs résultats, il faut d'abord affecter une valeur à leurs paramètres avant de pouvoir les exécuter. par exemple, un vertex shader déclare, en général, 2 types de paramètres : les uniforms et les attributs de sommet (la position, la couleur, la normale, etc...)</p>
<p><em>pourquoi ?</em></p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifdef VERTEX_SHADER</span></div>
<div class="line"> </div>
<div class="line">uniform mat4 mvpMatrix; <span class="comment">// la transformation à appliquer aux sommets, mot-clé : uniform</span></div>
<div class="line"> </div>
<div class="line">in <a class="code" href="structvec3.html">vec3</a> position;       <span class="comment">// la position d&#39;un sommet, mot-clé : in</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main( )</div>
<div class="line">{</div>
<div class="line">    gl_Position= mvpMatrix * <a class="code" href="structvec4.html">vec4</a>(position, 1);</div>
<div class="line">}</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p>Les shaders (et le reste du pipeline graphique) sont exécutés par les processeurs de la carte graphique au moment ou l'application utilise <code>glDrawArrays(GL_TRIANGLES, 0, n);</code> ce qui signifie "dessine des triangles avec les sommets d'indice 0 à n-1", soit n/3 triangles.</p>
<p>Les processeurs de la carte graphique transforment tous les sommets en parallèle : un vertex shader (la fonction ci-dessus) est exécutée pour transformer un seul sommet. il faut donc affecter une valeur aux paramètres <code>mvpMatrix</code> et <code>position</code> pour chaque appel de la fonction afin de transformer tous les sommets. La matrice de transformation est la même pour tous les sommets, par contre, la position du sommet change chaque fois que la fonction est appellée... et comme tous les appels sont fait en même temps, toutes les valeurs de <code>position</code> doivent être accessibles, quelquepart dans la mémoire de la carte graphique (ce sont les buffers d'openGL qui permettent de stocker ces valeurs).</p>
<p>C'est pour cette raison que les paramètres <code>mvpMatrix</code> et <code>position</code> sont déclarés avec des mots-clés différents, <code>uniform</code> pour indiquer que tous les vertex shaders utilisent la même transformation (la même matrice) et le mot-clé <code>in</code> pour indiquer que la valeur de la position change à chaque appel, pour chaque sommet. Et bien sur, affecter une (seule) valeur à un uniform est différent d'affecter un ensemble de valeurs à un attribut. <a class="el" href="classMesh.html" title="representation d&#39;un objet / maillage.">Mesh</a> s'occuppe des attributs, le plus "complique", mais il reste les uniforms...</p>
<p>Par contre, il faut respecter la convention utilisée par <a class="el" href="classMesh.html" title="representation d&#39;un objet / maillage.">Mesh</a>, qui numérote les attributs des sommets et impose un type qu'il faut respecter :</p><ul>
<li>attribut 0, <code><a class="el" href="structvec3.html" title="vecteur generique, utilitaire.">vec3</a> position</code>,</li>
<li>attribut 1, <code><a class="el" href="structvec2.html" title="vecteur generique, utilitaire.">vec2</a> texcoord</code>,</li>
<li>attribut 2, <code><a class="el" href="structvec3.html" title="vecteur generique, utilitaire.">vec3</a> normal</code>,</li>
<li>attribut 3, <code><a class="el" href="structvec4.html" title="vecteur generique 4d, ou 3d homogene, utilitaire.">vec4</a> color</code>.</li>
</ul>
<p>voila la déclaration à utiliser dans le vertex shader, en fonction des attributs nécessaires : </p><div class="fragment"><div class="line">layout(location= 0) in <a class="code" href="structvec3.html">vec3</a> position;</div>
<div class="line">layout(location= 1) in <a class="code" href="structvec2.html">vec2</a> texcoord;</div>
<div class="line">layout(location= 2) in <a class="code" href="structvec3.html">vec3</a> normal;</div>
<div class="line">layout(location= 3) in <a class="code" href="structvec4.html">vec4</a> color;</div>
</div><!-- fragment --><p>relisez le résumé de GLSL, le langage des shaders, <a class="el" href="group__glsl.html">shaders et GLSL</a> si nécessaire, et <a class="el" href="group__tuto3GL.html">afficher plusieurs triangles, modifier les paramètres uniform d'un shader program</a> également qui explique comment openGL permet d'affecter une valeur à chaque uniform déclaré dans les shaders.</p>
<p>sinon, <a class="el" href="uniforms_8h.html">uniforms.h</a> fournit plusieurs utilitaires simplifiés : </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="uniforms_8h.html">uniforms.h</a>&quot;</span></div>
<div class="line"><span class="comment">// selectionner le shader program, si necessaire</span></div>
<div class="line"><span class="comment">// glUseProgram(program);</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="structTransform.html">Transform</a> mvp= { ... };</div>
<div class="line"><a class="code" href="group__openGL.html#ga4464cbf6223da0a918e0d81c55b2c05b">program_uniform</a>(program, <span class="stringliteral">&quot;mvpMatrix&quot;</span>, mvp);</div>
<div class="line"><span class="comment">//   ou, directement en utilisant openGL :</span></div>
<div class="line"><span class="comment">//   int location= glGetUniformLocation(program, &quot;mvpMatrix&quot;);</span></div>
<div class="line"><span class="comment">//   glUniformMatrix4fv(location, 1, GL_TRUE, mvp.buffer());</span></div>
</div><!-- fragment --><p>Pour calculer la transformation mvp, qui permet de projeter directement un sommet sur la camera, il faut savoir ou se trouve l'objet dans le monde, ou se trouve la camera et quelle est sa projection, c'est à dire les transformations / matrices model, view et projection. Jusqu'à présent afficher un objet ressemblait à ça : </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="mat_8h.html">mat.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="mesh_8h.html">mesh.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="orbiter_8h.html">orbiter.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="draw_8h.html">draw.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="classMesh.html">Mesh</a> mesh= { ... };</div>
<div class="line"><a class="code" href="structTransform.html">Transform</a> model= { ... };   <span class="comment">// placer l&#39;objet dans le monde</span></div>
<div class="line"><a class="code" href="classOrbiter.html">Orbiter</a> camera= { ... };    <span class="comment">// une camera qui observe l&#39;obet </span></div>
<div class="line"> </div>
<div class="line">draw(mesh, model, camera);</div>
</div><!-- fragment --><p>La camera calcule les transformations view et projection, il suffit de les recupérer et de composer model, view, et projection pour obtenir une seule matrice qui enchaine les 3 changements de repères : </p><div class="fragment"><div class="line"><a class="code" href="classOrbiter.html">Orbiter</a> camera= { ... };    <span class="comment">// une camera qui observe l&#39;obet </span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="structTransform.html">Transform</a> view= camera.<a class="code" href="classOrbiter.html#af72f8177ec74237d2827aa2492cbec45">view</a>();</div>
<div class="line"><a class="code" href="structTransform.html">Transform</a> projection= camera.<a class="code" href="classOrbiter.html#af9ca7a9e5ca8407a3089dee63a710d52">projection</a>();</div>
<div class="line"><a class="code" href="structTransform.html">Transform</a> model= { ... };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// composition des 3 changements de repères</span></div>
<div class="line"><a class="code" href="structTransform.html">Transform</a> mvp= projection * view * model;   <span class="comment">// P(V(M*p))</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md95"></a>
dessiner</h2>
<p>Une fois le shader program complètement paramétré, il ne reste plus qu'à dessiner l'objet : </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="color_8h.html">color.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="mesh_8h.html">mesh.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="uniforms_8h.html">uniforms.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="draw_8h.html">draw.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="classMesh.html">Mesh</a> mesh= { ... };</div>
<div class="line">GLuint program= { ... };</div>
<div class="line"><span class="comment">// selectionner le program, si necessaire</span></div>
<div class="line"><span class="comment">// glUseProgram(program);</span></div>
<div class="line"><a class="code" href="group__openGL.html#ga4464cbf6223da0a918e0d81c55b2c05b">program_uniform</a>(program, <span class="stringliteral">&quot;mvpMatrix&quot;</span>, mvp);</div>
<div class="line"><a class="code" href="group__openGL.html#ga4464cbf6223da0a918e0d81c55b2c05b">program_uniform</a>(program, <span class="stringliteral">&quot;color&quot;</span>, <a class="code" href="group__image.html#ga24f865fa57fe11096a8ca1cb62f6dd21">Red</a>());</div>
<div class="line"> </div>
<div class="line"><span class="comment">//   ou, directement en utilisant openGL :</span></div>
<div class="line"><span class="comment">//   int location= glGetUniformLocation(program, &quot;mvpMatrix&quot;);</span></div>
<div class="line"><span class="comment">//   glUniformMatrix4fv(location, 1, GL_TRUE, mvp.buffer());</span></div>
<div class="line"><span class="comment">//   int location= glGetUniformLocation(program, &quot;color&quot;);</span></div>
<div class="line"><span class="comment">//   glUniform4f(location, 1, 1, 0, 1);</span></div>
<div class="line">    </div>
<div class="line">draw(mesh, program);</div>
</div><!-- fragment --><p>cf <a class="el" href="tuto9_8cpp.html">tuto9.cpp</a> pour un exemple complet qui utilise un uniform supplémentaire, qui permet de donner la même couleur aux pixels de l'objet.</p>
<p>par défaut, <a class="el" href="classMesh.html" title="representation d&#39;un objet / maillage.">Mesh</a> transfère tous les attributs, il est possible d'indiquer à draw( ) de n'utiliser que les attributs déclarés que le vertex shader : </p><div class="fragment"><div class="line">draw(mesh, program, <span class="comment">/* use position */</span> <span class="keyword">true</span>, <span class="comment">/* use texcoord */</span> <span class="keyword">false</span>, <span class="comment">/* use normal */</span> <span class="keyword">false</span>, <span class="comment">/* use color */</span> <span class="keyword">false</span>);</div>
</div><!-- fragment --><p>draw( ) vérifie (en mode debug, en tout cas) que les attributs déclarés dans le vertex shader sont disponibles dans le <a class="el" href="classMesh.html" title="representation d&#39;un objet / maillage.">Mesh</a>. par exemple, si le vertex shader déclare un attribut normale par sommet mais que ces valeurs ne sont pas dans le <a class="el" href="classMesh.html" title="representation d&#39;un objet / maillage.">Mesh</a>, le shader ne peut pas fonctionner...</p>
<p>cf <a class="el" href="group__tuto__mesh__buffer.html">tuto9_buffers.cpp</a> pour un exemple complet qui alloue et initialise un buffer pour stocker les positions des sommets du <a class="el" href="classMesh.html" title="representation d&#39;un objet / maillage.">Mesh</a> et qui configure un format de sommet (un vertex array object) pour dessiner un objet directement avec openGL, sans utiliser les utilitaires draw( ).</p>
<h2><a class="anchor" id="autotoc_md96"></a>
debugger un shader</h2>
<p>relancer l'application à chaque fois qu'un shader plante, n'est pas très pratique, il est possible de recharger les shaders à la volée, sans quitter l'application, cf reload_program() de <code><a class="el" href="program_8h.html">program.h</a></code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="program_8h.html">program.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="window_8h.html">window.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line">GLuint program;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// init( ) :</span></div>
<div class="line">    program=<a class="code" href="group__openGL.html#ga2d6e7b012b252577cc04bf9abdc4c5ba">read_program</a>(<span class="stringliteral">&quot;tutos/tuto9_color.glsl&quot;</span>);</div>
<div class="line">    <a class="code" href="group__openGL.html#ga873fe3eb898a9ffe19c8274f83116b8a">program_print_errors</a>(program);</div>
<div class="line">    </div>
<div class="line"><span class="comment">// draw( ) :</span></div>
<div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__application.html#gaab3200e25979a4c8db0238b880b8473d">key_state</a>(<span class="charliteral">&#39;r&#39;</span>))</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="group__application.html#ga6dc30441deb49055fc010b25478aac80">clear_key_state</a>(<span class="charliteral">&#39;r&#39;</span>);</div>
<div class="line">        reload_program(program, <span class="stringliteral">&quot;tutos/tuto9_color.glsl&quot;</span>);</div>
<div class="line">        <a class="code" href="group__openGL.html#ga873fe3eb898a9ffe19c8274f83116b8a">program_print_errors</a>(program);</div>
<div class="line">    }</div>
</div><!-- fragment --><p><b>attention :</b> les uniforms sont re-initialisés à 0 par la compilation d'un shader.</p>
<h2><a class="anchor" id="autotoc_md97"></a>
et avec une texture ?</h2>
<p>Il y a plusieurs étapes :</p><ul>
<li>d'abord charger la texture, cf GLuint texture= read_texture(0, fichier ); documenté dans <a class="el" href="texture_8h.html">texture.h</a>,</li>
<li>vérifier que les sommets de l'objet à dessiner sont bien associés à des coordonnées de texture, cf <a class="el" href="classMesh.html#a1af36a6ca8b3d6a4f672f27ec7646e87" title="definit les coordonnees de texture du prochain sommet.">Mesh::texcoord()</a> pour décrire les attributs de sommet, ou <a class="el" href="classMesh.html#a06943d2f4e1a6c64c62d37945c3b3fa8" title="renvoie la taille (en octets) du texcoord buffer.">Mesh::texcoord_buffer_size()</a>, pour vérifier que les coordonnées de texture sont bien présentes,</li>
<li>déclarer l'attribut dans le vertex shader, cf layout(location= 1) in <a class="el" href="structvec2.html" title="vecteur generique, utilitaire.">vec2</a> texcoord;</li>
<li>transmettre les texcoord au fragment shader,</li>
<li>lire la texture dans la fragment shader, aux bonnes coordonnées.</li>
</ul>
<p>Lisez la section "écrire le fragment shader (et le vertex shader)" dans <a class="el" href="group__tuto5GL.html">textures, samplers et pipeline</a> pour comprendre comment les différents morceaux se connectent ensemble.</p>
<p>Dernière étape, configurer le pipeline pour utiliser la texture, vous pouvez lire les détails dans <a class="el" href="group__tuto5GL.html">textures, samplers et pipeline</a> ou utiliser l'utilitaire <a class="el" href="group__openGL.html#gaa1d4b5856f4a5f571f9380572a26bbe3" title="configure le pipeline et le shader program pour utiliser une texture, et des parametres de filtrages,...">program_use_texture( )</a>; </p><div class="fragment"><div class="line"><span class="comment">// init( ) :</span></div>
<div class="line">    <span class="comment">// verifie que l&#39;objet a bien des coordonnées de texture</span></div>
<div class="line">    <span class="keywordflow">if</span>(m_objet.texcoord_buffer_size() == 0)</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;erreur, pas de texcoords...&quot;</span>;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// charge une texture sur l&#39;unite 0</span></div>
<div class="line">    m_texture= <a class="code" href="group__openGL.html#gab752f06d2afe33f1e865d7c4dce5fa4f">read_texture</a>(0, <span class="stringliteral">&quot;...&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// render( ) :</span></div>
<div class="line">    <span class="comment">// selectionner le shader program, si necessaire</span></div>
<div class="line">    <span class="comment">// glUseProgram(program);</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// . parametres &quot;supplementaires&quot; :</span></div>
<div class="line">    <span class="comment">//   . utilisation d&#39;une texture configuree sur l&#39;unite 0, cf texture= read_texture(0, &quot;...&quot;);</span></div>
<div class="line">    <a class="code" href="group__openGL.html#gaa1d4b5856f4a5f571f9380572a26bbe3">program_use_texture</a>(program, <span class="stringliteral">&quot;texture0&quot;</span>, 0, m_texture);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// go !</span></div>
<div class="line">    m_objet.draw(m_program);</div>
</div><!-- fragment --><p> cf <a class="el" href="tuto9__texture1_8cpp.html">tuto9_texture1.cpp</a> pour un exemple complet qui charge une texture.</p>
<h2><a class="anchor" id="autotoc_md98"></a>
et avec plusieurs textures ?</h2>
<p>C'est la même chose, par contre, il faut charger et configurer une unité de texture par image / texture à utiliser et déclarer un sampler2D par texture dans le shader. </p><div class="fragment"><div class="line"><span class="comment">// init( ) :</span></div>
<div class="line">    <span class="comment">// verifie que l&#39;objet a bien des coordonnées de texture</span></div>
<div class="line">    <span class="keywordflow">if</span>(m_objet.texcoord_buffer_size() == 0)</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;erreur, pas de texcoords...&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// charge une texture sur l&#39;unite 0</span></div>
<div class="line">    m_texture0= <a class="code" href="group__openGL.html#gab752f06d2afe33f1e865d7c4dce5fa4f">read_texture</a>(0, <span class="stringliteral">&quot;...&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// charge une texture sur l&#39;unite 1</span></div>
<div class="line">    m_texture1= <a class="code" href="group__openGL.html#gab752f06d2afe33f1e865d7c4dce5fa4f">read_texture</a>(1, <span class="stringliteral">&quot;...&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// render( ) :</span></div>
<div class="line">    <span class="comment">// selectionner le shader program, si necessaire</span></div>
<div class="line">    <span class="comment">// glUseProgram(program);</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// . parametres &quot;supplementaires&quot; :</span></div>
<div class="line">    <span class="comment">//   . utilisation d&#39;une texture configuree sur l&#39;unite 0, cf texture= read_texture(0, &quot;...&quot;);</span></div>
<div class="line">    <a class="code" href="group__openGL.html#gaa1d4b5856f4a5f571f9380572a26bbe3">program_use_texture</a>(program, <span class="stringliteral">&quot;texture0&quot;</span>, 0, m_texture0);    <span class="comment">// le shader déclare: uniform sampler2D texture0;</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">//   . utilisation d&#39;une texture configuree sur l&#39;unite 1, cf texture= read_texture(1, &quot;...&quot;);</span></div>
<div class="line">    <a class="code" href="group__openGL.html#gaa1d4b5856f4a5f571f9380572a26bbe3">program_use_texture</a>(program, <span class="stringliteral">&quot;texture1&quot;</span>, 1, m_texture1);    <span class="comment">// le shader déclare: uniform sampler2D texture1;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// go !</span></div>
<div class="line">    m_objet.draw(m_program);</div>
</div><!-- fragment --><p>cf <a class="el" href="tuto9__textures_8cpp.html">tuto9_textures.cpp</a> pour un exemple complet qui charge et utilise 2 textures. </p>
</div><!-- contents -->
<div class="ttc" id="aclassOrbiter_html_af9ca7a9e5ca8407a3089dee63a710d52"><div class="ttname"><a href="classOrbiter.html#af9ca7a9e5ca8407a3089dee63a710d52">Orbiter::projection</a></div><div class="ttdeci">Transform projection(const float width, const float height, const float fov) const</div><div class="ttdoc">renvoie la projection reglee pour une image d'aspect width / height, et une ouverture de fov degres.</div><div class="ttdef"><b>Definition:</b> <a href="orbiter_8cpp_source.html#l00047">orbiter.cpp:47</a></div></div>
<div class="ttc" id="agroup__openGL_html_ga2d6e7b012b252577cc04bf9abdc4c5ba"><div class="ttname"><a href="group__openGL.html#ga2d6e7b012b252577cc04bf9abdc4c5ba">read_program</a></div><div class="ttdeci">GLuint read_program(const char *filename, const char *definitions)</div><div class="ttdef"><b>Definition:</b> <a href="program_8cpp_source.html#l00203">program.cpp:203</a></div></div>
<div class="ttc" id="aprogram_8h_html"><div class="ttname"><a href="program_8h.html">program.h</a></div></div>
<div class="ttc" id="agroup__application_html_ga6dc30441deb49055fc010b25478aac80"><div class="ttname"><a href="group__application.html#ga6dc30441deb49055fc010b25478aac80">clear_key_state</a></div><div class="ttdeci">void clear_key_state(const SDL_Keycode key)</div><div class="ttdoc">desactive une touche du clavier.</div><div class="ttdef"><b>Definition:</b> <a href="window_8cpp_source.html#l00049">window.cpp:49</a></div></div>
<div class="ttc" id="agroup__openGL_html_ga4464cbf6223da0a918e0d81c55b2c05b"><div class="ttname"><a href="group__openGL.html#ga4464cbf6223da0a918e0d81c55b2c05b">program_uniform</a></div><div class="ttdeci">void program_uniform(const GLuint program, const char *uniform, const unsigned int v)</div><div class="ttdoc">affecte une valeur a un uniform du shader program. uint.</div><div class="ttdef"><b>Definition:</b> <a href="uniforms_8cpp_source.html#l00068">uniforms.cpp:68</a></div></div>
<div class="ttc" id="amat_8h_html"><div class="ttname"><a href="mat_8h.html">mat.h</a></div></div>
<div class="ttc" id="agroup__application_html_gaab3200e25979a4c8db0238b880b8473d"><div class="ttname"><a href="group__application.html#gaab3200e25979a4c8db0238b880b8473d">key_state</a></div><div class="ttdeci">int key_state(const SDL_Keycode key)</div><div class="ttdoc">renvoie l'etat d'une touche du clavier. cf la doc SDL2 pour les codes.</div><div class="ttdef"><b>Definition:</b> <a href="window_8cpp_source.html#l00043">window.cpp:43</a></div></div>
<div class="ttc" id="aclassOrbiter_html_af72f8177ec74237d2827aa2492cbec45"><div class="ttname"><a href="classOrbiter.html#af72f8177ec74237d2827aa2492cbec45">Orbiter::view</a></div><div class="ttdeci">Transform view() const</div><div class="ttdoc">renvoie la transformation vue.</div><div class="ttdef"><b>Definition:</b> <a href="orbiter_8cpp_source.html#l00040">orbiter.cpp:40</a></div></div>
<div class="ttc" id="aorbiter_8h_html"><div class="ttname"><a href="orbiter_8h.html">orbiter.h</a></div></div>
<div class="ttc" id="astructvec3_html"><div class="ttname"><a href="structvec3.html">vec3</a></div><div class="ttdoc">vecteur generique, utilitaire.</div><div class="ttdef"><b>Definition:</b> <a href="vec_8h_source.html#l00144">vec.h:144</a></div></div>
<div class="ttc" id="amesh_8h_html"><div class="ttname"><a href="mesh_8h.html">mesh.h</a></div></div>
<div class="ttc" id="astructvec2_html"><div class="ttname"><a href="structvec2.html">vec2</a></div><div class="ttdoc">vecteur generique, utilitaire.</div><div class="ttdef"><b>Definition:</b> <a href="vec_8h_source.html#l00129">vec.h:129</a></div></div>
<div class="ttc" id="adraw_8h_html"><div class="ttname"><a href="draw_8h.html">draw.h</a></div></div>
<div class="ttc" id="aclassMesh_html"><div class="ttname"><a href="classMesh.html">Mesh</a></div><div class="ttdoc">representation d'un objet / maillage.</div><div class="ttdef"><b>Definition:</b> <a href="mesh_8h_source.html#l00108">mesh.h:108</a></div></div>
<div class="ttc" id="agroup__openGL_html_gab752f06d2afe33f1e865d7c4dce5fa4f"><div class="ttname"><a href="group__openGL.html#gab752f06d2afe33f1e865d7c4dce5fa4f">read_texture</a></div><div class="ttdeci">GLuint read_texture(const int unit, const char *filename, const GLenum texel_type)</div><div class="ttdef"><b>Definition:</b> <a href="texture_8cpp_source.html#l00098">texture.cpp:98</a></div></div>
<div class="ttc" id="aclassOrbiter_html"><div class="ttname"><a href="classOrbiter.html">Orbiter</a></div><div class="ttdoc">representation de la camera, type orbiter, placee sur une sphere autour du centre de l'objet.</div><div class="ttdef"><b>Definition:</b> <a href="orbiter_8h_source.html#l00016">orbiter.h:16</a></div></div>
<div class="ttc" id="agroup__openGL_html_ga873fe3eb898a9ffe19c8274f83116b8a"><div class="ttname"><a href="group__openGL.html#ga873fe3eb898a9ffe19c8274f83116b8a">program_print_errors</a></div><div class="ttdeci">int program_print_errors(const GLuint program)</div><div class="ttdoc">affiche les erreurs de compilation.</div><div class="ttdef"><b>Definition:</b> <a href="program_8cpp_source.html#l00384">program.cpp:384</a></div></div>
<div class="ttc" id="agroup__image_html_ga24f865fa57fe11096a8ca1cb62f6dd21"><div class="ttname"><a href="group__image.html#ga24f865fa57fe11096a8ca1cb62f6dd21">Red</a></div><div class="ttdeci">Color Red()</div><div class="ttdoc">utilitaire. renvoie une couleur rouge.</div><div class="ttdef"><b>Definition:</b> <a href="color_8cpp_source.html#l00019">color.cpp:19</a></div></div>
<div class="ttc" id="astructvec4_html"><div class="ttname"><a href="structvec4.html">vec4</a></div><div class="ttdoc">vecteur generique 4d, ou 3d homogene, utilitaire.</div><div class="ttdef"><b>Definition:</b> <a href="vec_8h_source.html#l00166">vec.h:166</a></div></div>
<div class="ttc" id="awindow_8h_html"><div class="ttname"><a href="window_8h.html">window.h</a></div></div>
<div class="ttc" id="acolor_8h_html"><div class="ttname"><a href="color_8h.html">color.h</a></div></div>
<div class="ttc" id="astructTransform_html"><div class="ttname"><a href="structTransform.html">Transform</a></div><div class="ttdoc">representation d'une transformation, une matrice 4x4, organisee par ligne / row major.</div><div class="ttdef"><b>Definition:</b> <a href="mat_8h_source.html#l00020">mat.h:20</a></div></div>
<div class="ttc" id="auniforms_8h_html"><div class="ttname"><a href="uniforms_8h.html">uniforms.h</a></div></div>
<div class="ttc" id="agroup__openGL_html_gaa1d4b5856f4a5f571f9380572a26bbe3"><div class="ttname"><a href="group__openGL.html#gaa1d4b5856f4a5f571f9380572a26bbe3">program_use_texture</a></div><div class="ttdeci">void program_use_texture(const GLuint program, const char *uniform, const int unit, const GLuint texture, const GLuint sampler)</div><div class="ttdoc">configure le pipeline et le shader program pour utiliser une texture, et des parametres de filtrages,...</div><div class="ttdef"><b>Definition:</b> <a href="uniforms_8cpp_source.html#l00118">uniforms.cpp:118</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 9 2019 15:39:11 for gKit2 light by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
