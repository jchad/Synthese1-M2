<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gKit2 light: mini pipeline graphique</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">gKit2 light
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">mini pipeline graphique</div>  </div>
</div><!--header-->
<div class="contents">
<p>cf <a class="el" href="pipeline_8cpp.html">pipeline.cpp</a></p>
<p>la solution présentée dans <a class="el" href="group__intro3d.html">introduction api 3d, openGL et pipeline graphique</a> fonctionne correctement, dans les cas simples, lorsque les 3 sommets du triangle sont devant la camera.</p>
<p><em>indication :</em> les points derrière la caméra peuvent se projetter aussi sur l'image... par exemple, que se passe-t-il si un point à des coordonnées z et w négatives ? lorsque l'on calcule le point réel on divise z par w, et le résultat est positif... un sommet derriere la camera peut très bien se projetter dans l'image, il faut détecter ce problème avant de faire la projection, ou ne pas faire de projection...</p>
<p>il y a 2 types de solutions, soit decouper le triangle pour ne garder que la partie que l'on peut dessiner, soit ne pas faire de projection, puisque c'est elle qui introduit le probleme.</p>
<h2><a class="anchor" id="autotoc_md53"></a>
découper le triangle</h2>
<p>en regardant plus en détails, on s'apercoit qu'il n'y a qu'un cas qui est vraiment génant, c'est lorsqu'un sommet est derrière la camera. un sommet trop à gauche, ou trop à droite (trop haut, trop bas, et trop loin) n'est pas vraiment génant.</p>
<div class="image">
<img src="clipped.png" alt=""/>
</div>
<p>la solution est relativement simple : soit 1 sommet est derriere la camera, soit 2 sommets sont derrière (si les 3 sont derriere, il n'y a rien a dessiner). mais on se retrouve dans les 2 cas, avec un sommet d'un cote et les 2 de l'autre du plan proche de la projection. il suffit de couper les 2 aretes partant du sommet par le plan, pour obtenir soit un triangle que l'on peut dessiner directement, soit un trapeze, que l'on decoupe en 2 triangles que l'on peut ensuite dessiner.</p>
<p><em>remarque :</em> pourquoi ne pas couper par le plan qui passe par la camera ? les sommet sur ce plan ont par definition, z = 0, qui va etre genant pour calculer l'intersection des aretes et du plan... ou pour trouver le point homogène associé...</p>
<p>comment calculer l'intersection d'une arete avec le plan near dans l'espace homogene ? cf <a href="http://fabiensanglard.net/polygon_codec/clippingdocument/Clipping.pdf">"homogenous clipping"</a>, sections 8 et 9</p>
<h2><a class="anchor" id="autotoc_md54"></a>
sans projection</h2>
<p>l'autre categorie de solution utilise une approche différente qui ne fait pas de projection.</p>
<p>les tests d'inclusion des pixels se font en 2d, dans le plan image, après la projection. si on ne veut pas calculer la projection, il faut faire un test équivalent en 3d, avant la projection.</p>
<p>la solution est logique, au lieu de tester un pixel par rapport à un triangle, et de calculer des aires, il faut tester un point 3d par rapport à un... tetrahèdre et calculer des volumes.</p>
<p><em>remarque :</em> pour les curieux, toutes les explications sont dans <a href="http://cg.ivd.kit.edu/publications/p2012/3dr/gi2012.pdf">"3D Rasterization"</a> T. Davidovic, T. Engelhardt, I. Georgiev, 2012</p>
<p>le test d'inclusion d'un pixel p dans un triangle abc calcule les aires signées des triangles pab, pbc, pca. ce qui permet de vérifier que le pixel se trouve du "bon" coté de chaque arête du triangle.</p>
<p>pour le test 3d, la camera est le sommet du tetrahedre, e, et sa base est le triangle abc. le test d'inclusion du point p se transforme en calcul du volume signé des tetrahedres formés par le point p et les faces abc, eba ecb, eac. s'ils sont tous du même signe, p à est l'interieur du volume eabc, et le pixel fait parti du triangle. c'est le même test qu'avec l'aire, le volume sera positif si p se trouve du "bon" coté de chaque face du tetrahedre.</p>
<h2><a class="anchor" id="autotoc_md55"></a>
sans projection et dans l'espace homogene</h2>
<p>une derniere solution réalise le test "est ce que le centre du pixel est inclus dans le triangle" sans faire de projection, directement dans l'espace projectif homogène. cf <a href="http://diglib.eg.org/bitstream/handle/10.2312/EGGH.EGGH97.089-095/089-095.pdf?sequence=1&amp;isAllowed=y">"Triangle scan conversion using 2D Homogeneous coordinate"</a> M. Olano, T. Greer, 1997</p>
<p>une solution directe teste tous les pixels de l'image, ce qui n'est pas tres efficace. pour limiter le nombre de pixels teste, il possible de parcourir l'image de manière hiérarchique, en utilisant une grille, ou en suivant une courbe de remplissage, comme la <a href="https://en.wikipedia.org/wiki/Z-order_curve">courbe en Z</a>, ou la <a href="https://en.wikipedia.org/wiki/Hilbert_curve">courbe de Hilbert</a>, cf <a href="http://perso.univ-lyon1.fr/jean-claude.iehl/Public/educ/M2PROIMA/2007/incremental_and_hierarchical_hilbert_order_edge_equation_polygon_rasterization.pdf">"Incremental and Hierarchical Hilbert Order Edge Equation Polygon Rasterization"</a> M.D. McCool, C. Wales, K. Moule, 2001 </p>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 9 2019 15:39:11 for gKit2 light by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
