<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gKit2 light: introduction api 3d, openGL et pipeline graphique</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">gKit2 light
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">introduction api 3d, openGL et pipeline graphique</div>  </div>
</div><!--header-->
<div class="contents">
<h2><a class="anchor" id="autotoc_md43"></a>
introduction : une api 3d ? c'est quoi ?</h2>
<p>facile, c'est un ensemble de fonctions permettant de paramétrer un pipeline graphique pour dessiner des objets...</p>
<h2><a class="anchor" id="autotoc_md44"></a>
un pipeline graphique ? c'est quoi ?</h2>
<p>c'est l'ensemble de traitements qui permet de dessiner des objets.</p>
<h2><a class="anchor" id="autotoc_md45"></a>
et openGL ?</h2>
<p>c'est une api 3d permettant d'utiliser une carte graphique pour dessiner des objets.</p>
<h2><a class="anchor" id="autotoc_md46"></a>
et alors ?</h2>
<p>une api 3d permet de configurer et de paramétrer les différentes étapes d'un pipeline graphique. pour comprendre comment utiliser openGL, il faut avoir quelques idées sur le fonctionnement de ces étapes...</p>
<p>exemple : pour dessiner un point, il faut connaitre ses coordonnées, les convertir en position dans l'image et choisir une couleur pour le pixel. si on voulait construire un pipeline pour dessiner des points, il faudrait :</p><ul>
<li>les coordonnées du point : x et y dans le plan 2d, entre -1 et 1, par exemple,</li>
<li>la couleur du point : rouge, vert, bleu,</li>
<li>les dimensions de l'image : largeur, hauteur,</li>
<li>et l'image pour stocker le résultat.</li>
</ul>
<p>mais il faut aussi définir comment passer des coordonnées du point (entre -1 et 1) aux coordonnées du pixel dans l'image (entre largeur et hauteur).</p>
<p>pour dessiner un triangle, un pipeline à besoin de ces informations pour les 3 sommets du triangle. mais il y a des choix à faire : par exemple, si les 3 sommets n'ont pas la même couleur, laquelle choisir ?</p><ul>
<li>utiliser la couleur du premier sommet ?</li>
<li>interpoler les 3 couleurs ?</li>
</ul>
<p>en gros, le pipeline peut proposer plusieurs solutions standards, mais la solution la plus souple est d'écrire une fonction qui fait exactement ce que l'on veut et de la "donner" au pipeline pour qu'il l'utilise.</p>
<p>pour dessiner plusieurs triangles, il faut "donner" au pipeline les coordonnées et les couleurs des sommets de chaque triangle. que se passe-t-il lorsque plusieurs triangles se dessinent sur le même pixel de l'image ?</p><ul>
<li>openGL, par exemple, propose 3 solutions :<ul>
<li>dessiner les triangles dans l'ordre, chaque pixel garde la couleur du dernier triangle dessiné,</li>
<li>ou utiliser la profondeur, en 3d, pour ne garder que la couleur du triangle le plus "proche", ou le plus "loin".</li>
</ul>
</li>
</ul>
<p>en résumé, les fonctions de l'api openGL permettent de :</p><ul>
<li>"donner" des informations sur les sommets des triangles à dessiner,</li>
<li>"donner" une fonction qui transforme les coordonnées des sommets en position dans l'image,</li>
<li>de choisir comment remplir l'intérieur des triangles (couleur du premier sommet, interpolation, etc) et la meilleure solution est d'écrire une fonction, un shader, qui calcule la couleur du pixel,</li>
<li>de choisir quel triangle garder pour chaque pixel de l'image,</li>
</ul>
<p>et à chaque fois, les mêmes étapes se repètent, créer un objet (un buffer par exemple, pour stocker les informations sur les sommets) et de configurer le pipeline pour utiliser les informations/paramètres qu'il contient pour dessiner des triangles, des points, ou des droites.</p>
<h1><a class="anchor" id="pipeline"></a>
pipeline graphique openGL</h1>
<p>le pipeline openGL est découpé en 2 parties :</p><ul>
<li>la première partie traite la géométrie, les sommets des triangles. son rôle est de transformer les coordonnées des sommets, qui sont fournies dans un repère quelconque, en positions dans l'image,</li>
<li>la deuxième partie détermine quels pixels de l'image doivent changer de couleur pour dessiner chaque triangle, en utilisant les positions calculées par la première étape.</li>
</ul>
<p>ces 2 parties sont à moitié programmable, avec des shaders, et à moitié configurable, il faut choisir quelle solution standard utiliser. par exemple, il faut choisir quel triangle donne sa couleur à chaque pixel de l'image, soit en fonction de sa profondeur (le plus proche ou le plus loin), soit en fonction de l'ordre d'affichage. autre option disponible, on peut choisir de dessiner tout le triangle (son intérieur et son bord), ou uniquement son bord, voire uniquement ses sommets.</p>
<h2><a class="anchor" id="autotoc_md47"></a>
pipeline géométrique</h2>
<p>le role de la première partie est de préparer le dessin des triangles, et son principal travail est de transformer les positions des sommets pour déterminer sur quel pixel de l'image ils se projettent.</p>
<p><em>pourquoi faut-il transformer les positions des sommets ?</em></p>
<p>quand on crée un objet, on le dessine tout seul, avec un logiciel comme blender, par exemple, ou on le construit en calculant la position de chacun de ses sommets.</p>
<p>ensuite ces objets, crées séparement, sont disposés dans une scène, il faut les placer, les orienter, ajuster leur taille, etc. pour dessiner ces objets, il faut choisir un point de vue, une camera, qui est aussi placée et orientée dans la scène. et l'information nécessaire pour dessiner un triangle est de savoir sur quels pixels le dessiner, quelque soit la position de la camera. si la camera bouge, les triangles doivent aussi se déplacer dans l'image pour recréer une vue correcte de la scène.</p>
<p>au final, les sommets existent dans plusieurs repères :</p><ul>
<li>le repère de création de l'objet,</li>
<li>le repère de la scène, ou du monde,</li>
<li>le repère de la caméra,</li>
<li>le repère projectif, qui permet de passer de la 3d à la 2d de l'image,</li>
<li>et enfin, le repère image,</li>
</ul>
<p>le même sommet à donc 5 ou 6 coordonnées différentes (selon qu'il est visible ou pas, un sommet non visible dans l'image n'a pas de coordonnées image).</p>
<p>en résumé, cette première partie du pipeline doit déterminer où se trouve chaque triangle par rapport à la caméra. si un triangle est devant caméra, il sera visible dans l'image, et les coordonnées de ses sommets dans le repère image permettent de le dessiner.</p>
<h3><a class="anchor" id="autotoc_md48"></a>
comment ça marche ?</h3>
<p>pour placer un triangle dans la scène, on modifie les coordonnées de ses sommets, que l'on connait dans son repère de création. la <em>transformation</em> dans ce cas, est une <em>translation</em>. on ajoute un déplacement, un <em>vecteur</em>, à chaque <em>point</em>. (cf <a href="https://fr.wikipedia.org/wiki/Translation_%28g%C3%A9om%C3%A9trie%29">wikipedia</a>)</p>
<p>si l'on veut faire tourner / réorienter un triangle autour d'un axe, ou d'un vecteur, on peut calculer ses nouvelles coordonnées, avec le sinus et le cosinus de l'angle de la rotation. (cf <a href="https://fr.wikipedia.org/wiki/Rotation_affine">wikipedia</a>)</p>
<p>le changement, le passage d'un repère au suivant peut se représenter à chaque fois de manière assez directe avec une matrice (qui n'est au final, qu'une notation compacte pour un calcul un peu long à écrire avec les 3 coordonnées de chaque sommet). le cas des translations et des projections est un peu à part et nécessite des matrices avec une ligne et une colonne de plus. (cf <a href="https://fr.wikipedia.org/wiki/Coordonn%C3%A9es_homog%C3%A8nes#Notation_matricielle">wikipedia</a>)</p>
<p>mais au final, le passage d'un repère au suivant se représente avec une matrice 4x4 :</p><ul>
<li>placer l'objet dans la scène : passage du repère de création vers le repère monde, matrice <em>model</em>,</li>
<li>passage monde vers le repère de la caméra, matrice <em>view</em>,</li>
<li>passage camera vers le repère projectif, matrice <em>projection</em>,</li>
<li>passage projectif vers le repère image, matrice <em>viewport</em> (uniquement pour les sommets visibles).</li>
</ul>
<p>tous les pipelines 3d utilisent ces matrices, même si ce n'est pas toujours intuitif à manipuler. par contre, ces matrices ont des propriétés très interressantes : on peut multiplier plusieurs matrices pour sauter plusieurs changements de repères, ce qui permet de faire des calculs plus rapides, on peut inverser une matrice pour obtenir le passage dans l'autre sens, ce qui permet, par exemple, de faire du lancer de rayons, on peut facilement construire des objets articulés et les animer, ou faire bouger des objets les uns par rapport aux autres... et tout ca serait beaucoup plus difficile ou limité sans utiliser de matrices.</p>
<p><em>et openGL ?</em></p>
<p>openGL à besoin de connaitre les coordonnées des sommets des triangles dans le repère <em>projectif</em> homogène de la camera pour pouvoir ensuite dessiner les triangles, et comme on écrit une fonction qui fait le calcul, on est libre d'utiliser des matrices, ou pas... il faut "juste" l'expliquer à openGL, et écrire le <em>vertex shader</em> responsable de cette partie du pipeline.</p>
<p>si on souhaite écrire une fonction en C/C++ qui déplace un sommet, on aura quelque chose comme ca :</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structPoint.html">Point</a></div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">float</span> x, y, z, w;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code" href="structPoint.html">Point</a> transform( <span class="keyword">const</span> <a class="code" href="structPoint.html">Point</a> position, <span class="keyword">const</span> <span class="keywordtype">float</span> dx, <span class="keyword">const</span> <span class="keywordtype">float</span> dy, <span class="keyword">const</span> <span class="keywordtype">float</span> dz )</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structPoint.html">Point</a> r;</div>
<div class="line">    r.x= position.x + dx;</div>
<div class="line">    r.y= position.y + dy;</div>
<div class="line">    r.z= position.z + dz;</div>
<div class="line">    r.w= 1;</div>
<div class="line">    <span class="keywordflow">return</span> r;</div>
<div class="line">}</div>
</div><!-- fragment --><p>pour simplifier les calculs, on choisit des sommets qui sont deja placés devant la camera, et par convention, leurs coordonnées doivent être entre -1 et 1 sur x, y, et z, pour être visible. la 4ieme coordonnée est 1 pour un point.</p>
<p>(<em>rappel :</em> vu que les transformations sont représentées par des matrices à 4 lignes de 4 colonnes, un <em>point</em> ou un <em>vecteur</em> à forcement 4 coordonnées : x, y, z et w, le poids homogène)</p>
<p>cette fonction ne transforme qu'un seul sommet, il faut donc l'utiliser 3 fois pour déplacer un triangle. openGL impose une solution particulière : par defaut, il se contente de numéroter les sommets, le shader ne prend en entrée qu'un seul paramètre, l'indice du sommet à tansformer. la fonction s'appelle main et le résultat doit être écrit dans une variable globale.</p>
<p>le shader ressemble plutot à ça :</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structPoint.html">Point</a></div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">float</span> x, y, z, w;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// variables definies par l&#39;application</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> dx= ... ;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> dy= ... ;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> dz= ... ;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> gl_VertexID = ... ; <span class="comment">// valeur donnée par openGL</span></div>
<div class="line"><a class="code" href="structPoint.html">Point</a> gl_Position;            <span class="comment">// stockage du résultat, utilise par la suite du pipeline</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main( )</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="structPoint.html">Point</a> positions[3] = { { ... }, { ... }, { ... } };</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="structPoint.html">Point</a> r;</div>
<div class="line">    r.x= positions[gl_VertexID].x + dx;</div>
<div class="line">    r.y= positions[gl_VertexID].y + dy;</div>
<div class="line">    r.z= positions[gl_VertexID].z + dz;</div>
<div class="line">    r.w= 1;</div>
<div class="line">    </div>
<div class="line">    gl_Position= r;</div>
<div class="line">}</div>
</div><!-- fragment --><p>cette fonction est appellée pour déplacer chaque sommet des triangles que l'on dessine, et gl_VertexID change de valeur à chaque fois. en gros, le pipeline openGL utilise le vertex shader de cette manière :</p>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    une carte graphique fait quelque chose d&#39;équivalent (mais en parallèle et avec du matériel spécialisé), </span></div>
<div class="line"><span class="comment">    une fois que les 3 sommets d&#39;un triangle sont transformés, on peut dessiner le triangle.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><a class="code" href="structPoint.html">Point</a> vertex_shader( <span class="keyword">const</span> <span class="keywordtype">int</span> vertex_id )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// definit les variables globales maniplees par le vertex shader</span></div>
<div class="line">    <span class="keywordtype">int</span> gl_VertexID= vertex_id;</div>
<div class="line">    <a class="code" href="structPoint.html">Point</a> gl_Position;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// execute la fonction main() du vertex shader</span></div>
<div class="line">    { ... }</div>
<div class="line">    <span class="comment">// renvoie la position transformee</span></div>
<div class="line">    <span class="keywordflow">return</span> gl_Position;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> draw( <span class="keyword">const</span> <span class="keywordtype">int</span> count )</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i= 0; i +2 &lt; count; i= i +3)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// transforme les 3 sommets du triangle en utilisant le vertex shader</span></div>
<div class="line">        <a class="code" href="structPoint.html">Point</a> a= vertex_shader(i);</div>
<div class="line">        <a class="code" href="structPoint.html">Point</a> b= vertex_shader(i +1);</div>
<div class="line">        <a class="code" href="structPoint.html">Point</a> c= vertex_shader(i +2);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// dessiner un triangle par triplet de sommets...</span></div>
<div class="line">        draw_triangle(a, b, c);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>le plus simple est de le tester.</p>
<p>compilez <a class="el" href="shader__kit_8cpp.html">shader_kit.cpp</a> et jouez un peu avec le shader <a class="el" href="intro1_8glsl_source.html">intro1.glsl</a> </p><div class="fragment"><div class="line">./bin/shader_kit tutos/intro1.glsl</div>
</div><!-- fragment --><p> ouvrez <a class="el" href="intro1_8glsl_source.html">tutos/intro1.glsl</a> avec un éditeur, faites des modifications, réactivez la fenêtre de shader_kit et appuyez sur R pour recharger le shader...</p>
<p><em>remarque</em>: shader_kit n'affiche qu'un seul triangle de cette manière...</p>
<p><em>et avec plusieurs triangles ?</em></p>
<p>le vertex shader est presque le même, mais le tableau de sommets est global, et sa déclaration est un peu particulière, et c'est l'application qui le remplit, pas le shader.</p>
<div class="fragment"><div class="line"><span class="comment">// valeurs definies par l&#39;application</span></div>
<div class="line">uniform <a class="code" href="structvec3.html">vec3</a> positions[12];</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> dx= ... ;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> dy= ... ;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> dz= ... ;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main( )</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structPoint.html">Point</a> r;</div>
<div class="line">    r.x= positions[gl_VertexID].x + dx;</div>
<div class="line">    r.y= positions[gl_VertexID].y + dy;</div>
<div class="line">    r.z= positions[gl_VertexID].z + dz;</div>
<div class="line">    r.w= 1;</div>
<div class="line">    </div>
<div class="line">    gl_Position= r;</div>
<div class="line">}</div>
</div><!-- fragment --><p>le mot-clé <em>uniform</em>, indique que le tableau positions ne change pas pendant l'exécution du pipeline. c'est bien ce que l'on veut, du point de vue du vertex shader le tableau est une constante et le shader doit transformer tous les sommets du tableau pour pouvoir dessiner les triangles. par contre, l'application peut changer le contenu du tableau pour afficher un autre ensemble de triangles.</p>
<p>la différence principale avec la première solution : l'application remplit le tableau positions, fournit le shader et demande à openGL de dessiner 12 sommets, soit 4 triangles. c'est ce qu'il faut retenir : un shader, et le pipeline graphique en général, fonctionne avec les données et paramètres fourni par l'application, ils sont dépendents l'un de l'autre.</p>
<p>c'est la solution la plus directe pour dessiner quelques triangles, mais elle est limitée. les variables et tableaux déclarés comme uniform ne peuvent pas occupper plus de 64Ko (les 4 floats de chaque sommet, occuppent 16 octets, donc on peut dessiner 64000 / 16 / 3 = à peu près 1000 triangles).</p>
<p>la solution "normale" est un peu plus longue à mettre en place, mais fonctionne exactement de la même manière.</p>
<p>si vous êtes pressés, vous pouvez consulter les autres tutos pour écrire une première application openGL. mais il est conseillé de jeter un oeil à la 2ieme partie du pipeline...</p>
<p><em>raccourcis :</em> pour écrire une première application openGL qui utilise les 2 premières solutions :</p><ul>
<li><a class="el" href="group__tuto__application.html">écrire une application openGL</a>, ouvrir une fenêtre et initialiser openGL,</li>
<li><a class="el" href="group__interfaceC.html">interface C openGL</a>, les fonctions d'openGL, la construction de l'interface en C pur,</li>
<li><a class="el" href="group__tuto2GL.html">compiler et linker un shader program</a> compiler un shader, avec vérification des erreurs, avec les utilitaires de gKit,</li>
<li><a class="el" href="group__tuto3GL.html">afficher plusieurs triangles, modifier les paramètres uniform d'un shader program</a> passer des paramètres, des valeurs uniform, à un shader,</li>
<li><a class="el" href="group__tuto4GL.html">configurer un format de sommet, vertex array object</a> dessiner des triangles avec la solution classique, description des attributs des sommets, buffers, vertex arrays et shaders.</li>
</ul>
<h2><a class="anchor" id="autotoc_md49"></a>
pipeline pixels</h2>
<p>le role de la deuxième partie du pipeline est de dessiner les triangles en connaissant les coordonnées des sommets dans le repère projectif homogène de la caméra. et ces coordonnées sont calculées par la première partie du pipeline.</p>
<h3><a class="anchor" id="autotoc_md50"></a>
comment ça marche ?</h3>
<p>une fois que les vertex shaders ont été exécutés, le pipeline connait les coordonnées des sommets des triangles dans le repère projectif homogene. mais il reste un test de visibilité à faire, pour déterminer si le triangle est, au moins, en partie visible, ainsi qu'un dernier changement de repère, le passage vers le repere projectif reel et, enfin, vers le repère image.</p>
<p>tous les sommets ont des coordonnées dans le repère projectif, mais, par convention, seuls ceux qui se trouvent dans le cube [-1 1] sur x, y, et z correspondent à des pixels de l'image :</p><ul>
<li>-1 &lt; x &lt; 1</li>
<li>-1 &lt; y &lt; 1</li>
<li>-1 &lt; z &lt; 1</li>
</ul>
<p>les points homogenes wx, wy, wz, sont donc visibles si :</p><ul>
<li>-w &lt; wx &lt; w</li>
<li>-w &lt; wy &lt; w</li>
<li>-w &lt; wz &lt; w</li>
</ul>
<p><em>rappel :</em> on peut retrouver le point <em>réel</em> p = (x, y, z, 1) associé à un point <em>homogène</em> h = (wx, wy, wz, w) en divisant par w, le poids homogene : p = h / h.w.</p>
<p>le premier traitement réalisé est donc ce test de visibilité, suivi, ou pas, de la dernière transformation vers le repère image, et enfin du test qui détermine quels pixels permettent de dessiner le triangle.</p>
<p>on peut écrire le test de visibilité d'un sommet comme ça : </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> visible( <span class="keyword">const</span> <a class="code" href="structPoint.html">Point</a> p )</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span>(p.x &lt; -p.w || p.x &gt; p.w) <span class="keywordflow">return</span> <span class="keyword">false</span>;   <span class="comment">// trop à droite, ou à gauche</span></div>
<div class="line">    <span class="keywordflow">if</span>(p.y &lt; -p.w || p.y &gt; p.w) <span class="keywordflow">return</span> <span class="keyword">false</span>;   <span class="comment">// trop haut, ou trop bas</span></div>
<div class="line">    <span class="keywordflow">if</span>(p.z &lt; -p.w || p.z &gt; p.w) <span class="keywordflow">return</span> <span class="keyword">false</span>;   <span class="comment">// trop loin ou derrière</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// le sommet reel est bien dans le cube -1 1, il est visible par la camera</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>si les sommets du triangle ne sont pas tous les 3 visibles, il faudra découper le triangle pour trouver quelle partie est visible. sinon, les coordonnées sont transformées d'abord dans le repere projectif réel, puis en position de pixels dans l'image, et le <em>fragment shader</em>, la fonction responsable de donner une couleur au pixel est exécutée, puis la couleur est écrite dans l'image.</p>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">    une carte graphique fait quelque chose d&#39;équivalent (mais en parallèle et avec du matériel spécialisé).</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span><a class="code" href="classImage.html">Image</a> { ... };</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classImage.html">Image</a> image = { ... };                  <span class="comment">// image resultat</span></div>
<div class="line"><span class="keywordtype">int</span> width= ...;                         <span class="comment">// largeur de l&#39;image</span></div>
<div class="line"><span class="keywordtype">int</span> height= ...;                        <span class="comment">// hauteur de l&#39;image</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structFragment.html">Fragment</a> { <span class="keywordtype">float</span> x, y; };        <span class="comment">// representation d&#39;un fragment</span></div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structColor.html">Color</a> { <span class="keywordtype">float</span> r, g, b; };        <span class="comment">// representation d&#39;une couleur</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> draw_triangle( <span class="keyword">const</span> <a class="code" href="structPoint.html">Point</a> a, <span class="keyword">const</span> <a class="code" href="structPoint.html">Point</a> b, <span class="keyword">const</span> <a class="code" href="structPoint.html">Point</a> c )</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span>(!visible(a) || !visible(b) || !visible(c))</div>
<div class="line">        <span class="comment">// le triangle est en partie non visible, il faudra le decouper et ne dessiner que la partie visible</span></div>
<div class="line">        <span class="keywordflow">return</span>; <span class="comment">// todo</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// passage dans le repere projectif reel</span></div>
<div class="line">    a= a / a.w;</div>
<div class="line">    b= b / b.w;</div>
<div class="line">    c= c / c.w;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// passage dans le repère image, de [-1 1]x[-1 1] vers [0 width]x[0 height]</span></div>
<div class="line">    <a class="code" href="structPoint.html">Point</a> pa= (a + 1) * <a class="code" href="structPoint.html">Point</a>(with, height, 1) / 2;</div>
<div class="line">    <a class="code" href="structPoint.html">Point</a> pb= (b + 1) * <a class="code" href="structPoint.html">Point</a>(with, height, 1) / 2;</div>
<div class="line">    <a class="code" href="structPoint.html">Point</a> pc= (c + 1) * <a class="code" href="structPoint.html">Point</a>(with, height, 1) / 2;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// dessiner le triangle, parcourir tous les pixels de l&#39;image... </span></div>
<div class="line">    <span class="comment">// todo : comment eviter de tous les parcourir ?</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> y= 0; y &lt; height; y++)</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> x= 0; x &lt; width; x++)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// verifier que le pixel x, y fait partie du triangle...</span></div>
<div class="line">        <span class="keywordflow">if</span>(inside(x, y, pa, pb, pc))</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// executer le fragment shader pour connaitre la couleur du pixel</span></div>
<div class="line">            <a class="code" href="structFragment.html">Fragment</a> gl_FragCoord;      <span class="comment">// position du fragment</span></div>
<div class="line">            gl_FragCoord.x= x;</div>
<div class="line">            gl_FragCoord.y= y;</div>
<div class="line">            </div>
<div class="line">            <a class="code" href="structColor.html">Color</a> gl_FragColor;         <span class="comment">// couleur du fragment</span></div>
<div class="line">            gl_FragColor.r= 0;</div>
<div class="line">            gl_FragColor.g= 0;</div>
<div class="line">            gl_FragColor.b= 0;</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// execute la fonction main() du fragment shader</span></div>
<div class="line">            { ... }</div>
<div class="line">            <span class="comment">// renvoie la couleur du fragment</span></div>
<div class="line">            <span class="comment">// ecrit la couleur dans l&#39;image</span></div>
<div class="line">            image(x, y)= gl_FragColor;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>le <em>fragment shader</em> utilise aussi une convention particulière, la position du pixel est disponible dans une variable globale, gl_FragCoord, la couleur du pixel doit être aussi écrite dans une variable globale, gl_FragColor.</p>
<p><b>fragment :</b> par définition, un fragment est la partie du triangle qui se projette sur un pixel.</p>
<p>le shader le plus simple donne une couleur constante à chaque pixel du triangle : </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="structFragment.html">Fragment</a> gl_FragCoord= ... ;      <span class="comment">// valeur donnée par openGL</span></div>
<div class="line"><a class="code" href="structColor.html">Color</a> gl_FragColor;                     <span class="comment">// stockage du résultat, utilise par la suite du pipeline</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main( )</div>
<div class="line">{</div>
<div class="line">    gl_FragColor= <a class="code" href="structColor.html">Color</a>(1, 1, 1);       <span class="comment">// le pixel sera blanc...</span></div>
<div class="line">}</div>
</div><!-- fragment --><div class="image">
<img src="grid_triangle.png" alt=""/>
<div class="caption">
le triangle et la grille de pixels à tester...</div></div>
<p>la fonction qui permet vraiment de dessiner le triangle, en testant l'inclusion d'un pixel x, y dans le triangle a, b, c, appelée inside( ), est plus interressante, et c'est un bon exercice...</p>
<p>si openGL ne dessinait qu'un seul triangle de couleur constante, la présentation serait terminée. il y a donc quelques détails supplémentaires...</p>
<h3><a class="anchor" id="autotoc_md51"></a>
et avec plusieurs triangles ?</h3>
<p>comme évoqué dans l'introduction, plusieurs triangles peuvent se dessiner sur le même pixel. dans ce cas, il faut choisir quelle couleur conserver. une option nécessaire pour obtenir une image cohérente de la scène est de garder la couleur du triangle le plus proche de la camera. si les objets représentés par les triangles sont opaques, c'est la bonne solution...</p>
<p>le pipeline calcule donc une autre information pour chaque fragment : la distance jusqu'à la camera et la conserve pour chaque pixel dans une autre image, le <em>zbuffer</em>.</p>
<p>contrairement à l'intuition, le repère image n'est pas un carre en 2d. la profondeur d'un sommet, sa coordonnée z, est connue, et il suffit de garder le triangle avec le plus petit z, pour chaque pixel de l'image. le repère image est donc un cube en 3d, de dimensions [0 largeur]x[0 hauteur]x[0 1], la profondeur est normalisée entre 0 et 1. la camera n'observe qu'une région de la scène, les triangles trop proches, ainsi que ceux qui sont trop loin, ne sont pas dessinés. ces paramètres sont fournis lors de la construction de la transformation <em>projection</em>. cf les paramètres znear et zfar de <a class="el" href="group__math.html#gaa8f5681ae80df53c6b6191168ecad85a" title="renvoie la matrice representant une transformation projection perspective.">Perspective( )</a>.</p>
<p>il y a quand même un problème à régler, le pipeline connait les coordonnées des sommets de chaque triangle, mais il faut calculer les coordonnées de chaque fragment, c'est à dire la coordonnée z pour chaque pixel x, y occuppé par le triangle dans l'image.</p>
<p>une solution est d'interpoler la valeur z pour tous les pixels du triangle. <em>comment ?</em></p>
<p>la fonction inside( ), qui permet de savoir si un pixel x, y appartient à un triangle a, b, c, fournit quasiment la réponse.</p>
<p>l'idée du test réalisé par inside( ) est de vérifier que le pixel x, y est du "bon" coté des 3 arêtes du triangle.</p>
<div class="image">
<img src="grid_edges.png" alt=""/>
<div class="caption">
les 3 arêtes à tester, pour chaque pixel...</div></div>
<p>ce test revient à calculer l'aire signée (algébrique) des 3 triangles formés par le pixel p, et les 3 arêtes ab, bc, et ca (cf <a href="http://geomalgorithms.com/a01-_area.html">Modern triangles / section Modern triangles</a>). si les aires des triangles pab, pbc et pca ont le même signe, le pixel p est à l'intérieur du triangle.</p>
<div class="image">
<img src="grid_samples.png" alt=""/>
<div class="caption">
les 2 triangles (verts) ont des aires de signes opposés, à gauche le pixel est à intérieur, à droite, le pixel est à l'extérieur.</div></div>
<p>dans l'exemple ci dessus, partie gauche, l'aire du triangle vert sera positive si les sommets du triangle abc sont dans le sens trigo et négative dans l'autre cas. on a aire(p, a, b) &gt; 0 (les 3 sommets sont dans le sens trigo) et à droite aire(p, a, b) &lt; 0 (les 3 sommets sont dans le sens horaire).</p>
<p>si le triangle abc est décrit dans l'autre sens, le sens horaire, l'aire change de signe. il est donc très important de décrire les sommets des triangles à dessiner en respectant une orientation et de donner cette information au pipeline pour qu'il prenne les bonnes décisions.</p>
<p>en résumé, si le pixel p fait parti du triangle, on connait l'aire des 3 sous-triangles pab, pbc et pca, et, en plus, on sait, par construction, que la somme de ces 3 aires est égale à celle du triangle a, b, c. ce sont exactement les coordonnées barycentriques du pixel p dans le triangle, et on peut utiliser ces coordonnées pour interpoler la coordonnée z pour le pixel x, y en ne connaissant que les coordonnées des sommets. (cf <a href="https://fr.wikipedia.org/wiki/Coordonn%C3%A9es_barycentriques">wikipedia</a>)</p>
<div class="image">
<img src="grid_fragments.png" alt=""/>
<div class="caption">
résultat: les pixels à l'intérieur du triangle...</div></div>
<p>au final, dessiner un triangle ressemble plutot à ça : </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="classImage.html">Image</a> { ... };</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classImage.html">Image</a> image= { ... };                   <span class="comment">// image resultat</span></div>
<div class="line"><a class="code" href="classImage.html">Image</a> zbuffer= { ... };                 <span class="comment">// image resultat</span></div>
<div class="line"><span class="keywordtype">int</span> width= ...;                         <span class="comment">// largeur de l&#39;image</span></div>
<div class="line"><span class="keywordtype">int</span> height= ...;                        <span class="comment">// hauteur de l&#39;image</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structFragment.html">Fragment</a> { <span class="keywordtype">float</span> x, y, z; };     <span class="comment">// representation d&#39;un fragment</span></div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structColor.html">Color</a> { <span class="keywordtype">float</span> r, g, b; };        <span class="comment">// representation d&#39;une couleur</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> draw_triangle( <span class="keyword">const</span> <a class="code" href="structPoint.html">Point</a> a, <span class="keyword">const</span> <a class="code" href="structPoint.html">Point</a> b, <span class="keyword">const</span> <a class="code" href="structPoint.html">Point</a> c )</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span>(!visible(a) || !visible(b) || !visible(c))</div>
<div class="line">        <span class="comment">// le triangle est en partie non visible, il faudra le decouper et ne dessiner que la partie visible</span></div>
<div class="line">        <span class="keywordflow">return</span>; <span class="comment">// todo</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// passage dans le repere projectif reel</span></div>
<div class="line">    a= a / a.w;</div>
<div class="line">    b= b / b.w;</div>
<div class="line">    c= c / c.w;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// passage dans le repère image, de [-1 1]x[-1 1]x[-1 1] vers [0 width]x[0 height]x[0 1]</span></div>
<div class="line">    <a class="code" href="structPoint.html">Point</a> pa= (a + 1) * <a class="code" href="structPoint.html">Point</a>(with, height, 1) / 2;</div>
<div class="line">    <a class="code" href="structPoint.html">Point</a> pb= (b + 1) * <a class="code" href="structPoint.html">Point</a>(with, height, 1) / 2;</div>
<div class="line">    <a class="code" href="structPoint.html">Point</a> pc= (c + 1) * <a class="code" href="structPoint.html">Point</a>(with, height, 1) / 2;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// dessiner le triangle</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> y= 0; y &lt; height; y++)</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> x= 0; x &lt; width; x++)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// verifier que le pixel x, y fait partie du triangle...</span></div>
<div class="line">        <span class="keywordflow">if</span>(inside(x, y, pa, pb, pc))</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// executer le fragment shader pour connaitre la couleur du pixel</span></div>
<div class="line">            <a class="code" href="structFragment.html">Fragment</a> gl_FragCoord;      <span class="comment">// position du fragment</span></div>
<div class="line">            gl_FragCoord.x= x;</div>
<div class="line">            gl_FragCoord.y= y;</div>
<div class="line">            <span class="comment">// interpoler la profondeur du fragment</span></div>
<div class="line">            gl_FragCoord.z= fragment_depth(x, y, pa, pb, pc);</div>
<div class="line">            </div>
<div class="line">            <a class="code" href="structColor.html">Color</a> gl_FragColor;         <span class="comment">// couleur du fragment</span></div>
<div class="line">            gl_FragColor.r= 0;</div>
<div class="line">            gl_FragColor.g= 0;</div>
<div class="line">            gl_FragColor.b= 0;</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// execute la fonction main() du fragment shader</span></div>
<div class="line">            { ... }</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// ecrit la couleur dans l&#39;image, si le fragment est plus proche == test de profondeur</span></div>
<div class="line">            <span class="keywordflow">if</span>(gl_FragCoord.z &lt; zbuffer(x, y))</div>
<div class="line">            {</div>
<div class="line">                image(x, y)= gl_FragColor;</div>
<div class="line">                zbuffer(x, y)= gl_FragCoord.z;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p><em>remarque :</em> un code complet et fonctionnel est disponible dans <a class="el" href="group__pipeline__c.html">mini pipeline graphique</a>.</p>
<p>implication directe pour l'application, il plutôt important d'initialiser correctement les valeurs du zbuffer avant de dessiner des triangles, sinon le test de profondeur ne conservera pas le bon triangle pour chaque pixel.</p>
<p><em>quelle est la profondeur max d'un fragment visible ?</em></p>
<p>c'est ... 1, la coordonnée z d'un sommet visible est comprise entre -1 et 1 dans le repère projectif, et est ensuite normalisée entre 0 et 1 dans le repère image.</p>
<p>une autre conséquence directe de cette interpolation : on peut interpoler n'importe quelle valeur définie sur les sommets du triangle, comme des couleurs, des normales, des coordonnées de textures, etc. ou même calculer une valeur dans le vertex shader et la transmettre au fragment shader.</p>
<p>le pipeline pourrait interpoler automatiquement toutes les informations définies par sommet du triangle et les donner au fragment shader, mais cette solution n'est pas assez souple. par exemple, on peut tres bien <em>calculer</em> les coordonnées de texture d'un sommet sans quelles soient fournies par l'application.</p>
<p>il faut donc un "mécanisme" plus souple : les shaders peuvent déclarer un nouveau type de variable, des <em>varyings</em> qui sont calculés par un shader et récupérés par le shader suivant dans le pipeline. (<em>remarque :</em> cet exemple n'utilise que des vertex et des fragment shaders, mais il y a 5 types de shaders dans le pipeline graphique openGL...)</p>
<p>ces variables sont donc déclarées en sortie du vertex shader et en entrée du fragment shader, et sont bien sur interpolées par le pipeline.</p>
<div class="fragment"><div class="line"><span class="comment">// vertex shader</span></div>
<div class="line">out <a class="code" href="structvec3.html">vec3</a> texcoord;  <span class="comment">// declaration d&#39;une sortie optionnelle, un varying, mot clé: out</span></div>
<div class="line"> </div>
<div class="line">uniform <a class="code" href="structvec3.html">vec3</a> positions[12];</div>
<div class="line">uniform <a class="code" href="structvec3.html">vec3</a> deplacement;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main()</div>
<div class="line">{</div>
<div class="line">    gl_Position= positions[gl_VertexID] + deplacement;  <span class="comment">// sortie obligatoire du vertex shader</span></div>
<div class="line">    texcoord= positions[gl_VertexID];   <span class="comment">// varying, sortie &quot;optionnelle&quot; du vertex shader, a déclarer avec le mot clé: out</span></div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// fragment shader</span></div>
<div class="line">in <a class="code" href="structvec3.html">vec3</a> texcoord;   <span class="comment">// declaration d&#39;une entrée optionnelle, un varying, mot clé: in, </span></div>
<div class="line"><span class="comment">// doit avoir le même nom et le même type que la sortie déclarée dans le vertex shader</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main( )</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> color= <a class="code" href="structvec3.html">vec3</a>(0, 0, 0);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// calculer la couleur du fragment en fonction de texcoord</span></div>
<div class="line">    <span class="comment">// construit une grille dans le repere local de l&#39;objet, et donne une couleur en fonction de la distance à la cellule la plus proche</span></div>
<div class="line">    <span class="comment">// texcoord contient la position du fragment du triangle visible pour le pixel, et est interpolé par le pipeline</span></div>
<div class="line">    </div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> p= texcoord * 8;</div>
<div class="line">    <span class="keywordtype">float</span> d= <a class="code" href="group__math.html#gaf34f93c25b062fad7f99a1e02d88a423">length</a>( p - (floor(p) + 0.5));</div>
<div class="line">    <span class="keywordflow">if</span>(d &gt; 1) d= 0;</div>
<div class="line">        color=  <a class="code" href="structvec3.html">vec3</a>(d*0.8*2, d*0.4*2, 0);</div>
<div class="line"> </div>
<div class="line">    glFragColor= color;</div>
<div class="line">}</div>
</div><!-- fragment --><div class="image">
<img src="mesh_uvgrid.png" alt=""/>
</div>
<h1><a class="anchor" id="autotoc_md52"></a>
résumé</h1>
<p>pour résumer, voila à quoi ressemble le pipeline openGL :</p>
<div class="image">
<img src="opengl_pipeline.png" alt=""/>
</div>
<p>certaines étapes sont programmables, ce sont les shaders, et les autres sont paramétrables :</p><ul>
<li>assemblage des attributs / informations des sommets de chaque triangle,</li>
<li>exécution des vertex shaders, pour transformer chaque sommet de chaque triangle,</li>
<li>assemblage des triangles, récupère les 3 sommets transformés de chaque triangle (et ses varyings...)</li>
<li>visibilité / orientation du triangle par rapport à la caméra, les triangles à l'arrière des objets opaques ne peuvent pas être visibles, ce n'est pas la peine de les dessiner, si l'aire signée du triangle n'est pas positive,</li>
<li>fragmentation du triangle, détermine l'ensemble de pixels permettant de dessiner le triangle, interpole les varyings déclarés en sortie du vertex shader,</li>
<li>exécution des fragment shaders, pour donner une couleur à chaque pixel de chaque triangle,</li>
<li>test de profondeur de chaque fragment,</li>
<li>écriture dans l'image résultat et mise à jour du zbuffer par le pipeline, pour chaque fragment, de chaque triangle,</li>
</ul>
<div class="image">
<img src="shader2_pipeline.png" alt=""/>
</div>
<p>pour dessiner un triangle (ou plusieurs), il faut donc paramétrer le pipeline pour obtenir le résultat voulu... cf <a class="el" href="group__tuto3GL.html">afficher plusieurs triangles, modifier les paramètres uniform d'un shader program</a> et écrire les 2 shaders... cf <a class="el" href="group__glsl.html">shaders et GLSL</a></p>
<p>suite de la lecture :</p><ul>
<li><a class="el" href="group__interfaceC.html">interface C openGL</a>, les fonctions d'openGL, la construction de l'interface en C pur,</li>
<li><a class="el" href="group__tuto__application.html">écrire une application openGL</a>, ouvrir une fenêtre et initialiser openGL,</li>
<li><a class="el" href="group__tuto2GL.html">compiler et linker un shader program</a> compiler un shader program, avec vérification des erreurs, avec les utilitaires de gKit,</li>
<li><a class="el" href="group__tuto3GL.html">afficher plusieurs triangles, modifier les paramètres uniform d'un shader program</a> passer des paramètres, des valeurs uniform, à un shader,</li>
<li><a class="el" href="group__tuto4GL.html">configurer un format de sommet, vertex array object</a> dessiner des triangles avec la solution classique, description des attributs des sommets, buffers, vertex arrays et shaders. </li>
</ul>
</div><!-- contents -->
<div class="ttc" id="astructFragment_html"><div class="ttname"><a href="structFragment.html">Fragment</a></div><div class="ttdef"><b>Definition:</b> <a href="pipeline_8cpp_source.html#l00036">pipeline.cpp:36</a></div></div>
<div class="ttc" id="aclassImage_html"><div class="ttname"><a href="classImage.html">Image</a></div><div class="ttdoc">representation d'une image.</div><div class="ttdef"><b>Definition:</b> <a href="image_8h_source.html#l00020">image.h:20</a></div></div>
<div class="ttc" id="astructPoint_html"><div class="ttname"><a href="structPoint.html">Point</a></div><div class="ttdoc">representation d'un point 3d.</div><div class="ttdef"><b>Definition:</b> <a href="vec_8h_source.html#l00020">vec.h:20</a></div></div>
<div class="ttc" id="astructvec3_html"><div class="ttname"><a href="structvec3.html">vec3</a></div><div class="ttdoc">vecteur generique, utilitaire.</div><div class="ttdef"><b>Definition:</b> <a href="vec_8h_source.html#l00144">vec.h:144</a></div></div>
<div class="ttc" id="agroup__math_html_gaf34f93c25b062fad7f99a1e02d88a423"><div class="ttname"><a href="group__math.html#gaf34f93c25b062fad7f99a1e02d88a423">length</a></div><div class="ttdeci">float length(const Vector &amp;v)</div><div class="ttdoc">renvoie la longueur d'un vecteur.</div><div class="ttdef"><b>Definition:</b> <a href="vec_8cpp_source.html#l00142">vec.cpp:142</a></div></div>
<div class="ttc" id="astructColor_html"><div class="ttname"><a href="structColor.html">Color</a></div><div class="ttdoc">representation d'une couleur (rgba) transparente ou opaque.</div><div class="ttdef"><b>Definition:</b> <a href="color_8h_source.html#l00013">color.h:13</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 9 2019 15:39:11 for gKit2 light by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
