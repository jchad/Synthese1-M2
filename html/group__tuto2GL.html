<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gKit2 light: compiler et linker un shader program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">gKit2 light
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">compiler et linker un shader program</div>  </div>
</div><!--header-->
<div class="contents">
<p>cf <a class="el" href="tuto2GL_8cpp.html">tuto2GL.cpp</a> (+ <a class="el" href="tuto2GL__vertex_8glsl_source.html">tuto2GL_vertex.glsl</a> et <a class="el" href="tuto2GL__fragment_8glsl_source.html">tuto2GL_fragment.glsl</a>) et <a class="el" href="tuto1GL_8cpp.html">tuto1GL.cpp</a> (+ <a class="el" href="tuto1GL__vertex_8glsl_source.html">tuto1GL_vertex.glsl</a> et <a class="el" href="tuto1GL__fragment_8glsl_source.html">tuto1GL_fragment.glsl</a>)</p>
<p>un shader program est la même chose que d'habitude : le code exécutable crée par l'édition de liens des binaires obtenus après la compilations des shaders.</p>
<p>et comme d'habitude, il peut y avoir des erreurs de compilation et des erreurs d'édition de liens.</p>
<p>la démarche est très classique :</p><ul>
<li>lire le fichier source,</li>
<li>créer un vertex shader</li>
<li>lui donner le source,</li>
<li>compiler,</li>
<li>recommencer pour le fragment shader,</li>
<li>créer un shader program</li>
<li>associer les 2 shaders au program,</li>
<li>linker</li>
<li>utiliser / exécuter, si tout c'est bien passé.</li>
</ul>
<p>la partie la plus longue est finalement la vérification et la récupération des erreurs, sans grande surprise...</p>
<p><em>rappel :</em> les objets openGL sont manipulés à travers des identifiants numériques, openGL définit le type GLuint spécialement pour ça. vous pouvez repasser dans <a class="el" href="group__interfaceC.html">interface C openGL</a>, si nécessaire.</p>
<h2><a class="anchor" id="autotoc_md64"></a>
lire les sources</h2>
<p>le plus simple en C++, renvoie une chaine de caractères std::string : </p><div class="fragment"><div class="line">std::string read( <span class="keyword">const</span> <span class="keywordtype">char</span> *filename )</div>
<div class="line">{</div>
<div class="line">    std::stringbuf source;</div>
<div class="line">    std::ifstream in(filename);</div>
<div class="line">    <span class="comment">// verifie que le fichier existe</span></div>
<div class="line">    <span class="keywordflow">if</span>(in.good() == <span class="keyword">false</span>)</div>
<div class="line">        <span class="comment">// affiche une erreur, si le fichier n&#39;existe pas ou n&#39;est pas accessible</span></div>
<div class="line">        <a class="code" href="group__application.html#ga6efbb9298a8f73b9a17959b56ec20267">printf</a>(<span class="stringliteral">&quot;[error] loading program &#39;%s&#39;...\n&quot;</span>, filename);</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">        <a class="code" href="group__application.html#ga6efbb9298a8f73b9a17959b56ec20267">printf</a>(<span class="stringliteral">&quot;loading program &#39;%s&#39;...\n&quot;</span>, filename);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// lire le fichier, jusqu&#39;au premier separateur, </span></div>
<div class="line">    <span class="comment">// le caractere &#39;\0&#39; ne peut pas se trouver dans un fichier texte, donc lit tout le fichier d&#39;un seul coup</span></div>
<div class="line">    in.get(source, 0);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// renvoyer la chaine de caracteres</span></div>
<div class="line">    <span class="keywordflow">return</span> source.str();</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md65"></a>
créer et compiler les shaders</h2>
<div class="fragment"><div class="line">GLenum type= GL_VERTEX_SHADER;   <span class="comment">// ou GL_FRAGMENT_SHADER...</span></div>
<div class="line">GLuint shader= glCreateShader(type);</div>
</div><!-- fragment --><p>il faut ensuite préparer les sources à compiler. la fonction glShaderSource() veut un tableau de chaines de caracteres. il faut donc le construire. </p><div class="fragment"><div class="line">std::string source= read( <span class="stringliteral">&quot;vertex_shader.glsl&quot;</span> );</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *strings[]= { source.c_str() };</div>
<div class="line">glShaderSource(shader, 1, strings, NULL);</div>
</div><!-- fragment --><p>puis compiler le shader : </p><div class="fragment"><div class="line">glCompileShader(shader);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md66"></a>
vérifier les erreurs de compilation du shader</h2>
<p>un objet shader openGL maintient un état de compilation ainsi que les messages d'erreurs (et sonsource également). il suffit de l'interroger avec glGetShader( ) :</p>
<div class="fragment"><div class="line">GLint status;</div>
<div class="line">glGetShaderiv(shader, GL_COMPILE_STATUS, &amp;status);</div>
<div class="line"><span class="keywordflow">if</span>(status == GL_TRUE)</div>
<div class="line">    <span class="comment">// pas d&#39;erreurs de compilation</span></div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">    <span class="comment">// erreurs</span></div>
</div><!-- fragment --><p>si la compilation à échoué, il faut récupérer et afficher les messages, cf glGetShaderInfoLog( ). comme on ne connait pas a priori la longueur des messages, il faut la demander, allouer une chaine de caractères de la bonne taille et enfin récupérer les messsages... </p><div class="fragment"><div class="line"><span class="comment">// recuperer la longueur des messages d&#39;erreurs </span></div>
<div class="line">GLint <a class="code" href="group__math.html#gaf34f93c25b062fad7f99a1e02d88a423">length</a>;</div>
<div class="line">glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &amp;<a class="code" href="group__math.html#gaf34f93c25b062fad7f99a1e02d88a423">length</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// allouer une chaine de caracteres, length compte le 0 a la fin de la chaine</span></div>
<div class="line"><span class="keywordtype">char</span> *message= <span class="keyword">new</span> <span class="keywordtype">char</span> [<a class="code" href="group__math.html#gaf34f93c25b062fad7f99a1e02d88a423">length</a>];</div>
<div class="line"> </div>
<div class="line"><span class="comment">// recuperer les messages d&#39;erreurs</span></div>
<div class="line">glGetShaderInfoLog(shader, <a class="code" href="group__math.html#gaf34f93c25b062fad7f99a1e02d88a423">length</a>, message, NULL);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// afficher </span></div>
<div class="line"><a class="code" href="group__application.html#ga6efbb9298a8f73b9a17959b56ec20267">printf</a>(<span class="stringliteral">&quot;[errors]\n%s\n&quot;</span>, message);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// nettoyer </span></div>
<div class="line"><span class="keyword">delete</span> [] message;</div>
</div><!-- fragment --><p>si tout c'est bien passé pour le premier shader, on peut passer au 2ieme, seul le type de shader change : ce sera GL_FRAGMENT_SHADER au lieu de GL_VERTEX_SHADER.</p>
<h2><a class="anchor" id="autotoc_md67"></a>
créer et linker le program</h2>
<p>la démarche est la même que pour les shaders, il faut indiquer au program quels shaders linker ensemble avec glAttachShader( ), puis vérifier les erreurs, </p><div class="fragment"><div class="line">GLuint program= glCreateProgram();</div>
<div class="line">glAttachShader(program, vertex_shader);</div>
<div class="line">glAttachShader(program, fragment_shader);</div>
<div class="line">glLinkProgram(program);</div>
<div class="line"> </div>
<div class="line">GLint status;</div>
<div class="line">glGetProgramiv(program, GL_LINK_STATUS, &amp;status);</div>
<div class="line"><span class="keywordflow">if</span>(status == GL_TRUE)</div>
<div class="line">    <span class="comment">// pas d&#39;erreur de link, le program est pret a etre utilise !</span></div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">    <span class="comment">// erreurs ...</span></div>
</div><!-- fragment --><p>et éventuellement récupérer et afficher les erreurs... </p><div class="fragment"><div class="line"><span class="comment">// recuperer la longueur des messages d&#39;erreurs </span></div>
<div class="line">GLint <a class="code" href="group__math.html#gaf34f93c25b062fad7f99a1e02d88a423">length</a>;</div>
<div class="line">glGetProgramiv(program, GL_INFO_LOG_LENGTH, &amp;<a class="code" href="group__math.html#gaf34f93c25b062fad7f99a1e02d88a423">length</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// allouer une chaine de caracteres, length compte le 0 a la fin de la chaine</span></div>
<div class="line"><span class="keywordtype">char</span> *message= <span class="keyword">new</span> <span class="keywordtype">char</span> [<a class="code" href="group__math.html#gaf34f93c25b062fad7f99a1e02d88a423">length</a>];</div>
<div class="line"> </div>
<div class="line"><span class="comment">// recuperer les messages d&#39;erreurs</span></div>
<div class="line">glGetProgramInfoLog(program, <a class="code" href="group__math.html#gaf34f93c25b062fad7f99a1e02d88a423">length</a>, message, NULL);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// afficher </span></div>
<div class="line"><a class="code" href="group__application.html#ga6efbb9298a8f73b9a17959b56ec20267">printf</a>(<span class="stringliteral">&quot;[link errors]\n%s\n&quot;</span>, message);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// nettoyer </span></div>
<div class="line"><span class="keyword">delete</span> [] message;</div>
</div><!-- fragment --><p>voila, rien de bien compliqué, mais c'est un peu long.</p>
<p>un exemple minimaliste est dispo <a class="el" href="tuto2GL_8cpp.html">tuto2GL.cpp</a> (qui utilise les utilitaires de <a class="el" href="window_8h.html">window.h</a>), et <a class="el" href="tuto1GL_8cpp.html">tuto1GL.cpp</a> qui montre la totalité du code.</p>
<p>une fois que le program est correctement compilé et linké, avant de dessiner avec glDraw( ), il faut donner une valeur à tous ses uniforms et associer un buffer à ses attributs cf <a class="el" href="group__tuto3GL.html">afficher plusieurs triangles, modifier les paramètres uniform d'un shader program</a> et <a class="el" href="group__tuto4GL.html">configurer un format de sommet, vertex array object</a>. il est aussi possible, pour vérifier que l'on a rien oublié, de demander au shader program quels sont les uniforms déclarés, leur nom, leur type, leur valeur, etc. pour vérifier que l'initialisation est correcte. cf <a class="el" href="group__shader__reflect.html">récupérer les uniforms et les attributs utilisés par un shader program</a>.</p>
<h2><a class="anchor" id="autotoc_md68"></a>
formatage des erreurs</h2>
<p>par contre les messages d'erreurs sont très succints et n'affichent qu'un numéro de ligne sans aucun contexte, ce qui est assez pénible pour corriger l'erreur.</p>
<p>exemple: la compilation du shader suivant, qui comporte une erreur : </p><div class="fragment"><div class="line"><span class="preprocessor">#version 330</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> dx= 0.0;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> dy= 0;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> dz= 0;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main( )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// intialiser les coordonnees des 3 sommets</span></div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> positions[3]= <a class="code" href="structvec3.html">vec3</a>[3]( <a class="code" href="structvec3.html">vec3</a>(-0.5, -0.5, 0), <a class="code" href="structvec3.html">vec3</a>(0.5, -0.5, 0), <a class="code" href="structvec3.html">vec3</a>(0, 0.5, 0) );</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// recuperer le sommet a traiter</span></div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> p= positions[i];</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// calculer le resultat </span></div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a> r;</div>
<div class="line">    r.x= p.x + dx;</div>
<div class="line">    r.y= p.y + dy;</div>
<div class="line">    r.z= p.z + dz;</div>
<div class="line">    r.w= 1;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// renvoyer le sommet transforme</span></div>
<div class="line">    gl_Position= r;</div>
<div class="line">}</div>
</div><!-- fragment --><p>renvoie les erreurs : </p><div class="fragment"><div class="line">[errors]</div>
<div class="line">0(15) : error C1008: undefined variable <span class="stringliteral">&quot;i&quot;</span></div>
</div><!-- fragment --><p>ce qui n'est pas vraiment utilisable...</p>
<p><a class="el" href="program_8h.html">program.h</a> fournit une fonction utilitaire qui analyse le message d'erreur, retrouve les numéros de lignes sur lesquels se sont produit les erreurs, et les insère dans le source du shader :</p>
<div class="fragment"><div class="line">GLuint program= ... ;</div>
<div class="line"><a class="code" href="group__openGL.html#ga873fe3eb898a9ffe19c8274f83116b8a">program_print_errors</a>(program);</div>
</div><!-- fragment --><p>ce qui donne :</p>
<div class="fragment"><div class="line">  0001  #version 330</div>
<div class="line">  0003  </div>
<div class="line">  0004  </div>
<div class="line">  0005  <span class="keyword">const</span> <span class="keywordtype">float</span> dx= 0.0;</div>
<div class="line">  0006  <span class="keyword">const</span> <span class="keywordtype">float</span> dy= 0;</div>
<div class="line">  0007  <span class="keyword">const</span> <span class="keywordtype">float</span> dz= 0;</div>
<div class="line">  0008  </div>
<div class="line">  0009  <span class="keywordtype">void</span> main( )</div>
<div class="line">  0010  {</div>
<div class="line">  0011      <span class="comment">// intialiser les coordonnees des 3 sommets</span></div>
<div class="line">  0012      <a class="code" href="structvec3.html">vec3</a> positions[3]= <a class="code" href="structvec3.html">vec3</a>[3]( <a class="code" href="structvec3.html">vec3</a>(-0.5, -0.5, 0), <a class="code" href="structvec3.html">vec3</a>(0.5, -0.5, 0), <a class="code" href="structvec3.html">vec3</a>(0, 0.5, 0) );</div>
<div class="line">  0013      </div>
<div class="line">  0014      <span class="comment">// recuperer le sommet a traiter</span></div>
<div class="line">  0015      <a class="code" href="structvec3.html">vec3</a> p= positions[i];</div>
<div class="line"> </div>
<div class="line">error C1008: undefined variable <span class="stringliteral">&quot;i&quot;</span></div>
<div class="line"> </div>
<div class="line">  0016  </div>
<div class="line">  0017      <span class="comment">// calculer le resultat </span></div>
<div class="line">  0018      <a class="code" href="structvec4.html">vec4</a> r;</div>
<div class="line">  0019      r.x= p.x + dx;</div>
<div class="line">  0020      r.y= p.y + dy;</div>
<div class="line">  0021      r.z= p.z + dz;</div>
<div class="line">  0022      r.w= 1;</div>
<div class="line">  0023      </div>
<div class="line">  0024      <span class="comment">// renvoyer le sommet transforme</span></div>
<div class="line">  0025      gl_Position= r;</div>
<div class="line">  0026  }</div>
</div><!-- fragment --><p>vous pouvez compiler les shaders comme vous voulez et utiliser uniquement <a class="el" href="group__openGL.html#ga873fe3eb898a9ffe19c8274f83116b8a" title="affiche les erreurs de compilation.">program_print_errors()</a> ou <a class="el" href="group__openGL.html#gacb379652a3176b4038d8badff9108214" title="renvoie les erreurs de compilation.">program_format_errors()</a>.</p>
<p><em>pour les curieux :</em> le source est dispo <a class="el" href="program_8cpp_source.html">program.cpp</a>, fonctions print_line( ) et print_errors( ).</p>
<h2><a class="anchor" id="autotoc_md69"></a>
utilitaires : program.h</h2>
<p><a class="el" href="program_8h.html">program.h</a> fournit une fonction permettant de compiler plusieurs shaders écrits dans le même fichier, cf <a class="el" href="group__openGL.html#ga2d6e7b012b252577cc04bf9abdc4c5ba">read_program( )</a>. </p><div class="fragment"><div class="line">GLuint program= <a class="code" href="group__openGL.html#ga2d6e7b012b252577cc04bf9abdc4c5ba">read_program</a>( <span class="stringliteral">&quot;tutos/intro1.glsl&quot;</span> );</div>
</div><!-- fragment --><p>les shaders sont compilés séparement en utilisant le pré processeur, avec #ifdef VERTEX_SHADER, #ifdef FRAGMENT_SHADER, etc. un fichier .glsl ressemble à ça :</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 330</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef VERTEX_SHADER</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main( )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// intialiser les coordonnees des 3 sommets</span></div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> positions[3]= <a class="code" href="structvec3.html">vec3</a>[3]( <a class="code" href="structvec3.html">vec3</a>(-0.5, -0.5, 0), <a class="code" href="structvec3.html">vec3</a>(0.5, -0.5, 0), <a class="code" href="structvec3.html">vec3</a>(0, 0.5, 0) );</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// recuperer le sommet a traiter</span></div>
<div class="line">    gl_Position= positions[gl_VertexID];</div>
<div class="line">}</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef FRAGMENT_SHADER</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main( )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// remplir le triangle avec une couleur uniforme</span></div>
<div class="line">    gl_FragColor= <a class="code" href="structvec4.html">vec4</a>(0.8, 0.4, 0, 1);</div>
<div class="line">}</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p>cf <a class="el" href="tuto2GL_8cpp.html">tuto2GL.cpp</a> </p>
</div><!-- contents -->
<div class="ttc" id="agroup__openGL_html_ga2d6e7b012b252577cc04bf9abdc4c5ba"><div class="ttname"><a href="group__openGL.html#ga2d6e7b012b252577cc04bf9abdc4c5ba">read_program</a></div><div class="ttdeci">GLuint read_program(const char *filename, const char *definitions)</div><div class="ttdef"><b>Definition:</b> <a href="program_8cpp_source.html#l00203">program.cpp:203</a></div></div>
<div class="ttc" id="astructvec3_html"><div class="ttname"><a href="structvec3.html">vec3</a></div><div class="ttdoc">vecteur generique, utilitaire.</div><div class="ttdef"><b>Definition:</b> <a href="vec_8h_source.html#l00144">vec.h:144</a></div></div>
<div class="ttc" id="agroup__openGL_html_ga873fe3eb898a9ffe19c8274f83116b8a"><div class="ttname"><a href="group__openGL.html#ga873fe3eb898a9ffe19c8274f83116b8a">program_print_errors</a></div><div class="ttdeci">int program_print_errors(const GLuint program)</div><div class="ttdoc">affiche les erreurs de compilation.</div><div class="ttdef"><b>Definition:</b> <a href="program_8cpp_source.html#l00384">program.cpp:384</a></div></div>
<div class="ttc" id="astructvec4_html"><div class="ttname"><a href="structvec4.html">vec4</a></div><div class="ttdoc">vecteur generique 4d, ou 3d homogene, utilitaire.</div><div class="ttdef"><b>Definition:</b> <a href="vec_8h_source.html#l00166">vec.h:166</a></div></div>
<div class="ttc" id="agroup__application_html_ga6efbb9298a8f73b9a17959b56ec20267"><div class="ttname"><a href="group__application.html#ga6efbb9298a8f73b9a17959b56ec20267">printf</a></div><div class="ttdeci">void printf(Text &amp;text, const int px, const int py, const char *format,...)</div><div class="ttdoc">affiche un texte a la position x, y. meme utilisation que printf().</div><div class="ttdef"><b>Definition:</b> <a href="text_8cpp_source.html#l00140">text.cpp:140</a></div></div>
<div class="ttc" id="agroup__math_html_gaf34f93c25b062fad7f99a1e02d88a423"><div class="ttname"><a href="group__math.html#gaf34f93c25b062fad7f99a1e02d88a423">length</a></div><div class="ttdeci">float length(const Vector &amp;v)</div><div class="ttdoc">renvoie la longueur d'un vecteur.</div><div class="ttdef"><b>Definition:</b> <a href="vec_8cpp_source.html#l00142">vec.cpp:142</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 9 2019 15:39:11 for gKit2 light by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
