<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gKit2 light: openGL 4.3 : storage textures / images</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">gKit2 light
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">openGL 4.3 : storage textures / images</div>  </div>
</div><!--header-->
<div class="contents">
<p>cf <a class="el" href="tuto__storage__texture_8cpp.html">tuto_storage_texture.cpp</a></p>
<h3><a class="anchor" id="autotoc_md116"></a>
compute shader et textures</h3>
<p>Les textures sont accessibles en lecture avec un sampler, comme dans les fragment shaders. Il y a quand même une différence, habituellement le pipeline graphique calcule automatiquement les paramètres de filtrage de la texture, mais comme un compute shader ne fait pas parti du pipeline graphique, il faut choisir le mipmap explicitement avec <code>textureLod()</code>, par exemple.</p>
<h3><a class="anchor" id="autotoc_md117"></a>
écrire dans une texture</h3>
<p>Lorsqu'un shader (fragment ou compute) veut écrire dans une texture, il faut "emballer" la texture dans un objet openGL, une <code>texture image</code> (rappel: pour que le pipeline graphique écrive dans une texture, il faut aussi l'emballer dans un framebuffer object, cf <a class="el" href="group__framebuffer.html">rendu multi-passes : shadow maps, post process</a>). Et comme d'habitude, plusieurs images peuvent être déclarées, elles sont donc numérotées, comme les unités de textures, ou les sorties d'un framebuffer object.</p>
<p>C'est <code>glBindImageTexture()</code> qui permet de configurer le pipeline / d'associer une texture à une unité : </p><div class="fragment"><div class="line">GLuint texture= { ... };</div>
<div class="line">GLint unit= 0;</div>
<div class="line">glBindImageTexture( unit, <span class="comment">/* texture */</span> texture, <span class="comment">/* level */</span> 0, </div>
<div class="line">    <span class="comment">/* layered */</span> GL_TRUE, <span class="comment">/* layer */</span> 0, </div>
<div class="line">    <span class="comment">/* access */</span> GL_WRITE_ONLY, <span class="comment">/* format */</span> GL_RGBA8UI );</div>
</div><!-- fragment --><p>Pour des textures 2d classiques, les paramètres layered et layer sont ignorés. Il faut donc préciser la texture, le niveau de mipmap à sélectionner, le type d'accès (lecture seule <code>GL_READ_ONLY</code>, écriture seule <code>GL_WRITE_ONLY</code>, mixte <code>GL_READ_WRITE</code>) et le format interne des texels (GL_RGBA8UI pour les textures classiques avec des valeurs 0..255 par canal et 4 canaux, rgb et a) à utiliser lorsque le shader écrit une valeur dans l'image.</p>
<p>Dernière étape, fournir au shader, le numéro de l'unité sur laquelle la texture est sélectionnée, c'est le même principe que pour les unités de textures et les samplers : </p><div class="fragment"><div class="line"><span class="comment">// selectionner le shader program, si necessaire</span></div>
<div class="line"><span class="comment">// glUseProgram(program);</span></div>
<div class="line"> </div>
<div class="line">GLint location= glGetUniformLocation(program, <span class="stringliteral">&quot;...&quot;</span>);</div>
<div class="line">glUniform1i(location, unit);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md118"></a>
déclaration dans le shader</h3>
<p>Les images sont des uniforms déclarés avec le type :</p><ul>
<li><code>image2D</code> pour les textures 2d classiques (réels),</li>
<li><code>uimage2D</code> pour les textures 2d (entièrs non signés),</li>
<li><code>iimage2D</code> pour les textures 2d (entièrs signés).</li>
</ul>
<p>La déclaration doit aussi être décorée avec le format des données en cas de lecture (ou d'accès mixte) et éventuellement l'indice de l'unité sur laquelle la texture est sélectionnée : </p><div class="fragment"><div class="line">layout(binding= 0) writeonly uniform image2D image;</div>
<div class="line">layout(binding= 0, rgba8ui) readonly uniform uimage2D image;</div>
<div class="line">layout(binding= 0, rgba8ui) coherent uniform uimage2D image;</div>
</div><!-- fragment --><p><b>attention :</b> les accès déclarés dans le shader et par l'application (cf <code>glBindImageTexture()</code>) doivent être les mêmes.</p>
<p>Tous les formats de textures ne sont pas disponibles, seuls les versions 1, 2 et 4 canaux existent : <code>r</code>, <code>rg</code>, <code>rgba</code>, par contre les formats sont les memes, 8bits entiers, 16bits réels, 32bits réels et entiers, signés ou pas. Ils sont désignés par les suffixes : <code>8</code>, <code>16</code> ou <code>32</code> pour la taille et par <code>i</code>, <code>ui</code> ou <code>f</code> pour entier, entier non signé et réel. Voici les types courants : <code>rgba8ui</code>, <code>rgba32f</code>, <code>r32ui</code>.</p>
<h3><a class="anchor" id="autotoc_md119"></a>
lecture</h3>
<p>c'est la fonction <code>imageLoad( image, ivec2 pixel )</code> qui permet de lire une valeur. Les coordonnées du pixel sont comprises entre 0 et largur / hauteur. La valeur renvoyée dépend de la déclaration de l'image. <code>image2D</code> renvoie un <a class="el" href="structvec4.html" title="vecteur generique 4d, ou 3d homogene, utilitaire.">vec4</a>, <code>uimage2D</code> renvoie un uvec4, etc.</p>
<p>L'image doit etre déclarée en lecture : </p><div class="fragment"><div class="line"><span class="comment">// shader</span></div>
<div class="line">layout(binding= 0, rgba8ui) readonly uniform uimage2D image;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main( )</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a> color= imageLoad(image, ivec2(x, y));</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// application</span></div>
<div class="line">GLuint program= { ... };</div>
<div class="line">GLuint texture= { ... };</div>
<div class="line">GLint unit= 0;</div>
<div class="line"> </div>
<div class="line">glBindImageTexture( unit, texture, <span class="comment">/* level*/</span> 0, </div>
<div class="line">    <span class="comment">/* layered */</span> GL_TRUE, <span class="comment">/* layer */</span> 0, </div>
<div class="line">    <span class="comment">/* access */</span> GL_READ_ONLY, <span class="comment">/* format*/</span> GL_RGBA8UI );</div>
<div class="line">    </div>
<div class="line">GLint location= glGetUniformLocation(program, <span class="stringliteral">&quot;image&quot;</span>);</div>
<div class="line">glUniform1i(location, unit);    </div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md120"></a>
écriture</h3>
<p>c'est la fonction <code>imageStore( image, ivec2 pixel, values )</code> qui permet d'écrire une valeur. le type des valeurs écrites dans l'image dépend aussi de la déclaration de l'image. Et bien sur l'image doit etre déclarée en écriture :</p>
<div class="fragment"><div class="line"><span class="comment">// shader</span></div>
<div class="line">layout(binding= 0) writeonly uniform image2D image;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main( )</div>
<div class="line">{</div>
<div class="line">    imageStore(image, ivec2(x, y), <a class="code" href="structvec4.html">vec4</a>(r, g, b, a));</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// application</span></div>
<div class="line">GLuint program= { ... };</div>
<div class="line">GLuint texture= { ... };</div>
<div class="line">GLint unit= 0;</div>
<div class="line"> </div>
<div class="line">glBindImageTexture( unit, texture, <span class="comment">/* level*/</span> 0, </div>
<div class="line">    <span class="comment">/* layered */</span> GL_TRUE, <span class="comment">/* layer */</span> 0, </div>
<div class="line">    <span class="comment">/* access */</span> GL_WRITE_ONLY, <span class="comment">/* format*/</span> GL_RGBA8UI );</div>
<div class="line"> </div>
<div class="line">GLint location= glGetUniformLocation(program, <span class="stringliteral">&quot;image&quot;</span>);</div>
<div class="line">glUniform1i(location, unit);    </div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md121"></a>
opération atomiques</h3>
<p>les images permettent aussi d'utiliser les opérations atomiques <code>imageAtomicAdd()</code>, <code>imageAtomicMin()</code>, <code>imageAtomicMax()</code>, <code>imageAtomicAnd()</code>, <code>imageAtomicOr()</code>, <code>imageAtomicXor()</code> et <code>imageAtomicExchange()</code><code>imageAtomicCompSwap()</code>.</p>
<p>L'image doit être déclarée en lecture / écriture cohérente et avec un type entier 32 bits : </p><div class="fragment"><div class="line"><span class="comment">// shader</span></div>
<div class="line">layout(binding= 0, r32ui) coherent uniform uimage2D image;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main( )</div>
<div class="line">{</div>
<div class="line">    imageAtomicAdd(image, ivec2(x, y), 1);</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// application</span></div>
<div class="line">GLuint program= { ... };</div>
<div class="line">GLuint texture= { ... };</div>
<div class="line">GLint unit= 0;</div>
<div class="line"> </div>
<div class="line">glBindImageTexture( unit, texture, <span class="comment">/* level*/</span> 0, </div>
<div class="line">    <span class="comment">/* layered */</span> GL_TRUE, <span class="comment">/* layer */</span> 0, </div>
<div class="line">    <span class="comment">/* access */</span> GL_READ_WRITE, <span class="comment">/* format*/</span> GL_R32UI );</div>
<div class="line"> </div>
<div class="line">GLint location= glGetUniformLocation(program, <span class="stringliteral">&quot;image&quot;</span>);</div>
<div class="line">glUniform1i(location, unit);    </div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md122"></a>
créer une texture GL_R32UI / entiers</h2>
<p>Les textures classiques stockent des couleurs soit directement avec des réels (<code>GL_RGBA32F</code>), soit avec des entiers normalisés (<code>GL_RGBA</code> ou <code>GL_RGBA8</code>). Pour créer une texture permettant de stocker des entiers non normalisés, il faut utiliser <code>GL_RED_INTEGER</code> pour un canal, et <code>GL_RG_INTEGER</code>, <code>GL_RGB_INTEGER</code> ou <code>GL_RGBA_INTEGER</code>, pour 2, 3, et 4 canaux.</p>
<div class="fragment"><div class="line">GLuint texture= 0;</div>
<div class="line">glGenTextures(1, &amp;texture);</div>
<div class="line">glBindTexture(GL_TEXTURE_2D, texture);</div>
<div class="line">glTexImage2D(GL_TEXTURE_2D, 0,</div>
<div class="line">    GL_R32UI, width, height, 0,</div>
<div class="line">    GL_RED_INTEGER, GL_UNSIGNED_INT, <span class="keyword">nullptr</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// pas de mipmaps</span></div>
<div class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 0);</div>
</div><!-- fragment --> </div><!-- contents -->
<div class="ttc" id="astructvec4_html"><div class="ttname"><a href="structvec4.html">vec4</a></div><div class="ttdoc">vecteur generique 4d, ou 3d homogene, utilitaire.</div><div class="ttdef"><b>Definition:</b> <a href="vec_8h_source.html#l00166">vec.h:166</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 9 2019 15:39:11 for gKit2 light by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
