<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gKit2 light: shaders et GLSL</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">gKit2 light
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">shaders et GLSL</div>  </div>
</div><!--header-->
<div class="contents">
<p>le pipeline a besoin d'un vertex shader et d'un fragment shader pour fonctionner, repassez dans <a class="el" href="group__intro3d.html">introduction api 3d, openGL et pipeline graphique</a> si nécessaire, et dans <a class="el" href="group__tuto2GL.html">compiler et linker un shader program</a> pour savoir comment les compiler, et <a class="el" href="group__tuto3GL.html">afficher plusieurs triangles, modifier les paramètres uniform d'un shader program</a> pour afficher simplement quelques triangles (un cube, par exemple).</p>
<h2><a class="anchor" id="autotoc_md30"></a>
présentation GLSL</h2>
<p>GLSL est le langage permettant d'écrire des shaders, il est très proche du C/C++, avec quelques limitations :</p><ul>
<li>pas de pointeurs,</li>
<li>pas de fonctions récursives,</li>
<li>des tableaux, mais une dimension,</li>
<li>des structs, mais pas d'heritage,</li>
<li>pas de passage de valeur par référence, mais par copie.</li>
</ul>
<p>il existe plusieurs versions du langage, il faut préciser laquelle avec la directive <code>#version xxx</code>. la version classique est la version 330 / openGL 3.3. la plupart des shaders commencent donc par la ligne <code>#version 330</code>.</p>
<p>les types de base sont classiques : int, uint, bool, float, mais les vecteurs et les matrices sont définies ainsi que leurs opérations :</p><ul>
<li><a class="el" href="structvec2.html" title="vecteur generique, utilitaire.">vec2</a>, <a class="el" href="structvec3.html" title="vecteur generique, utilitaire.">vec3</a>, <a class="el" href="structvec4.html" title="vecteur generique 4d, ou 3d homogene, utilitaire.">vec4</a> : pour des vecteurs à 2, 3, 4 composantes float,</li>
<li>ivec2, ivec3, ivec4 : pour des vecteurs d'entiers,</li>
<li>uvec2, uvec3, uvec4 : pour des vecteurs d'entiers non signés,</li>
<li>bvec2, bvec3, bvec4 : pour des vecteurs de bool,</li>
<li>mat2, mat3, mat4 : pour les matrices 2x2, 3x3 et 4x4.</li>
</ul>
<p>la librairie standard contient à peu près tout ce qui est nécessaire pour des calculs graphiques, consultez la doc officielle : <a href="https://www.opengl.org/sdk/docs/man/">openGL SDK</a>, par exemple les produits de matrices, les produits matrices / vecteurs...</p>
<p>l'initialisation des vecteurs, matrices et vecteurs n'utilise pas toujours la même syntaxe que le C++, par exemple : </p><div class="fragment"><div class="line"><a class="code" href="structvec3.html">vec3</a> point;</div>
<div class="line">point= <a class="code" href="structvec3.html">vec3</a>(1, 1, 1);</div>
<div class="line"><a class="code" href="structvec3.html">vec3</a> extremite= <a class="code" href="structvec3.html">vec3</a>(1, 0, 0);  <span class="comment">// vec3 extremite(1, 0, 0); n&#39;existe pas</span></div>
<div class="line"><a class="code" href="structvec3.html">vec3</a> direction= extremite - point;</div>
<div class="line"> </div>
<div class="line">mat4 m= mat4( <a class="code" href="structvec4.html">vec4</a>(....), <a class="code" href="structvec4.html">vec4</a>(...), <a class="code" href="structvec4.html">vec4</a>(...), <a class="code" href="structvec4.html">vec4</a>(...) );</div>
<div class="line"> </div>
<div class="line"><a class="code" href="structvec3.html">vec3</a> positions[3]= <a class="code" href="structvec3.html">vec3</a>[3]( <a class="code" href="structvec3.html">vec3</a>(-0.5, -0.5, 0), <a class="code" href="structvec3.html">vec3</a>(0.5, -0.5, 0), <a class="code" href="structvec3.html">vec3</a>(0, 0.5, 0) );</div>
</div><!-- fragment --><p>la déclaration des structures est sans surprise : </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Sphere</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> centre;</div>
<div class="line">    <span class="keywordtype">float</span> rayon;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">Sphere scene[4];</div>
</div><!-- fragment --><p>les opérateurs sur les vecteurs et les matrices fonctionnent, là encore, sans surprises : </p><div class="fragment"><div class="line"><a class="code" href="structvec4.html">vec4</a> point= <a class="code" href="structvec4.html">vec4</a>( ... );</div>
<div class="line">mat4 m= mat4( ... );</div>
<div class="line"><a class="code" href="structvec4.html">vec4</a> r= m * point;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="structvec4.html">vec4</a> q= r + <a class="code" href="structvec4.html">vec4</a>( ... );</div>
<div class="line"><a class="code" href="structvec4.html">vec4</a> s= r + point;</div>
</div><!-- fragment --><p>l'opérateur de sélection de composantes sur les vecteurs est plutôt pratique : </p><div class="fragment"><div class="line"><a class="code" href="structvec4.html">vec4</a> a= <a class="code" href="structvec4.html">vec4</a>( ... );</div>
<div class="line"><a class="code" href="structvec3.html">vec3</a> b= a.xyz;</div>
<div class="line"><a class="code" href="structvec4.html">vec4</a> c= a.zwxx;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="structvec3.html">vec3</a> p= <a class="code" href="structvec3.html">vec3</a>( ... );</div>
<div class="line"><a class="code" href="structvec3.html">vec3</a> q.xzy= p.xzy;      <span class="comment">// quelle valeur est affectee a q ?</span></div>
</div><!-- fragment --><p>les constructeurs acceptent aussi d'extraire les premières composantes, pour les vecteurs mais aussi pour les matrices : </p><div class="fragment"><div class="line"><a class="code" href="structvec4.html">vec4</a> p= <a class="code" href="structvec4.html">vec4</a>( ... );</div>
<div class="line"><a class="code" href="structvec3.html">vec3</a> q= <a class="code" href="structvec3.html">vec3</a>(p);        <span class="comment">// ou q= p.xyz;</span></div>
<div class="line"> </div>
<div class="line">mat4 m= mat4( ... );</div>
<div class="line">mat3 t= mat3(m);        <span class="comment">// t[0]= vec3(m[0]); t[1]= vec3(m[1]); t[2]= vec3(m[2]);</span></div>
</div><!-- fragment --><p>et ça fonctionne aussi dans l'autre sens, on peut construire un vecteur à partir d'un autre vecteur plus court, plus d'autres valeurs : </p><div class="fragment"><div class="line"><span class="preprocessor">#version 330</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="structvec3.html">vec3</a> position= <a class="code" href="structvec3.html">vec3</a>( ... );</div>
<div class="line">mat4 mvpMatrix= mat4( ... );</div>
<div class="line"> </div>
<div class="line">gl_Position= mvpMatrix * <a class="code" href="structvec4.html">vec4</a>(position, 1);     <span class="comment">// position 3 floats + un float == 4 floats </span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md31"></a>
fonctions et passage par copie</h3>
<p>les fonctions (non récursives) s'écrivent comme d'habitude, la seule différence notable est le passage des paramètres qui utilise des mot clés <code>in</code>, <code>out</code>, <code>inout</code> pour indiquer les paramètres d'entrée, de sortie et d'entrée / sortie : </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f1( in <span class="keywordtype">float</span> a, out <span class="keywordtype">float</span> b )</div>
<div class="line">{</div>
<div class="line">    b= a + 10;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> f2( in a, inout b )</div>
<div class="line">{</div>
<div class="line">    b= a + 2*b;</div>
<div class="line">}</div>
</div><!-- fragment --><p>il est également possible d'utiliser <code>const</code> sur les parametres des fonctions : </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f1( <span class="keyword">const</span> in <span class="keywordtype">float</span> a, out <span class="keywordtype">float</span> b )</div>
<div class="line">{</div>
<div class="line">    b= a + 10;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> f2( <span class="keyword">const</span> in a, inout b )</div>
<div class="line">{</div>
<div class="line">    b= a + 2*b;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md32"></a>
vertex shader et GLSL</h2>
<p>un vertex shader est composée d'une fonction principale, <code>void main( void )</code>, et doit écrire les coordonnées des sommets dans une variable globale <code><a class="el" href="structvec4.html" title="vecteur generique 4d, ou 3d homogene, utilitaire.">vec4</a> gl_Position</code> (<em>rappel :</em> coordonnées x, y, z et w dans le repère projectif).</p>
<p>les attributs se déclarent en global avec le mot clé <code>in</code>, les varyings/sorties avec <code>out</code>, les constantes initialisées avec <code>const</code>.</p>
<p>les variables fournies par l'application sont déclarées avec le mot-clé <code>uniform</code> en plus de leur type et de leur nom.</p>
<p>le vertex shader à également accès à des variables définies par le pipeline, elles sont toutes prefixées par <code>gl_</code> (cf <a href="https://www.opengl.org/sdk/docs/man/">openGL SDK</a>, section glsl, lettre g), par exemple : gl_VertexID, l'indice du sommet à traiter.</p>
<p>exemple : </p><div class="fragment"><div class="line"><span class="comment">// vertex shader de tuto3GL</span></div>
<div class="line"><span class="preprocessor">#version 330</span></div>
<div class="line"> </div>
<div class="line">uniform <a class="code" href="structvec3.html">vec3</a> positions[36];     <span class="comment">// declare un uniform, un tableau de vec3</span></div>
<div class="line">uniform <span class="keywordtype">float</span> time;             <span class="comment">// declare un uniform, time de type float</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <a class="code" href="structvec3.html">vec3</a> deplace= <a class="code" href="structvec3.html">vec3</a>(...);  <span class="comment">// declare une constante</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main( )</div>
<div class="line">{</div>
<div class="line">    gl_Position= <a class="code" href="structvec4.html">vec4</a>( positions[gl_VertexID] + deplace * time / 1000.0, 1.0 );</div>
<div class="line">    <span class="comment">// positions[gl_VertexID] est un vec3 + vec3 * float / float, ce qui donne bien un vec3</span></div>
<div class="line">    <span class="comment">// et le vec3 est complete par une valeur pour etre affecte a un vec4</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>le vertex shader déclare, en général, des attributs de sommets initialisés par le pipeline (l'application devra configurer un vertex array et créer des buffers, cf <a class="el" href="group__tuto4GL.html">configurer un format de sommet, vertex array object</a>) : </p><div class="fragment"><div class="line"><span class="comment">// vertex shader et attributs</span></div>
<div class="line"><span class="preprocessor">#version 330</span></div>
<div class="line"> </div>
<div class="line">in <a class="code" href="structvec3.html">vec3</a> position;               <span class="comment">// declare un attribut, position de type vec3</span></div>
<div class="line"> </div>
<div class="line">uniform mat4 mvpMatrix;         <span class="comment">// declare un uniform, mvpMatrix de type mat4</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main( <span class="keywordtype">void</span> )</div>
<div class="line">{</div>
<div class="line">    gl_Position= mvpMatrix * <a class="code" href="structvec4.html">vec4</a>(position, 1);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md33"></a>
fragment shader et GLSL</h2>
<p>le fragment shader est similaire au vertex shader, mais il ne peut pas utiliser les valeurs des attributs, ils ne sont plus accessibles, uniquement leurs valeurs interpolées, les <em>varyings</em> (repassez dans <a class="el" href="group__intro3d.html">introduction api 3d, openGL et pipeline graphique</a> et <a class="el" href="group__intro3d.html#pipeline">pipeline graphique openGL</a>, si ce n'est pas clair)</p>
<p>la couleur du fragment doit être écrite dans un <code>out <a class="el" href="structvec4.html" title="vecteur generique 4d, ou 3d homogene, utilitaire.">vec4</a> gl_FragColor</code> ou une variable en sortie déclarée par le shader <code>out <a class="el" href="structvec4.html" title="vecteur generique 4d, ou 3d homogene, utilitaire.">vec4</a> fragment_color;</code> selon la version d'openGL.</p>
<p>un fragment shader peut déclarer des uniforms et des varyings, et accéder à plusieurs variables définies par le pipeline, par exemple :</p><ul>
<li><code><a class="el" href="structvec4.html" title="vecteur generique 4d, ou 3d homogene, utilitaire.">vec4</a> gl_FragCoord</code>, les coordonnées dans le repère image du fragment,</li>
<li><code>int gl_PrimitiveID</code>, l'indice de la primitive, du triangle, traité par le shader,</li>
<li><code>bool gl_FrontFacing</code>, l'orientation de la primitive traitée par le shader, toujours vrai si les faces arrières sont éliminées avant la fragmentation (cf <a class="el" href="group__intro3d.html">introduction api 3d, openGL et pipeline graphique</a>).</li>
</ul>
<p>exemple: </p><div class="fragment"><div class="line"><span class="comment">// fragment shader et variables</span></div>
<div class="line"><span class="preprocessor">#version 330</span></div>
<div class="line"> </div>
<div class="line">uniform <a class="code" href="structvec3.html">vec3</a> back_color;        <span class="comment">// uniform, couleur pour les faces mal orientees</span></div>
<div class="line"> </div>
<div class="line">out <a class="code" href="structvec4.html">vec4</a> fragment_color;        <span class="comment">// varying, couleur du fragment, ecrite dans l&#39;image par le pipeline</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main( <span class="keywordtype">void</span> )</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> color;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// utiliser l&#39;indice du triangle, gl_PrimitiveID, pour fabriquer une couleur &quot;aleatoire&quot;</span></div>
<div class="line">    color= <a class="code" href="structvec3.html">vec3</a>(1.0 - <span class="keywordtype">float</span>(gl_PrimitiveID % 100) / 99.0, <span class="keywordtype">float</span>(gl_PrimitiveID % 10) / 9.0, <span class="keywordtype">float</span>(gl_PrimitiveID % 1000) / 999.0);</div>
<div class="line">    <span class="comment">// glsl n&#39;autorise pas les casts avec la syntaxe du C, </span></div>
<div class="line">    <span class="comment">// donc utiliser la notation constructeur comme en C++</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// si le triangle est une face arriere, l&#39;afficher d&#39;une couleur differente, cf parametre uniform, initialise par l&#39;application </span></div>
<div class="line">    <span class="keywordflow">if</span>(gl_FrontFacing == <span class="keyword">false</span>)</div>
<div class="line">        color= back_color;</div>
<div class="line">        </div>
<div class="line">    fragment_color= <a class="code" href="structvec3.html">vec3</a>(color, 1);       <span class="comment">// couleur opaque, alpha= 1</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md34"></a>
uniforms, varyings et variables</h2>
<p>à quoi servent les différents types de variables ?</p><ul>
<li>les <code>uniform</code> correspondent à des valeurs fournies par l'application, elles ne changent pas de valeur pendant l'exécution des shaders, cf <a class="el" href="group__tuto2GL.html">compiler et linker un shader program</a>,</li>
<li>les <code>in</code> sont les entrées du shader :<ul>
<li>pour un vertex shader, ils représentent les attributs du sommet, c'est le pipeline qui affecte les valeurs en fonction du vertex array object sélectionné par l'application au moment du draw( ). cf <a class="el" href="group__tuto4GL.html">configurer un format de sommet, vertex array object</a></li>
<li>pour les autres shaders, les fragment shaders, par exemple, ce sont des varyings, des entrées qui doivent correspondre à des sorties déclarées par les shaders précédents dans le pipeline. ces variables n'existent que pendant l'exécution du pipeline et ne sont pas accessibles par l'application.</li>
</ul>
</li>
<li>les <code>out</code> sont les sorties du shader.</li>
</ul>
<p><em>exemple :</em> si chaque sommet est décrit par une position et une couleur, les entrées du vertex shader sont 2 attributs, déclarés avec <code>in</code> et configurés par l'application.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 330</span></div>
<div class="line"><span class="comment">// vertex shader</span></div>
<div class="line"> </div>
<div class="line">in <a class="code" href="structvec3.html">vec3</a> position;               <span class="comment">// attribut</span></div>
<div class="line">in <a class="code" href="structvec4.html">vec4</a> color;                  <span class="comment">// attribut</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main( )</div>
<div class="line">{</div>
<div class="line">    gl_Position= ... ;          <span class="comment">// obligatoire, affecter une position</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>si on veut que le fragment shader utilise la couleur des sommets pour calculer sa couleur, il faut les lui transmettre explicitement, il ne peut pas y accéder tout seul. dans ce cas, la couleur est un varying, déclarée comme sortie optionnelle du vertex shader (avec <code>out</code>) et comme entrée (avec <code>in</code>) du fragment shader.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 330</span></div>
<div class="line"><span class="comment">// vertex shader</span></div>
<div class="line"> </div>
<div class="line">in <a class="code" href="structvec3.html">vec3</a> position;</div>
<div class="line">in <a class="code" href="structvec4.html">vec4</a> color;</div>
<div class="line"> </div>
<div class="line">out <a class="code" href="structvec4.html">vec4</a> vertex_color;          <span class="comment">// sortie, varying</span></div>
<div class="line"><span class="keywordtype">void</span> main( )</div>
<div class="line">{</div>
<div class="line">    vertex_color= color;</div>
<div class="line">    gl_Position= ... ;</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="preprocessor">#version 330</span></div>
<div class="line"><span class="comment">// fragment shader</span></div>
<div class="line"> </div>
<div class="line">in <a class="code" href="structvec4.html">vec4</a> vertex_color;           <span class="comment">// entree, varying, meme type et meme nom que dans le vertex shader</span></div>
<div class="line"> </div>
<div class="line">out <a class="code" href="structvec4.html">vec4</a> fragment_color;        <span class="comment">// varying, couleur du fragment, ecrite dans l&#39;image par le pipeline</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main( )</div>
<div class="line">{</div>
<div class="line">    fragment_color= vertex_color;</div>
<div class="line">    <span class="comment">// le fragment shader doit ecrire une couleur dans la variable declaree en sortie, cf out vec4 fragment_color.</span></div>
<div class="line">}</div>
</div><!-- fragment --> </div><!-- contents -->
<div class="ttc" id="astructvec3_html"><div class="ttname"><a href="structvec3.html">vec3</a></div><div class="ttdoc">vecteur generique, utilitaire.</div><div class="ttdef"><b>Definition:</b> <a href="vec_8h_source.html#l00144">vec.h:144</a></div></div>
<div class="ttc" id="astructvec4_html"><div class="ttname"><a href="structvec4.html">vec4</a></div><div class="ttdoc">vecteur generique 4d, ou 3d homogene, utilitaire.</div><div class="ttdef"><b>Definition:</b> <a href="vec_8h_source.html#l00166">vec.h:166</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 9 2019 15:39:11 for gKit2 light by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
