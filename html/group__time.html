<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gKit2 light: mesure du temps cpu et gpu</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">gKit2 light
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">mesure du temps cpu et gpu</div>  </div>
</div><!--header-->
<div class="contents">
<p>cf <a class="el" href="tuto__time_8cpp.html">tuto_time.cpp</a></p>
<p>il y a toujours plusieurs solutions pour dessiner des objets, et chacune présente des avantages (simple à écrire) et des inconvénients (trop lente...), une manière de sélectionner la "meilleure" solution est donc nécessaire. Un critère de sélection est le temps d'exécution.</p>
<p>l'application, la librairie et le driver openGL fonctionnent sur le cpu et le pipeline graphique sur le gpu, de manière asynchrone. Par exemple, un appel à glDrawArrays( ) n'est pas bloquant, l'application continue à s'exécuter sans attendre que le gpu commence à dessiner. Il est donc nécessaire de mesurer le temps cpu et le temps gpu... un seul appel à glDrawArrays( ) peut faire dessiner des millions de triangles ou un seul... par contre, l'application, la librairie et le driver feront le meme travail dans les 2 cas. Il est tout à fait possible que le temps cpu soit plus important que le temps gpu...</p>
<h2><a class="anchor" id="autotoc_md130"></a>
mesure temps cpu</h2>
<p>il suffit d'utiliser les fonctionnalités de <a href="http://www.cplusplus.com/reference/chrono/">std::chrono du c++ 11</a> pour mesurer le temps d'exécution sur cpu. Le principe est simple :</p><ul>
<li>relever l'heure courante,</li>
<li>exécuter la fonction dont on veut mesurer le temps,</li>
<li>relever l'heure à la fin de l'exécution,</li>
<li>calculer la différence.</li>
</ul>
<p>la seule subtilité est la précision necéssaire pour faire les mesures : pour le cpu c'est de l'ordre de la micro seconde... et il faut choisir l'horloge la plus précise <code>std::chrono::high_resolution_clock</code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span></div>
<div class="line"> </div>
<div class="line">{</div>
<div class="line">    <span class="comment">// temps courant, avant l&#39;execution</span></div>
<div class="line">    std::chrono::high_resolution_clock::time_point a= std::chrono::high_resolution_clock::now();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// faire quelquechose</span></div>
<div class="line">    { ... }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// temps courant, apres l&#39;execution</span></div>
<div class="line">    std::chrono::high_resolution_clock::time_point b= std::chrono::high_resolution_clock::now();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// mesurer la difference, et l&#39;exprimer en microsecondes </span></div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> time= std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(b - a).count();</div>
<div class="line">}</div>
</div><!-- fragment --><p>l'utilisation est la même dans une application openGL.</p>
<p><b>remarque :</b> <code>std::high_resolution_clock</code> est buggé sur visual studio avant la version 2015.</p>
<h2><a class="anchor" id="autotoc_md131"></a>
mesure temps gpu</h2>
<p>Pour mesurer le temps gpu, il faut demander à openGL de le faire et de transmettre le résultat. C'est un objet "query" qui permet de stocker ces mesures et glBeginQuery() / glEndQuery() qui permettent de faire la mesure. L'utilisation est très proche de la version cpu, mais il faut bien sur créer un objet query avant toute chose :</p>
<div class="fragment"><div class="line">GLuint time;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="shader__kit_8cpp.html#a72fad2bb274e5f3b6d190bd860ea63b5">init</a>( )</div>
<div class="line">{</div>
<div class="line">    glGenQueries(1, &amp;time);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> quit( )</div>
<div class="line">{</div>
<div class="line">    glDeleteQueries(1, &amp;time);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> draw( )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// temps courant, avant l&#39;execution</span></div>
<div class="line">    glBeginQuery( GL_TIME_ELAPSED, time );</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// dessiner quelquechose</span></div>
<div class="line">    { ... }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// temps courant, apres l&#39;execution</span></div>
<div class="line">    glEndQuery( GL_TIME_ELAPSED );</div>
<div class="line">}</div>
</div><!-- fragment --><p>Les requêtes GL_TIME_ELAPSED mesurent directement la durée entre BeginQuery et EndQuery. Il est aussi possible de recupérer le temps courant avec glQueryCounter( ), mais il faut qu'une requête GL_TIME_ELAPSED soit en cours...</p>
<p>Il ne reste plus qu'à récupérer le résultat avec glGetQueryObject( ). openGL mesure le temps en nanosecondes et renvoie le resultat comme un entier 64 bits, il faut donc utiliser un GLint64 pour récupérer le résultat ;</p>
<div class="fragment"><div class="line">GLint64 gpu_time= 0;</div>
<div class="line">glGetQueryObjecti64v(time, GL_QUERY_RESULT, &amp;gpu_time);</div>
</div><!-- fragment --><p>et il n'y a plus qu'à convertir la durée dans une unité un peu plus "lisible" avant de l'afficher, par exemple en millisecondes et microsecondes : </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> milli= (int) (gpu_time / 1000000);</div>
<div class="line"><span class="keywordtype">int</span> micro= (int) ((gpu_time / 1000) % 1000);</div>
<div class="line"><a class="code" href="group__application.html#ga6efbb9298a8f73b9a17959b56ec20267">printf</a>(<span class="stringliteral">&quot;gpu  %02dms %03dus&quot;</span>, milli, micro);</div>
</div><!-- fragment --><p><b>attention :</b> il faut attendre que le gpu ait fini de dessiner pour connaitre la durée, et cette attente bloque le cpu ! en pratique ca ne pose pas de problème, si glGetQueryObject( ) est utilisé après avoir tout dessiné. <a class="el" href="tuto__time_8cpp.html">tuto_time.cpp</a> mesure aussi ce temps d'attente cpu. pour l'affichage d'une scène simple, il est de l'ordre de 16 millisecondes.</p>
<h2><a class="anchor" id="autotoc_md132"></a>
et alors ?</h2>
<p><a class="el" href="tuto__time_8cpp.html">tuto_time.cpp</a> affiche un objet "normalement" et compare ensuite les temps de rendu cpu/gpu pour 2 manières différentes d'afficher 25 objets (identiques) disposés sur une grille 5x5 :</p><ul>
<li>mode 1 : affiche 25 fois l'objet en modifiant sa transformation model, pour placer les 25 copies sur une grille,</li>
<li>mode 2 : utilise glDrawArraysInstanced( ) pour faire la même chose mais avec un seul draw... le travail pour le gpu est le meme : 25 fois plus de sommets à transformer et de triangles à dessiner, mais c'est le vertex shader qui calcule la position de chaque copie, cf <a class="el" href="group__draw.html">glDraw( ) et la famille</a> pour les explications.</li>
</ul>
<p>bilan :</p><ul>
<li>mode 0 : 1 draw, temps cpu 50us, gpu 6us</li>
<li>mode 1 : devrait prendre 25 fois plus de temps ? temps cpu 500us, gpu 100us</li>
<li>mode 2 : ?? temps cpu 40us, gpu 80us</li>
</ul>
<p>que peut on en déduire ? premièrement que faire 25 appels à glDrawArrays() (cf mode 1) est très couteux pour le cpu, plus que pour le gpu !! selon les performances de la machine, ce sera soit le cpu soit le gpu qui limitera le nombre d'objets que l'on peut dessiner. et que le gpu peut faire l'equivalent de manière plus efficace (mode 2 plus performant que mode 1, pour le cpu bien sur, mais egalement pour le gpu). </p>
</div><!-- contents -->
<div class="ttc" id="ashader__kit_8cpp_html_a72fad2bb274e5f3b6d190bd860ea63b5"><div class="ttname"><a href="shader__kit_8cpp.html#a72fad2bb274e5f3b6d190bd860ea63b5">init</a></div><div class="ttdeci">int init(std::vector&lt; const char * &gt; &amp;options)</div><div class="ttdef"><b>Definition:</b> <a href="shader__kit_8cpp_source.html#l00094">shader_kit.cpp:94</a></div></div>
<div class="ttc" id="agroup__application_html_ga6efbb9298a8f73b9a17959b56ec20267"><div class="ttname"><a href="group__application.html#ga6efbb9298a8f73b9a17959b56ec20267">printf</a></div><div class="ttdeci">void printf(Text &amp;text, const int px, const int py, const char *format,...)</div><div class="ttdoc">affiche un texte a la position x, y. meme utilisation que printf().</div><div class="ttdef"><b>Definition:</b> <a href="text_8cpp_source.html#l00140">text.cpp:140</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 9 2019 15:39:11 for gKit2 light by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
