<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gKit2 light: charger et preparer un objet wavefront .obj</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">gKit2 light
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">charger et preparer un objet wavefront .obj</div>  </div>
</div><!--header-->
<div class="contents">
<p>cf <a class="el" href="mesh__viewer_8cpp.html">mesh_viewer.cpp</a> <a class="el" href="mesh__data_8h.html">mesh_data.h</a> <a class="el" href="mesh__buffer_8h.html">mesh_buffer.h</a></p>
<h2><a class="anchor" id="autotoc_md123"></a>
lire un fichier wavefront &lt;tt&gt;.obj&lt;/tt&gt;</h2>
<p>un objet 3d est décrit par un ensemble de triangles, associes à des matières. chaque sommet est décrit par une position, et éventuellement une normale et des coordonnées de textures.</p>
<p>un ficher .obj est un fichier texte qui représente ces informations ligne par ligne, en séquence. les sommets sont décrits par une ou plusieurs lignes, en fonction des attributs présents :</p><ul>
<li><code>v x y z</code> : position,</li>
<li><code>vt u v</code> : coordonnées de texture,</li>
<li><code>vn x y z</code> : normale</li>
</ul>
<p>les attributs sont indexés séparement. les faces sont décrites par une liste de sommets, et chaque sommet est décrit par un tuple d'indices d'attributs, dans l'ordre position, texcoord, normale :</p><ul>
<li><code>f p0/t0/n0 p1/t1/n1 p2/t2/n2</code> : décrit la face / le triangle p0, p1, p2 associé aux attributs position, texcoord et normale.</li>
</ul>
<p>les attributs texcoord et normale sont optionnels (position est obligatoire), il est donc possible de représenter un sommet par :</p><ul>
<li><code>p</code> : position seule,</li>
<li><code>p/t</code> : position + texcoord,</li>
<li><code>p//n</code> : position + normale,</li>
<li><code>p/t/n</code> : position + texcoord + normale.</li>
</ul>
<p><em>remarque :</em> les indices sont numerotés à partir de 1... ou de la fin du tableau, les indices sont négatifs dans ce cas et -1 designe le dernier élément.</p>
<p>lire un fichier .obj est assez simple, il suffit de déterminer quelle donnée est décrite par chaque ligne, de l'analyser puis de stocker les données dans un ou plusieurs vecteur stl.</p>
<p>analyser la description d'une face est un petit peu plus complexe, puisqu'il est nécessaire d'analyser le tuple décrivant chaque sommet. de plus, des faces avec plus de 3 sommets sont autorisées, il faudra donc les trianguler...</p>
<p>les matières sont décrites dans un fichier séparé, extension <code>.mtl</code>, son nom est indiqué par une ligne <code>mtllib materials.mtl</code>. la matière associée à la prochaine face est indiquée par une ligne <code>usemtl nom_matiere</code>. chaque triangle est aussi associé à un indice de matière.</p>
<p>c'est <code><a class="el" href="mesh__data_8cpp.html#ac4fa72eb9002de5339a321670bb7ca22" title="charge un fichier wavefront .obj et renvoie les donnees.">read_mesh_data( )</a></code> de <a class="el" href="mesh__data_8h.html">mesh_data.h</a> qui réalise le chargement du fichier <code>.obj</code>. la fonction renvoie une structure <code><a class="el" href="mesh__data_8h.html#structMeshData">MeshData</a></code> contenant les vecteurs de données, les indices des attributs de sommets ainsi que l'indice de la matière de chaque triangle. <code><a class="el" href="mesh__data_8cpp.html#a2cd0b837e13d4e705278aee2c0ba5451" title="charge un ensemble de matieres texturees.">read_material_data( )</a></code> charge les matières décrites par le fichier <code>.mtl</code> et renvoie un ensemble de matières <code><a class="el" href="mesh__data_8h.html#structMaterialDataLib" title="ensemble de matieres texturees.">MaterialDataLib</a></code>.</p>
<p><em>rappel :</em> représentation indexée ou pas d'un maillage. il y a 2 solutions, avec openGL, pour décrire un maillage. soit un triangle est décrit par les attributs de 3 sommets, et affiché avec glDrawArrays(), soit par 3 indices de sommets et affiché par glDrawElements(). cf <a class="el" href="group__draw.html">glDraw( ) et la famille</a></p>
<p><em>remarque :</em> <code><a class="el" href="group__objet3D.html#ga9982954fa508a4c2c9a26e06e09b7352" title="charge un fichier wavefront .obj et renvoie un mesh compose de triangles non indexes....">read_mesh()</a></code> et <code><a class="el" href="group__objet3D.html#gab8c59753239105ae79a7486a6c969f2d" title="charge une description de matieres, utilise par read_mesh.">read_materials()</a></code> de <a class="el" href="wavefront_8h.html">wavefront.h</a> font la même chose, mais ne construisent que la version non indexée du maillage de l'objet, pour un affichage direct avec glDrawArrays().</p>
<h2><a class="anchor" id="autotoc_md124"></a>
glDrawElements() et indexation unique.</h2>
<p>les sommets du fichier <code>.obj</code> sont décrits par un tuple d'indices. pour afficher un objet avec openGL, il faut une indexation unique des attributs des sommets : le sommet d'indice <code>VertexID</code> correspond aux attributs <code>positions[VertexID]</code>, <code>texcoords[VertexID]</code> et <code>normals[VertexID]</code> alors que la description du fichier <code>.obj</code> est plus souple (un indice par attribut). il faut donc identifier les tuples uniques, et copier les attributs correspondants. c'est la fonction <code><a class="el" href="mesh__buffer_8cpp.html#af9c01c4285fe2a34523e5041abf7a86c" title="construction a partir des donnees d&#39;un maillage.">buffers()</a></code> de <a class="el" href="mesh__buffer_8h.html">mesh_buffer.h</a> qui transforme l'indexation, et qui permet d'utiliser glDrawElements() pour afficher le maillage indexé.</p>
<p><em>exemple : un cube</em> un cube est décrit par 8 positions. mais selon les attributs associés à ces positions, plus de 8 sommets sont nécessaires pour décrire l'objet à openGL. la position d'un coin du cube peut être associée à 3 normales différentes, ou à 3 matières différentes. pour openGL, il faut décrire 3 sommets différents. dans cet exemple, chaque sommet de chaque face est unique et il faudra décrire les 24 sommets des 6 faces du cube, soit 24 sommets et 12 triangles. alors que 8 auraient pu suffire avec une indexation plus souple.</p>
<h2><a class="anchor" id="autotoc_md125"></a>
plusieurs matières par maillage.</h2>
<p>les objets sont souvent composés de plusieurs parties chacune associée à une matière. pour dessiner efficacement ce type d'objet, il faut limiter le nombre de draw (et ne pas faire un draw par triangle en changeant les proprietes de la matière à chaque fois). une solution classique consiste à identifier les groupes de triangles associés à la même matière et à les dessiner ensemble, avec un seul appel à glDrawElements() par groupe.</p>
<p><code><a class="el" href="mesh__buffer_8cpp.html#af9c01c4285fe2a34523e5041abf7a86c" title="construction a partir des donnees d&#39;un maillage.">buffers( )</a></code> de <a class="el" href="mesh__buffer_8h.html">mesh_buffer.h</a> prépare les données de cette manière, d'abord en triant les triangles par matière puis en construisant une indexation unique des attributs des sommets. la liste des groupes de triangles est egalement construite, cf <code><a class="el" href="structMeshGroup.html" title="representation d&#39;une sequence de triangles associes a la meme matiere">MeshGroup</a></code>. ce sont les champs <a class="el" href="structMeshGroup.html#a502a1fe119f51853caad7f68111a4575" title="indice des premiers sommets">MeshGroup::first</a> et <a class="el" href="structMeshGroup.html#af7244e1c854b3508a66844b657f82841" title="nombre d&#39;indices">MeshGroup::count</a> qui permettent ensuite d'afficher la sequence de triangles en utilisant les paramètres <code>count</code> et <code>offset</code> de glDrawElements().</p>
<div class="fragment"><div class="line"><a class="code" href="structMeshBuffer.html">MeshBuffer</a> mesh;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="shader__kit_8cpp.html#a72fad2bb274e5f3b6d190bd860ea63b5">init</a>( ):</div>
<div class="line">    <span class="comment">// charger les donnees</span></div>
<div class="line">    <a class="code" href="mesh__data_8h.html#structMeshData">MeshData</a> data= <a class="code" href="mesh__data_8cpp.html#ac4fa72eb9002de5339a321670bb7ca22">read_mesh_data</a>( ... );</div>
<div class="line">    <span class="comment">// constuire les buffers indexes et les sequences de triangles triees par matiere</span></div>
<div class="line">    mesh= <a class="code" href="mesh__buffer_8cpp.html#af9c01c4285fe2a34523e5041abf7a86c">buffers</a>(data);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// creer les buffers openGL et configurer un format de sommet, un vao \ref tuto4GL</span></div>
<div class="line">    ...</div>
<div class="line">    </div>
<div class="line">draw( ):</div>
<div class="line">    glBindVertexArray( ... );</div>
<div class="line">    glUseProgram( ... );</div>
<div class="line">    glUniform( ... );</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i= 0; i &lt; mesh.groups.size(); i++)</div>
<div class="line">        <span class="comment">// afficher chaque sequence de triangles</span></div>
<div class="line">        glDrawElements(GL_TRIANGLES, <span class="comment">/* count */</span> mesh.groups[i].count, </div>
<div class="line">            <span class="comment">/* index type */</span> GL_UNSIGNED_INT, <span class="comment">/* offset */</span> (<span class="keyword">const</span> <span class="keywordtype">void</span> *) (mesh.groups[i].first * <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> int)));</div>
</div><!-- fragment --><p>exemple complet dans <code><a class="el" href="mesh__viewer_8cpp.html">mesh_viewer.cpp</a></code>, avec la creation des buffers d'attributs, du buffer d'indexation, et la configuration du format de sommet.</p>
<p><em>remarque :</em> le paramètre offset de glDrawElements() est exprimé en octets, il indique ou trouver les indices des triangles à dessiner par rapport au début de l'index buffer (cf configuration du vertex array object), la fonction MeshBuffer::index_buffer_offset( ) est également disponible.</p>
<h2><a class="anchor" id="autotoc_md126"></a>
recalculer les normales des sommets, si necessaire...</h2>
<p>cf <a class="el" href="mesh__data_8cpp.html#ab643d7c9eebe383b78549110b02cb6a7" title="(re-) calcule les normales des sommets. utiliser avant les reindexations, cf indices() et vertices().">normals()</a> de <a class="el" href="mesh__data_8h.html">mesh_data.h</a></p>
<p>pas mal de fichiers <code>.obj</code> ne décrivent pas les normales des sommets, cette information est pourtant essentielle aux calculs d'éclairage pour afficher l'objet. il est possible d'utiliser blender par exemple, pour calculer les normales et de re-exporter le fichier. mais il est assez simple de les calculer lorsqu'elles ne sont pas présentes.</p>
<p>connaissant 2 aretes d'un triangle, un produit vectoriel permet d'obtenir un vecteur orthogonal aux aretes, ce qui est nous donne la normale géométrique du triangle. pour calculer la normale aux sommets du maillage, il faut trouver les triangles adjacents à chaque sommet, et calculer la moyenne de leurs normales. ce qui est assez pénible à faire sur un ensemble de triangles non indexé.</p>
<p>une solution simple existe lorsque le maillage est indexé. dans ce cas, chaque triangle connait l'indice de la position de chacun de ses sommets et il suffit de créer une normale par position, de parcourir les triangles et d'accumuler la normale géométrique sur les sommets du triangle. A la fin du parcours, la normale associée à chaque position est la somme des normales des triangles adjacents, il ne reste plus qu'à la normaliser. la fonction <code><a class="el" href="mesh__data_8cpp.html#ab643d7c9eebe383b78549110b02cb6a7" title="(re-) calcule les normales des sommets. utiliser avant les reindexations, cf indices() et vertices().">normals( )</a></code> de <a class="el" href="mesh__data_8h.html">mesh_data.h</a> réalise ce calcul, pour les maillages indexés.</p>
<p>exemple d'utilisation : </p><div class="fragment"><div class="line"><span class="comment">// lire les donnees</span></div>
<div class="line"><a class="code" href="mesh__data_8h.html#structMeshData">MeshData</a> data= <a class="code" href="mesh__data_8cpp.html#ac4fa72eb9002de5339a321670bb7ca22">read_mesh_data</a>( ... );</div>
<div class="line"><span class="keywordflow">if</span>(data.normals.size() == 0)</div>
<div class="line">    <span class="comment">// calculer les normales, si necessaire</span></div>
<div class="line">    <a class="code" href="mesh__data_8cpp.html#ab643d7c9eebe383b78549110b02cb6a7">normals</a>(data);</div>
<div class="line">...</div>
<div class="line"><span class="comment">// preparer les buffers pour l&#39;affichage</span></div>
<div class="line">MeshBuffer mesh= <a class="code" href="mesh__buffer_8cpp.html#af9c01c4285fe2a34523e5041abf7a86c">buffers</a>(data);</div>
<div class="line">...</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md127"></a>
afficher toutes les matieres avec un seul draw ?</h2>
<p>trier et afficher par matière est une solution interressante, mais elle n'exploite pas completement le pipeline programmable d'openGL. une autre solution permet de dessiner tous les triangles avec un seul draw.</p>
<p><b>comment ?</b></p>
<p>l'idee est de récupérer la description de la matière de chaque triangle lors de sa fragmentation. on pourrait stocker une copie de la matiere par triangle, mais cette solution utilise trop de mémoire. une solution plus interressante utilise 2 tableaux : un pour stocker les matieres et un autre qui stocke, pour chaque triangle, l'indice de la matière associée.</p>
<p>on peut déclarer des tableaux d'uniforms dans le fragment shader : </p><div class="fragment"><div class="line">uniform <a class="code" href="structvec4.html">vec4</a> colors[M];</div>
<div class="line">uniform <span class="keywordtype">int</span> color_indices[T];</div>
<div class="line"> </div>
<div class="line">out <a class="code" href="structvec4.html">vec4</a> fragment_color;</div>
<div class="line"><span class="keywordtype">void</span> main( )</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> color_index= color_indices[gl_PrimitiveID];</div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a> color= colors[color_index];</div>
<div class="line">    </div>
<div class="line">    fragment_color= color;</div>
<div class="line">}</div>
</div><!-- fragment --><p><em>rappel :</em> <code>gl_PrimitiveID</code> permet au fragment shader de connaitre la primitive en cours de dessin, <code>gl_VertexID</code> permet au vertex shader de connaitre le sommet à transformer.</p>
<p>cette solution n'est pas directement exploitable, il faut définir les valeurs de M et T pour compiler le shader. et autre détail, les uniforms ne permettent pas de stocker beaucoup de valeurs, seulement 64KB sont utilisables.</p>
<p>mais il est possible d'associer un buffer à un tableau d'uniforms ou d'utiliser directement les shader storage buffers, cf <a class="el" href="group__storage.html">openGL 4.3 : storage buffers</a>. la déclaration d'un uniform associé à un buffer ressemble à une déclaration de struture, appellé un uniform block dans GLSL : </p><div class="fragment"><div class="line">uniform MaterialBlock</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a> colors[];</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">uniform IndexBlock</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> color_indices[];</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">out <a class="code" href="structvec4.html">vec4</a> fragment_color;</div>
<div class="line"><span class="keywordtype">void</span> main( )</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> color_index= color_indices[gl_PrimitiveID];</div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a> color= colors[color_index];</div>
<div class="line">    </div>
<div class="line">    fragment_color= color;</div>
<div class="line">}</div>
</div><!-- fragment --><p>le nom du block permet à l'application d'associer l'uniform à un buffer. et comme plusieurs buffers peuvent être utilisés simultanément par un shader, ils sont numérotés, et c'est l'application qui choisit le numero : </p><div class="fragment"><div class="line"><span class="comment">// creer et remplir le buffer avec les parametres des matieres.</span></div>
<div class="line">GLuint material_buffer= .... ;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// recuperer l&#39;identifiant du block a associer au buffer</span></div>
<div class="line">GLuint material_block= glGetUniformBlockIndex(program, <span class="stringliteral">&quot;MaterialBlock&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// les uniform blocks sont numerotes, et c&#39;est l&#39;application qui doit choisir le numero...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// associe le numero 0 au bloc &quot;MaterialBLock&quot;</span></div>
<div class="line">glUniformBlockBinding(program, material_block, 0);      </div>
<div class="line"><span class="comment">// associe le contenu d&#39;un buffer au block numero 0</span></div>
<div class="line">glBindBufferBase(GL_UNIFORM_BUFFER, 0, material_buffer);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// on recommence pour les indices, avec un autre numero</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// creer et remplir le buffer contenant l&#39;indice de la matiere de chaque triangle</span></div>
<div class="line">GLuint material_index_buffer= ... ;</div>
<div class="line">GLuint index_block= glGetUniformBlockIndex(program, <span class="stringliteral">&quot;IndexBlock&quot;</span>);</div>
<div class="line">glUniformBlockBinding(program, index_block, 1);</div>
<div class="line">glBindBufferBase(GL_UNIFORM_BUFFER, 1, material_index_buffer);</div>
</div><!-- fragment --><p>et voila, il ne reste qu'à dessiner l'objet avec un seul draw, et le fragment shader peut récupérer directement la description de la matière de chaque triangle.</p>
<h2><a class="anchor" id="autotoc_md128"></a>
autre chose ?</h2>
<p>il y a une autre solution, sans doute, plus simple à utiliser, il suffit d'associer un attribut (entier) supplémentaire aux sommets : l'indice de la matière. mais il faut que les sommets soient dupliqués lorsqu'ils sont sur une arete associée à 2 matières, cette opération est réalisée par <a class="el" href="mesh__buffer_8cpp.html#af9c01c4285fe2a34523e5041abf7a86c" title="construction a partir des donnees d&#39;un maillage.">buffers()</a> de <a class="el" href="mesh__buffer_8h.html">mesh_buffer.h</a>. par contre, il n'est pas possible d'interpoler un attribut entier dans un fragment shader, il faut le déclarer explicitement non interpolable avec le mot clé <code>flat</code> :</p>
<div class="fragment"><div class="line"><span class="comment">// vertex shader</span></div>
<div class="line">in <a class="code" href="structvec3.html">vec3</a> position;</div>
<div class="line">in <span class="keywordtype">int</span> material_index;</div>
<div class="line"> </div>
<div class="line">uniform mat4 mvpMatrix;</div>
<div class="line"> </div>
<div class="line">flat out <span class="keywordtype">int</span> vertex_material_index;      <span class="comment">// !! decoration flat !!</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main( )</div>
<div class="line">{</div>
<div class="line">    gl_Position= mvpMatrx * <a class="code" href="structvec4.html">vec4</a>(position, 1);</div>
<div class="line">    vertex_material_index= material_index;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// fragment shader</span></div>
<div class="line">flat in <span class="keywordtype">int</span> vertex_material_index;      <span class="comment">// !! decoration flat !!</span></div>
<div class="line"> </div>
<div class="line">uniform <a class="code" href="structvec4.html">vec4</a> colors[M];</div>
<div class="line"> </div>
<div class="line">out <a class="code" href="structvec4.html">vec4</a> fragment_color;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main( )</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a> color= colors[vertex_material_index];</div>
<div class="line">    </div>
<div class="line">    fragment_color= color;</div>
<div class="line">}</div>
</div><!-- fragment --><p>cette solution à toujours l'inconvénient de devoir compiler un shader par objet en fonction du nombre de matieres nécéssaire à son affichage... il suffit d'utiliser un tableau assez gros, mais de ne pas l'utiliser entièrement...</p>
<p>l'autre inconvénient est que l'indice de la matière du triangle est stocké 3 fois, une fois par sommet... la plupart des scenes utilisent un nombre raisonnable de matières, il est tout à fait possible de n'utiliser qu'un UNSIGNED_BYTE au lieu d'un UNSIGNED_INT et de limiter le nombre de matières à 255, ce qui permet de réduire l'occuppation mémoire.</p>
<p><em>remarque :</em> utiliser glVertexAttribIPointer() pour configurer un attribut entier.</p>
<h2><a class="anchor" id="autotoc_md129"></a>
et avec des textures ?</h2>
<p>il relativement simple de construire un tableau de matière et de l'indexer dans le fragment shader, mais cette solution n'est pas très interressante pour les textures, avec openGL 3</p>
<div class="fragment"><div class="line"><span class="comment">// fragment shader</span></div>
<div class="line">flat in <span class="keywordtype">int</span> vertex_material_index;      <span class="comment">// !! decoration flat !!</span></div>
<div class="line"> </div>
<div class="line">uniform <a class="code" href="structvec4.html">vec4</a> colors[M];</div>
<div class="line">uniform sampler2D diffuse_textures[M];</div>
<div class="line"> </div>
<div class="line">out <a class="code" href="structvec4.html">vec4</a> fragment_color;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main( )</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a> color= colors[vertex_material_index];</div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a> texture_color= texture(diffuse_textures[vertex_material_index], texcoords);</div>
<div class="line">    </div>
<div class="line">    fragment_color= color * texture_color;</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>pourquoi ?</b> les samplers qui permettent d'accéder au contenu de la texture dans un shader sont des types opaques, et l'application configure une unité de texture, et transmet l'indice de l'unite au shader. et comme on ne peut utiliser que 16 ou 32 unites simultanement... ce n'est pas une très bonne solution. mais on peut faire mieux avec les <em>bindless textures</em> introduites par l'extension <a href="https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_bindless_texture.txt">ARB_bindless_textures</a> qui elimine les unites de textures.</p>
<p>la solution de base fonctionne toujours, il suffit d'afficher les triangles tries par matiere et de selectionner les textures avant de dessiner. on peut limiter le nombre de changements de textures en triant aussi les matieres par textures.</p>
<p>la solution classique demande de réorganiser les textures : il est possible de créer des tableaux de textures et chaque tableau est sélectionné sur seule unité de texture. comme on peut créer des tableaux d'au moins 2048 textures, cette solution règle correctement le problème. par contre, il faut trier les textures par dimensions et par type de texel pour trouver celles que l'on peut grouper dans le même tableau et indiquer au shader comment accéder à la texture : quelle unité de texture et quelle texture du tableau, en plus des coordonnées classiques.</p>
<p>les tableaux de texture se manipulent sur GL_TEXTURE_2D_ARRAY et sont initialisés par glTexImage3D(GL_TEXTURE_2D_ARRRAY, ...).</p>
<p><a class="el" href="material__data_8cpp.html#a4a34af1cd84fe9a6317a9d8b506a64e0" title="charge les textures associees a un ensemble de matieres, sans depasser une limite de taille,...">read_textures()</a> de <a class="el" href="material__data_8h.html">material_data.h</a> permet d'utiliser la solution de base, dessiner une matière à la fois. la fonction charge les images, trouve une dimension max permettant de ne pas dépasser une limite de taille (1Go par défaut), redimensionne les images et enfin crée les textures. cf <a class="el" href="mesh__viewer_8cpp.html">mesh_viewer.cpp</a> <a class="el" href="material__data_8cpp.html">material_data.cpp</a> pour le code complet.</p>
<p>si vous ne souhaitez pas manipuler les textures, dans un premier temps, <a class="el" href="material__data_8cpp.html#a4a34af1cd84fe9a6317a9d8b506a64e0" title="charge les textures associees a un ensemble de matieres, sans depasser une limite de taille,...">read_textures()</a> calcule aussi la couleur moyenne des images, ce qui permet quand meme d'afficher une approximation de la scène. cf <a class="el" href="mesh__viewer_8cpp.html">mesh_viewer.cpp</a></p>
<div class="image">
<img src="sponza_texture.png" alt=""/>
</div>
<p> (avec les textures)</p>
<div class="image">
<img src="sponza_average.png" alt=""/>
</div>
<p> (avec les couleurs moyennes des textures) </p>
</div><!-- contents -->
<div class="ttc" id="amesh__buffer_8cpp_html_af9c01c4285fe2a34523e5041abf7a86c"><div class="ttname"><a href="mesh__buffer_8cpp.html#af9c01c4285fe2a34523e5041abf7a86c">buffers</a></div><div class="ttdeci">MeshBuffer buffers(const MeshData &amp;data)</div><div class="ttdoc">construction a partir des donnees d'un maillage.</div><div class="ttdef"><b>Definition:</b> <a href="mesh__buffer_8cpp_source.html#l00048">mesh_buffer.cpp:48</a></div></div>
<div class="ttc" id="amesh__data_8cpp_html_ac4fa72eb9002de5339a321670bb7ca22"><div class="ttname"><a href="mesh__data_8cpp.html#ac4fa72eb9002de5339a321670bb7ca22">read_mesh_data</a></div><div class="ttdeci">MeshData read_mesh_data(const char *filename)</div><div class="ttdoc">charge un fichier wavefront .obj et renvoie les donnees.</div><div class="ttdef"><b>Definition:</b> <a href="mesh__data_8cpp_source.html#l00041">mesh_data.cpp:41</a></div></div>
<div class="ttc" id="ashader__kit_8cpp_html_a72fad2bb274e5f3b6d190bd860ea63b5"><div class="ttname"><a href="shader__kit_8cpp.html#a72fad2bb274e5f3b6d190bd860ea63b5">init</a></div><div class="ttdeci">int init(std::vector&lt; const char * &gt; &amp;options)</div><div class="ttdef"><b>Definition:</b> <a href="shader__kit_8cpp_source.html#l00094">shader_kit.cpp:94</a></div></div>
<div class="ttc" id="amesh__data_8cpp_html_ab643d7c9eebe383b78549110b02cb6a7"><div class="ttname"><a href="mesh__data_8cpp.html#ab643d7c9eebe383b78549110b02cb6a7">normals</a></div><div class="ttdeci">void normals(MeshData &amp;data)</div><div class="ttdoc">(re-) calcule les normales des sommets. utiliser avant les reindexations, cf indices() et vertices().</div><div class="ttdef"><b>Definition:</b> <a href="mesh__data_8cpp_source.html#l00332">mesh_data.cpp:332</a></div></div>
<div class="ttc" id="astructvec3_html"><div class="ttname"><a href="structvec3.html">vec3</a></div><div class="ttdoc">vecteur generique, utilitaire.</div><div class="ttdef"><b>Definition:</b> <a href="vec_8h_source.html#l00144">vec.h:144</a></div></div>
<div class="ttc" id="amesh__data_8h_html_structMeshData"><div class="ttname"><a href="mesh__data_8h.html#structMeshData">MeshData</a></div><div class="ttdef"><b>Definition:</b> <a href="mesh__data_8h_source.html#l00046">mesh_data.h:46</a></div></div>
<div class="ttc" id="astructvec4_html"><div class="ttname"><a href="structvec4.html">vec4</a></div><div class="ttdoc">vecteur generique 4d, ou 3d homogene, utilitaire.</div><div class="ttdef"><b>Definition:</b> <a href="vec_8h_source.html#l00166">vec.h:166</a></div></div>
<div class="ttc" id="astructMeshBuffer_html"><div class="ttname"><a href="structMeshBuffer.html">MeshBuffer</a></div><div class="ttdoc">representation d'un objet.</div><div class="ttdef"><b>Definition:</b> <a href="mesh__buffer_8h_source.html#l00021">mesh_buffer.h:21</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 9 2019 15:39:11 for gKit2 light by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
