<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gKit2 light: glDraw( ) et la famille</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">gKit2 light
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">glDraw( ) et la famille</div>  </div>
</div><!--header-->
<div class="contents">
<p>cf <a class="el" href="tuto6GL_8cpp.html">tuto6GL.cpp</a></p>
<p>glDraw( ) est une famille de fonctions, et selon la description du maillage (sommets partagés, ou pas) il faut utiliser :</p><ul>
<li>glDrawElements( ) : lorsque le maillage est décrit par des sommets partagés / indexés, les triangles sont décrits par des triplets d'indices,</li>
<li>glDrawArrays( ) : lorsque le maillage est décrit uniquement par les coordonnées de ses sommets, les triangles sont décrits par des triplets de positions.</li>
</ul>
<p>la classe <a class="el" href="classMesh.html" title="representation d&#39;un objet / maillage.">Mesh</a> peut stocker les 2 types de maillages : il suffit de vérifier qu'un index buffer existe (cf <a class="el" href="classMesh.html#affd5950a84d6985109099f3eee2d729c" title="renvoie le nombre d&#39;indices de sommets.">Mesh::index_count()</a> &gt; 0 ou <a class="el" href="classMesh.html#a6b225c39aa3ef76dc6224565d32f0a61" title="renvoie la taille (en octets) de l&#39;index buffer.">Mesh::index_buffer_size()</a> &gt; 0) pour savoir qu'il faut utiliser glDrawElements( ) plutot que glDrawArrays( ). cf <a class="el" href="group__tuto4GL.html">configurer un format de sommet, vertex array object</a> pour des exemples.</p>
<p><em>remarque : quel est l'intêret d'utiliser des sommets partagés ?</em></p>
<p>la description de l'objet est plus compacte... un indice est un entier stocké sur 4, 2 ou 1 octets, un sommet est a priori 3 floats qui occuppent 4 octets chacuns, soit 12 octets au total. si l'on ajoute les normales (3 floats) et les coordonnées de textures (2 floats), un sommet occuppe 3x4 + 3x4 + 2x4 = 32 octets.</p>
<p>un simple cube composé de 8 sommets (soit 8x32 = 256 octets) et de 12 triangles indexés (12x3x4 = 144 octets) occuppe 400 octets. sans utiliser l'indexation, il faut décrire les 3 sommets des 12 triangles : 12x3x32 = 1152 octets... et autre amélioration, les vertex shaders ne transforment que 8 sommets dans un cas, contre 36 dans l'autre...</p>
<h3><a class="anchor" id="autotoc_md87"></a>
glDrawArrays et Mesh</h3>
<p>s'il n'existe pas d'index buffer dans l'objet, il suffit de créer un vertex buffer et de configurer un vao : </p><div class="fragment"><div class="line"><a class="code" href="classMesh.html">Mesh</a> mesh = { ... };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// configuration</span></div>
<div class="line">GLuint vao= 0;</div>
<div class="line">GLuint vertex_buffer= 0;</div>
<div class="line"> </div>
<div class="line">glGenVertexArrays(1, &amp;vao);</div>
<div class="line">glBindVertexArray(vao);</div>
<div class="line"> </div>
<div class="line">glGenBuffers(1, &amp;vertex_buffer);</div>
<div class="line">glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer);</div>
<div class="line">glBufferData(GL_ARRAY_BUFFER, mesh.<a class="code" href="classMesh.html#a916a1089ab91b425b159e0b34a3ed780">vertex_buffer_size</a>(), mesh.<a class="code" href="classMesh.html#a3387f3c281e83b20adcc083e086a6b53">vertex_buffer</a>(), GL_STATIC_DRAW);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// configure l&#39;attribut 0, cf layout(location= 0) in vec3 position, dans le vertex shader</span></div>
<div class="line">glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);</div>
<div class="line">glEnableVertexAttrib(0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// nettoyage</span></div>
<div class="line">glBindVertexArray(0);   <span class="comment">// !! pourquoi en premier ? !!</span></div>
<div class="line">glBindBuffer(GL_ARRAY_BUFFER, 0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// draw</span></div>
<div class="line">glBindVertexArray(vao);</div>
<div class="line">glUseProgram( ... );</div>
<div class="line">glUniform( ... );</div>
<div class="line"> </div>
<div class="line">glDrawArrays(GL_TRIANGLES, <span class="comment">/* first */</span> 0, <span class="comment">/* count */</span> mesh.<a class="code" href="classMesh.html#ab030b9ea443989d5966ea0be3e5e20a1">vertex_count</a>());</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md88"></a>
glDrawElements et Mesh</h3>
<p>la démarche est la même, il faut créer l'index buffer, en plus du vertex buffer et bien sur configurer le vao : </p><div class="fragment"><div class="line"><a class="code" href="classMesh.html">Mesh</a> mesh = { ... };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// configuration</span></div>
<div class="line">GLuint vao= 0;</div>
<div class="line">GLuint vertex_buffer= 0;</div>
<div class="line">GLuint index_buffer= 0;</div>
<div class="line"> </div>
<div class="line">glGenVertexArrays(1, &amp;vao);</div>
<div class="line">glBindVertexArray(vao);</div>
<div class="line"> </div>
<div class="line">glGenBuffers(1, &amp;vertex_buffer);</div>
<div class="line">glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer);</div>
<div class="line">glBufferData(GL_ARRAY_BUFFER, mesh.<a class="code" href="classMesh.html#a916a1089ab91b425b159e0b34a3ed780">vertex_buffer_size</a>(), mesh.<a class="code" href="classMesh.html#a3387f3c281e83b20adcc083e086a6b53">vertex_buffer</a>(), GL_STATIC_DRAW);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// configure l&#39;attribut 0, cf layout(location= 0) in vec3 position, dans le vertex shader</span></div>
<div class="line">glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);</div>
<div class="line">glEnableVertexAttrib(0);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(mesh.<a class="code" href="classMesh.html#affd5950a84d6985109099f3eee2d729c">index_count</a>() &gt; 0)</div>
<div class="line">{</div>
<div class="line">    glGenBuffers(1, &amp;index_buffer);</div>
<div class="line">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, index_buffer);</div>
<div class="line">    glBufferData(GL_ELEMENT_ARRAY_BUFFER, mesh.<a class="code" href="classMesh.html#a6b225c39aa3ef76dc6224565d32f0a61">index_buffer_size</a>(), mesh.<a class="code" href="classMesh.html#a9f73e9638f40415900bcfb4eb06d01f7">index_buffer</a>(), GL_STATIC_DRAW);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// !! la configuration du vao est implicite au moment du BindBuffer(GL_ELEMENT_ARRAY_BUFFER) !!</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// nettoyage</span></div>
<div class="line">glBindVertexArray(0);   <span class="comment">// !! pourquoi en premier ? !!</span></div>
<div class="line">glBindBuffer(GL_ARRAY_BUFFER, 0);</div>
<div class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// draw</span></div>
<div class="line">glBindVertexArray(vao);</div>
<div class="line">glUseProgram( ... );</div>
<div class="line">glUniform( ... );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// choisir le draw</span></div>
<div class="line"><span class="keywordflow">if</span>(mesh.<a class="code" href="classMesh.html#affd5950a84d6985109099f3eee2d729c">index_count</a>() == 0)</div>
<div class="line">    <span class="comment">// pas d&#39;index buffer</span></div>
<div class="line">    glDrawArrays(GL_TRIANGLES, <span class="comment">/* first */</span> 0, <span class="comment">/* count */</span> mesh.<a class="code" href="classMesh.html#ab030b9ea443989d5966ea0be3e5e20a1">vertex_count</a>());</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">    <span class="comment">// avec un index buffer</span></div>
<div class="line">    glDrawElements(GL_TRIANGLES, <span class="comment">/* count */</span> mesh.<a class="code" href="classMesh.html#affd5950a84d6985109099f3eee2d729c">index_count</a>(), <span class="comment">/* index type */</span> GL_UNSIGNED_INT, <span class="comment">/* offset */</span> 0);</div>
</div><!-- fragment --><p>les paramètres type et offset permettent d'itérer sur les indices stockés dans l'index buffer associé au vao.</p>
<p><b>remarque :</b> <a class="el" href="group__objet3D.html#ga9982954fa508a4c2c9a26e06e09b7352" title="charge un fichier wavefront .obj et renvoie un mesh compose de triangles non indexes....">read_mesh( )</a> ne construit pas, pour l'instant, d'index buffer, donc un objet chargé par <a class="el" href="group__objet3D.html#ga9982954fa508a4c2c9a26e06e09b7352" title="charge un fichier wavefront .obj et renvoie un mesh compose de triangles non indexes....">read_mesh( )</a> peut etre affiché directement par glDrawArrays().</p>
<p>en consultant la doc d'openGL, d'autres fonctions existent, à quoi servent-elles ?</p><ul>
<li>glDrawArraysInstanced( ), glDrawElementsInstanced( ) : permettent de dessiner plusieurs copies du même objet,</li>
<li>glDrawElementsBaseVertex( ) : permet de dessiner facilement un objet indexé, lorsque les attributs de ces sommets ne sont pas au début du vertex buffer...</li>
</ul>
<h2><a class="anchor" id="autotoc_md89"></a>
draw instanced, dessiner plusieurs copies</h2>
<p>dans pas mal de cas, il est nécessaire d'afficher plusieurs fois le même objet ou des variantes du même objet. par exemple, des unités dans un jeu de stratégie, des arbres pour afficher une forêt, des touffes d'herbes pour une prairie, des <em>cubes</em>, etc.</p>
<p>malheureusement, la solution directe, faire un draw par copie n'est <b>vraiment pas</b> une solution efficace. cf <a class="el" href="tuto__time_8cpp.html">tuto_time.cpp</a> et (les explications <a class="el" href="group__time.html">mesure du temps cpu et gpu</a>) pour une démonstration.</p>
<p>glDrawArraysInstanced( ) / glDrawElementsInstanced() fournissent une solution (partielle) à ce problème. les fonctions prennent un paramètre supplémentaire (par rappport à glDrawArrays() / glDrawElements()), le nombre de copies à dessiner.</p>
<p>parfait, reste un petit problème à régler... toutes les copies sont identiques et sont dessinées au même endroit, ce qui ne sert à rien. il faut pouvoir, au minimum, les placer à des endroits différents dans la scène / le monde.</p>
<p>il y a 2 deux moyens : on peut stocker les propriétés de chaque copie dans un buffer et modifier le vertex array object en fonction, et/ou utiliser l'indice de la copie en cours de traitement (cf int gl_InstanceID) dans le vertex shader pour calculer des propriétés uniques à chaque instance.</p>
<p>exemple : dessiner n copies alignées avec gl_InstanceID : il suffit de modifier le vertex shader pour calculer une position qui dépend de gl_InstanceID </p><div class="fragment"><div class="line"><span class="comment">// vertex shader</span></div>
<div class="line">in <a class="code" href="structvec3.html">vec3</a> position;</div>
<div class="line"> </div>
<div class="line">uniform mat4 mvpMatrix;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main( )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// int gl_InstanceID varie de 0 a N, le nombre d&#39;instances dessinees</span></div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> p= position + <a class="code" href="structvec3.html">vec3</a>(gl_InstanceID * 10, 0, 0);</div>
<div class="line">    gl_Position= mvpMatrix * <a class="code" href="structvec3.html">vec3</a>(p, 1);</div>
<div class="line">}</div>
</div><!-- fragment --><p>et dans l'application : </p><div class="fragment"><div class="line">glBindVertexArray( ... );</div>
<div class="line">glUseProgram( ... );</div>
<div class="line">glUniform( ... );</div>
<div class="line"> </div>
<div class="line">glDrawArraysInstanced(GL_TRIANGLES, <span class="comment">/* first */</span> 0, <span class="comment">/* count */</span> 36, <span class="comment">/* instance count */</span> 10); <span class="comment">// dessine N= 10 copies</span></div>
</div><!-- fragment --><p> permet de dessiner 10 cubes, par exemple. exemple complet dans <a class="el" href="tuto6GL_8cpp.html">tuto6GL.cpp</a> et <a class="el" href="instanceID_8glsl_source.html">instanceID.glsl</a>. <a class="el" href="tuto__time_8cpp.html">tuto_time.cpp</a> utilise aussi cette solution pour dessiner des objets disposés sur une grille.</p>
<p>l'autre solution nécessite de créer un buffer pour stocker les paramètres de chaque instance et de configurer le format de sommet avec glVertexAttribDivisor(index, 1). le vertex shader doit également déclarer et utiliser l'attribut supplémentaire cf <a class="el" href="instance__buffer_8glsl_source.html">instance_buffer.glsl</a> : </p><div class="fragment"><div class="line">in <a class="code" href="structvec3.html">vec3</a> position;               <span class="comment">// attribut du sommet</span></div>
<div class="line">in <a class="code" href="structvec3.html">vec3</a> instance_position;      <span class="comment">// l&#39;attribut d&#39;instance se declare &quot;normalement&quot;, </span></div>
<div class="line"><span class="comment">// c&#39;est l&#39;application qui doit correctement configurer le vao...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main( )</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> p= position + instance_position;</div>
<div class="line">    gl_Position= mvpMatrix * <a class="code" href="structvec4.html">vec4</a>(p, 1);</div>
<div class="line">    </div>
<div class="line">    vertex_normal= mat3(normalMatrix) * normal;</div>
<div class="line">}</div>
</div><!-- fragment --><p>et voici comment <a class="el" href="tuto6GL__buffer_8cpp.html">tuto6GL_buffer.cpp</a> configure le vao, pour l'attribut d'instance : </p><div class="fragment"><div class="line">std::vector&lt;vec3&gt; positions;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// remplir les positions</span></div>
<div class="line">{ ... }</div>
<div class="line"> </div>
<div class="line"><span class="comment">// creer le buffer</span></div>
<div class="line">glGenBuffers(1, &amp;m_instance_buffer);</div>
<div class="line">glBindBuffer(GL_ARRAY_BUFFER, m_instance_buffer);</div>
<div class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(<a class="code" href="structvec3.html">vec3</a>) * positions.size(), &amp;positions.front().x, GL_STATIC_DRAW);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// configure l&#39;attribut,  vec3 instance_position</span></div>
<div class="line">GLint index= glGetAttribLocation(program, <span class="stringliteral">&quot;instance_position&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// configure le vao pour l&#39;attribut d&#39;instance</span></div>
<div class="line">glVertexAttribPointer(index, 3, GL_FLOAT, GL_FALSE, <span class="comment">/* stride */</span> 0, <span class="comment">/* offset */</span> 0);</div>
<div class="line">glEnableVertexAttribArray(index);</div>
<div class="line"> </div>
<div class="line">glVertexAttribDivisor(index, 1);    <span class="comment">// !! c&#39;est la seule difference entre un attribut de sommet et un attribut d&#39;instance !!</span></div>
</div><!-- fragment --><p><b>remarque :</b> pourquoi divisor pour nommer une propriete d'instance ? euh, c'est pareil dans directx ? l'idée est de décrire à quel moment l'attribut change de valeur, pour chaque sommet (divisor == 0), ou pour chaque instance (divisor == 1), toutes les 2 instances (divisor == 2), etc.</p>
<p><b>remarque :</b> oui, ça permet d'avoir des propriétés d'instances qui sont définies pour un groupe d'instances, mais ce n'est pas très flexible...</p>
<h2><a class="anchor" id="autotoc_md90"></a>
draw base vertex, organisation des données</h2>
<p>si les données de plusieurs objets sont rangées dans le même vertex buffer, ca permet de ne configurer et de n'utiliser qu'un seul vao, ce qui peut simplifier le code d'affichage de plusieurs objets et permet aussi au driver de faire moins de travail.</p>
<p>si les sommets des objets A et B se trouvent dans le même buffer :</p>
<p><code>AAAAAA + BBB</code></p>
<p>on peut les afficher en utilisant le paramètre first de glDrawArrays( ): </p><div class="fragment"><div class="line">GLuint vao= { ... };</div>
<div class="line">glBindVertexArray(vao);</div>
<div class="line">glUseProgram( ... );</div>
<div class="line">glUniform( ... );</div>
<div class="line"> </div>
<div class="line">glDrawArrays(GL_TRIANGLES, <span class="comment">/* first */</span> 0, <span class="comment">/* count */</span> 6);       <span class="comment">// dessine A</span></div>
<div class="line">glDrawArrays(GL_TRIANGLES, <span class="comment">/* first */</span> 6, <span class="comment">/* count */</span> 3);       <span class="comment">// dessine B</span></div>
</div><!-- fragment --><p>et il aussi possible de dessiner les 2 objets avec un seul draw : </p><div class="fragment"><div class="line">GLuint vao= { ... };</div>
<div class="line">glBindVertexArray(vao);</div>
<div class="line">glUseProgram( ... );</div>
<div class="line">glUniform( ... );</div>
<div class="line"> </div>
<div class="line">glDrawArrays(GL_TRIANGLES, <span class="comment">/* first */</span> 0, <span class="comment">/* count */</span> 9);       <span class="comment">// dessine A et B</span></div>
</div><!-- fragment --><p><b>remarque :</b> si les objets ne sont pas placés les uns après les autres dans le vertex buffer, il faudra utiliser un draw par intervalle d'objets, ou utiliser glMultiDrawArrays()...</p>
<p>si les sommets des objets A, B, et C se trouvent dans le même buffer :</p>
<p><code>AAAAAA + BBB + CCC</code></p>
<p>et que l'on veut afficher A et C, il faudra utiliser 2 DrawArrays() ou préparer les paramètres de MultiDrawArrays( ) : </p><div class="fragment"><div class="line">std::vector&lt;GLint&gt; first;</div>
<div class="line">std::vector&lt;GLSizei&gt; count;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// draw A</span></div>
<div class="line">first.push_back(0);</div>
<div class="line">count.push_back(6);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// draw C</span></div>
<div class="line">first.push_back(9);</div>
<div class="line">count.push_back(3);</div>
<div class="line"> </div>
<div class="line">glMultiDrawArrays(GL_TRIANGLES, <span class="comment">/* first */</span> &amp;first.front(), <span class="comment">/* count */</span> &amp;count.front(), <span class="comment">/* draw count */</span> first.size());</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md91"></a>
et avec glDrawElements( ) ?</h3>
<p>La solution précédente est simple à utiliser tant que l'affichage des objets peut se faire avec glDrawArrays(), si les objets utilisent un index buffer / des sommets partagés, glDrawElements( ) ne permet pas directement de faire la même chose... <em>pourquoi ?</em></p>
<p>si les sommets des objets A et B se trouvent dans le même buffer :</p>
<p><code>AAAA + BBB</code></p>
<p>et que leur indexation est : <code>012023</code> pour le quad A et <code>012</code> pour le triangle B, et qu'ils sont dans le même index buffer :</p>
<p><code>012023 + 012</code></p>
<p>que va dessiner : </p><div class="fragment"><div class="line"><span class="comment">// dessiner un triangle indexé à partir du 6ième indice du buffer</span></div>
<div class="line">glDrawElements(GL_TRIANGLES, <span class="comment">/* count */</span> 3, <span class="comment">/* index type */</span> GL_UNSIGNED_INT, <span class="comment">/* offset */</span> <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) * 6); </div>
</div><!-- fragment --><ul>
<li>réponse A : le triangle A0A1A2,</li>
<li>réponse B : le triangle B0B1B2 ?</li>
</ul>
<p><em>indication :</em> quel est l'indice du sommet 0 de l'objet B rangé dans le vertex buffer ? habituellement c'est 0 ? non ??</p>
<p><em>réponse :</em> ça dépend du nombre de sommets du premier objet rangé dans le buffer...</p>
<p>et c'est très exactement cette valeur qui sert de paramètre base_vertex à glDrawElementBaseVertex( ) : </p><div class="fragment"><div class="line"><span class="comment">// dessiner un triangle indexé à partir du 6ième indice du buffer</span></div>
<div class="line">glDrawElementsBaseVertex(GL_TRIANGLES, <span class="comment">/* count */</span> 3, <span class="comment">/* index type */</span> GL_UNSIGNED_INT, <span class="comment">/* offset */</span> <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) * 6, <span class="comment">/* base vertex */</span> 4); </div>
<div class="line"><span class="comment">// dont les sommets se trouvent a partir du 4ieme sommet dans le vertex buffer...</span></div>
</div><!-- fragment --><p><b>bonus :</b> il y a une autre solution, qui utilise toujours glDrawElements() mais qui demande un peu plus de préparation... que se passe-t-il si l'index buffer contient :</p>
<p><code>012023 + 456</code></p>
<h2><a class="anchor" id="autotoc_md92"></a>
et les autres ?</h2>
<p>les glDrawInstancedBaseInstance( ) permettent de faire la même chose avec les buffers d'attributs d'instances.</p>
<p>l'autre draw interressant et plus souple que draw instanced s'appelle glMultiDraw( ) et surtout glMultiDrawIndirect( ), mais il n'est utilisable qu'à partir d'openGL 4.3.</p>
<p>todo </p>
</div><!-- contents -->
<div class="ttc" id="aclassMesh_html_a9f73e9638f40415900bcfb4eb06d01f7"><div class="ttname"><a href="classMesh.html#a9f73e9638f40415900bcfb4eb06d01f7">Mesh::index_buffer</a></div><div class="ttdeci">const void * index_buffer() const</div><div class="ttdoc">renvoie l'adresse du premier indice du premier triangle. par convention c'est un uint,...</div><div class="ttdef"><b>Definition:</b> <a href="mesh_8h_source.html#l00279">mesh.h:279</a></div></div>
<div class="ttc" id="aclassMesh_html_a916a1089ab91b425b159e0b34a3ed780"><div class="ttname"><a href="classMesh.html#a916a1089ab91b425b159e0b34a3ed780">Mesh::vertex_buffer_size</a></div><div class="ttdeci">std::size_t vertex_buffer_size() const</div><div class="ttdoc">renvoie la longueur (en octets) du vertex buffer.</div><div class="ttdef"><b>Definition:</b> <a href="mesh_8h_source.html#l00261">mesh.h:261</a></div></div>
<div class="ttc" id="aclassMesh_html_ab030b9ea443989d5966ea0be3e5e20a1"><div class="ttname"><a href="classMesh.html#ab030b9ea443989d5966ea0be3e5e20a1">Mesh::vertex_count</a></div><div class="ttdeci">int vertex_count() const</div><div class="ttdoc">renvoie le nombre de sommets.</div><div class="ttdef"><b>Definition:</b> <a href="mesh_8h_source.html#l00254">mesh.h:254</a></div></div>
<div class="ttc" id="aclassMesh_html_a3387f3c281e83b20adcc083e086a6b53"><div class="ttname"><a href="classMesh.html#a3387f3c281e83b20adcc083e086a6b53">Mesh::vertex_buffer</a></div><div class="ttdeci">const float * vertex_buffer() const</div><div class="ttdoc">renvoie l'adresse de la position du premier sommet. permet de construire les vertex buffers openGL....</div><div class="ttdef"><b>Definition:</b> <a href="mesh_8h_source.html#l00259">mesh.h:259</a></div></div>
<div class="ttc" id="aclassMesh_html_affd5950a84d6985109099f3eee2d729c"><div class="ttname"><a href="classMesh.html#affd5950a84d6985109099f3eee2d729c">Mesh::index_count</a></div><div class="ttdeci">int index_count() const</div><div class="ttdoc">renvoie le nombre d'indices de sommets.</div><div class="ttdef"><b>Definition:</b> <a href="mesh_8h_source.html#l00256">mesh.h:256</a></div></div>
<div class="ttc" id="astructvec3_html"><div class="ttname"><a href="structvec3.html">vec3</a></div><div class="ttdoc">vecteur generique, utilitaire.</div><div class="ttdef"><b>Definition:</b> <a href="vec_8h_source.html#l00144">vec.h:144</a></div></div>
<div class="ttc" id="aclassMesh_html"><div class="ttname"><a href="classMesh.html">Mesh</a></div><div class="ttdoc">representation d'un objet / maillage.</div><div class="ttdef"><b>Definition:</b> <a href="mesh_8h_source.html#l00108">mesh.h:108</a></div></div>
<div class="ttc" id="astructvec4_html"><div class="ttname"><a href="structvec4.html">vec4</a></div><div class="ttdoc">vecteur generique 4d, ou 3d homogene, utilitaire.</div><div class="ttdef"><b>Definition:</b> <a href="vec_8h_source.html#l00166">vec.h:166</a></div></div>
<div class="ttc" id="aclassMesh_html_a6b225c39aa3ef76dc6224565d32f0a61"><div class="ttname"><a href="classMesh.html#a6b225c39aa3ef76dc6224565d32f0a61">Mesh::index_buffer_size</a></div><div class="ttdeci">std::size_t index_buffer_size() const</div><div class="ttdoc">renvoie la taille (en octets) de l'index buffer.</div><div class="ttdef"><b>Definition:</b> <a href="mesh_8h_source.html#l00281">mesh.h:281</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 9 2019 15:39:11 for gKit2 light by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
