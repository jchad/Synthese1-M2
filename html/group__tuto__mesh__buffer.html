<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gKit2 light: tuto9_buffers.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">gKit2 light
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">tuto9_buffers.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<p>cf <a class="el" href="tuto9__buffers_8cpp.html">tuto9_buffers.cpp</a></p>
<p>le tuto précédent a montré comment manipuler un shader openGL pour dessiner un <a class="el" href="classMesh.html" title="representation d&#39;un objet / maillage.">Mesh</a>, ce tuto explique rapidement comment créer et configurer le vertex buffer et le vertex array qui permettent de dessiner directement un <a class="el" href="classMesh.html" title="representation d&#39;un objet / maillage.">Mesh</a> avec openGL.</p>
<p>que font <a class="el" href="classMesh.html" title="representation d&#39;un objet / maillage.">Mesh</a> et draw(mesh, program) pour afficher un objet ? comme expliqué dans le tuto précédent, les attributs de sommets doivent se trouver dans la memoire de la carte graphique pour que les vertex shader s'exécutent correctement.</p>
<p>la mémoire de la carte graphique est séparée de la mémoire de l'application : il n'est pas possible de faire un <code>malloc</code> ou un <code>new</code> directment, mais openGL propose des buffers comme mécanisme d'allocation de mémoire.</p>
<p>il faut d'abord créer un identifiant de buffer, cf glGenBuffers(), et le sélectionner pour le manipuler, cf glBindBuffer() : </p><div class="fragment"><div class="line">GLuint buffer;</div>
<div class="line">glGenBuffers(1, &amp;buffer);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// selectionne le buffer </span></div>
<div class="line">glBindBuffer(GL_ARRAY_BUFFER, buffer);</div>
</div><!-- fragment --><p>pour donner la taille du buffer, et son contenu, cf glBufferData() : </p><div class="fragment"><div class="line"><span class="comment">// selectionner le buffer, si necessaire :</span></div>
<div class="line"><span class="comment">// glBindBuffer(GL_ARRAY_BUFFER, buffer);</span></div>
<div class="line">glBufferData(GL_ARRAY_BUFFER, <span class="comment">/* size */</span>, <span class="comment">/* data */</span>, GL_STATIC_DRAW);</div>
</div><!-- fragment --><p>le dernier parametre, GL_STATIC_DRAW, indique que le contenu du buffer ne sera pas modifie.</p>
<p>il ne reste plus qu'à utiliser glBufferData() pour allouer et copier toutes les positions des sommets d'un <a class="el" href="classMesh.html" title="representation d&#39;un objet / maillage.">Mesh</a> : </p><div class="fragment"><div class="line"><a class="code" href="classMesh.html">Mesh</a> mesh= <a class="code" href="group__objet3D.html#ga9982954fa508a4c2c9a26e06e09b7352">read_mesh</a>( ... );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// selectionner le buffer, si necessaire :</span></div>
<div class="line"><span class="comment">// glBindBuffer(GL_ARRAY_BUFFER, buffer);</span></div>
<div class="line">glBufferData(GL_ARRAY_BUFFER, <span class="comment">/* size */</span> mesh.<a class="code" href="classMesh.html#a916a1089ab91b425b159e0b34a3ed780">vertex_buffer_size</a>(), <span class="comment">/* data */</span> mesh.<a class="code" href="classMesh.html#a3387f3c281e83b20adcc083e086a6b53">vertex_buffer</a>(), GL_STATIC_DRAW);</div>
</div><!-- fragment --><p><em>remarque :</em> on peut aussi ecrire une fonction utilitaire plus proche de l'utilisation de <code>malloc</code> : </p><div class="fragment"><div class="line">GLuint create_buffer( <span class="keyword">const</span> <span class="keywordtype">int</span> size, <span class="keyword">const</span> <span class="keywordtype">void</span> *data )</div>
<div class="line">{</div>
<div class="line">    GLuint buffer;</div>
<div class="line">    glGenBuffers(1, &amp;buffer);</div>
<div class="line">    glBindBuffer(GL_ARRAY_BUFFER, buffer);</div>
<div class="line">    glBufferData(GL_ARRAY_BUFFER, size, data, GL_STATIC_DRAW);</div>
<div class="line">    <span class="keywordflow">return</span> buffer;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> release_buffer( <span class="keyword">const</span> GLuint buffer )</div>
<div class="line">{</div>
<div class="line">    glDeleteBuffers(1, &amp;buffer);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">GLuint buffer= create_buffer(mesh.<a class="code" href="classMesh.html#a916a1089ab91b425b159e0b34a3ed780">vertex_buffer_size</a>(), mesh.<a class="code" href="classMesh.html#a3387f3c281e83b20adcc083e086a6b53">vertex_buffer</a>());</div>
</div><!-- fragment --><p>dernière étape, décrire le format des sommets du <a class="el" href="classMesh.html" title="representation d&#39;un objet / maillage.">Mesh</a> avec un vertex array object : même démarche, il faut créer un identifiant, cf glGenVertexArrays(), le sélectionner, cf glBindVertexArray(), et le configurer, cf glVertexAttribPointer() : </p><div class="fragment"><div class="line">GLuint vao;</div>
<div class="line">glGenVertexArrays(1, &amp;vao);</div>
<div class="line">glBindVertexArray(vao);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// selectionner le buffer contenant les positions, si nécessaire, c&#39;est un parametre implicite de glVertexAttribPointer !!</span></div>
<div class="line"><span class="comment">// glBindBuffer(GL_ARRAY_BUFFER, buffer);</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// configurer l&#39;attribut 0, position, cf convention de Mesh</span></div>
<div class="line">glVertexAttribPointer( <span class="comment">/* attribute */</span> 0, </div>
<div class="line">    3, GL_FLOAT,    <span class="comment">// size et type, position est un vec3 dans le vertex shader</span></div>
<div class="line">    GL_FALSE,       <span class="comment">// pas de normalisation des valeurs</span></div>
<div class="line">    0,              <span class="comment">// stride 0, les valeurs sont les unes a la suite des autres</span></div>
<div class="line">    0               <span class="comment">// offset 0, les valeurs sont au debut du buffer</span></div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// utiliser l&#39;attribut 0</span></div>
<div class="line">glEnableVertexAttribArray(0);</div>
</div><!-- fragment --><p>voila, les coordonnées des sommets du <a class="el" href="classMesh.html" title="representation d&#39;un objet / maillage.">Mesh</a> sont transférées dans un buffer, l'attribut est configuré dans un vertex array object, il suffira de le selectionner avant le glDraw() pour dessiner l'objet : </p><div class="fragment"><div class="line"><span class="comment">// configuration minimale du pipeline openGL</span></div>
<div class="line">glUseProgram( ... );</div>
<div class="line">glBindVertexArray(vao);</div>
<div class="line">glDrawArrays(GL_TRIANGLES, 0, n);</div>
</div><!-- fragment --><p>dernier detail, il ne faut pas oublier de conserver le nombre de sommets, et il n'est plus nécessaire de conserver l'objet <a class="el" href="classMesh.html" title="representation d&#39;un objet / maillage.">Mesh</a> !</p>
<p>cf <a class="el" href="group__tuto4GL.html">configurer un format de sommet, vertex array object</a> pour tous les détails supplémentaires, utiliser plusieurs buffers, plusieurs attributs, etc.</p>
<p><a class="el" href="tuto9__buffers_8cpp.html">tuto9_buffers.cpp</a> donne un exemple complet et stocke toutes les informations dans une structure <a class="el" href="structBuffers.html">Buffers</a> :</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structBuffers.html">Buffers</a></div>
<div class="line">{</div>
<div class="line">    GLuint vao;</div>
<div class="line">    GLuint vertex_buffer;</div>
<div class="line">    <span class="keywordtype">int</span> vertex_count;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="structBuffers.html">Buffers</a>( ) : vao(0), vertex_buffer(0), vertex_count(0) {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> create( <span class="keyword">const</span> <a class="code" href="classMesh.html">Mesh</a>&amp; mesh )</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span>(!mesh.<a class="code" href="classMesh.html#a916a1089ab91b425b159e0b34a3ed780">vertex_buffer_size</a>()) <span class="keywordflow">return</span>;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// cree et initialise le buffer stockant les positions des sommets</span></div>
<div class="line">        glGenBuffers(1, &amp;vertex_buffer);</div>
<div class="line">        glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer);</div>
<div class="line">        glBufferData(GL_ARRAY_BUFFER, mesh.<a class="code" href="classMesh.html#a916a1089ab91b425b159e0b34a3ed780">vertex_buffer_size</a>(), mesh.<a class="code" href="classMesh.html#a3387f3c281e83b20adcc083e086a6b53">vertex_buffer</a>(), GL_STATIC_DRAW);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// cree et configure un vertex array object: conserve la description des attributs de sommets</span></div>
<div class="line">        glGenVertexArrays(1, &amp;vao);</div>
<div class="line">        glBindVertexArray(vao);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// attribut 0, position des sommets, declare dans le vertex shader : in vec3 position;</span></div>
<div class="line">        glVertexAttribPointer(0, </div>
<div class="line">            3, GL_FLOAT,    <span class="comment">// size et type, position est un vec3 dans le vertex shader</span></div>
<div class="line">            GL_FALSE,       <span class="comment">// pas de normalisation des valeurs</span></div>
<div class="line">            0,              <span class="comment">// stride 0, les valeurs sont les unes a la suite des autres</span></div>
<div class="line">            0               <span class="comment">// offset 0, les valeurs sont au debut du buffer</span></div>
<div class="line">        );</div>
<div class="line">        glEnableVertexAttribArray(0);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// conserve le nombre de sommets</span></div>
<div class="line">        vertex_count= mesh.<a class="code" href="classMesh.html#ab030b9ea443989d5966ea0be3e5e20a1">vertex_count</a>();</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> release( )</div>
<div class="line">    {</div>
<div class="line">        glDeleteVertexArrays(1, &amp;vao);</div>
<div class="line">        glDeleteBuffers(1, &amp;vertex_buffer);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// init de l&#39;application :</span></div>
<div class="line">    <a class="code" href="classMesh.html">Mesh</a> mesh= <a class="code" href="group__objet3D.html#ga9982954fa508a4c2c9a26e06e09b7352">read_mesh</a>(<span class="stringliteral">&quot;data/cube.obj&quot;</span>);</div>
<div class="line">    <span class="keywordflow">if</span>(!mesh.<a class="code" href="classMesh.html#ab030b9ea443989d5966ea0be3e5e20a1">vertex_count</a>()) <span class="keywordflow">return</span> -1;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// creer le vertex buffer et le vao</span></div>
<div class="line">    m_objet.create(mesh);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// mesh n&#39;est plus necessaire</span></div>
<div class="line">    mesh.<a class="code" href="classMesh.html#abe72d90d78f80e8e8013bb5737fc94b4">release</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// draw de l&#39;application :</span></div>
<div class="line">    <span class="comment">// selectionner le program</span></div>
<div class="line">    glUseProgram( );</div>
<div class="line">    <span class="comment">// parametrer le program, cf tuto9</span></div>
<div class="line">    { ... }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// selectionner les buffers et les attributs de l&#39;objet </span></div>
<div class="line">    glBindVertexArray(m_objet.vao);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// dessiner les triangles de l&#39;objet</span></div>
<div class="line">    glDrawArrays(GL_TRIANGLES, 0, m_objet.vertex_count);</div>
</div><!-- fragment --><p>les différentes variantes de glDraw() sont expliquées dans <a class="el" href="group__draw.html">glDraw( ) et la famille</a>. </p>
</div><!-- contents -->
<div class="ttc" id="aclassMesh_html_a916a1089ab91b425b159e0b34a3ed780"><div class="ttname"><a href="classMesh.html#a916a1089ab91b425b159e0b34a3ed780">Mesh::vertex_buffer_size</a></div><div class="ttdeci">std::size_t vertex_buffer_size() const</div><div class="ttdoc">renvoie la longueur (en octets) du vertex buffer.</div><div class="ttdef"><b>Definition:</b> <a href="mesh_8h_source.html#l00261">mesh.h:261</a></div></div>
<div class="ttc" id="aclassMesh_html_ab030b9ea443989d5966ea0be3e5e20a1"><div class="ttname"><a href="classMesh.html#ab030b9ea443989d5966ea0be3e5e20a1">Mesh::vertex_count</a></div><div class="ttdeci">int vertex_count() const</div><div class="ttdoc">renvoie le nombre de sommets.</div><div class="ttdef"><b>Definition:</b> <a href="mesh_8h_source.html#l00254">mesh.h:254</a></div></div>
<div class="ttc" id="aclassMesh_html_a3387f3c281e83b20adcc083e086a6b53"><div class="ttname"><a href="classMesh.html#a3387f3c281e83b20adcc083e086a6b53">Mesh::vertex_buffer</a></div><div class="ttdeci">const float * vertex_buffer() const</div><div class="ttdoc">renvoie l'adresse de la position du premier sommet. permet de construire les vertex buffers openGL....</div><div class="ttdef"><b>Definition:</b> <a href="mesh_8h_source.html#l00259">mesh.h:259</a></div></div>
<div class="ttc" id="aclassMesh_html_abe72d90d78f80e8e8013bb5737fc94b4"><div class="ttname"><a href="classMesh.html#abe72d90d78f80e8e8013bb5737fc94b4">Mesh::release</a></div><div class="ttdeci">void release()</div><div class="ttdoc">detruit les objets openGL.</div><div class="ttdef"><b>Definition:</b> <a href="mesh_8cpp_source.html#l00022">mesh.cpp:22</a></div></div>
<div class="ttc" id="astructBuffers_html"><div class="ttname"><a href="structBuffers.html">Buffers</a></div><div class="ttdef"><b>Definition:</b> <a href="tuto7_8cpp_source.html#l00012">tuto7.cpp:12</a></div></div>
<div class="ttc" id="aclassMesh_html"><div class="ttname"><a href="classMesh.html">Mesh</a></div><div class="ttdoc">representation d'un objet / maillage.</div><div class="ttdef"><b>Definition:</b> <a href="mesh_8h_source.html#l00108">mesh.h:108</a></div></div>
<div class="ttc" id="agroup__objet3D_html_ga9982954fa508a4c2c9a26e06e09b7352"><div class="ttname"><a href="group__objet3D.html#ga9982954fa508a4c2c9a26e06e09b7352">read_mesh</a></div><div class="ttdeci">Mesh read_mesh(const char *filename)</div><div class="ttdoc">charge un fichier wavefront .obj et renvoie un mesh compose de triangles non indexes....</div><div class="ttdef"><b>Definition:</b> <a href="wavefront_8cpp_source.html#l00038">wavefront.cpp:38</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 9 2019 15:39:11 for gKit2 light by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
