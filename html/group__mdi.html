<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gKit2 light: openGL 4.3 : multi draw indirect</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">gKit2 light
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">openGL 4.3 : multi draw indirect</div>  </div>
</div><!--header-->
<div class="contents">
<p>cf <a class="el" href="tuto__mdi_8cpp.html">tuto_mdi.cpp</a> + <a class="el" href="indirect_8glsl_source.html">indirect.glsl</a></p>
<p>Les fonctions d'affichage classiques, cf <a class="el" href="group__draw.html">glDraw( ) et la famille</a>, sont relativement efficaces pour dessiner quelques objets, glDrawInstanced( ) permet d'afficher de nombreuses copies du même objet, mais openGL 3.3 ne fournit pas de méthode pour afficher un grand nombre d'objets différents.</p>
<p>En effet, la préparation de chaque draw nécessite pas mal de travail au driver openGL, et c'est finalement le cpu qui limite le nombre d'objets affichables, alors que la carte graphique est sous exploitée. Le tuto <a class="el" href="group__time.html">mesure du temps cpu et gpu</a> présente une méthode pour mesurer le temps cpu utilisé pour préparer N commandes d'affichage pour la carte graphique, en comparant les solutions précédentes : N commandes ou 1 commande instanciée avec N copies.</p>
<p>openGL 4.3 a introduit de nouvelles variantes de draw : <code>glMultiDrawArraysIndirect( )</code> et <code>glMultiDrawElementsIndirect()</code> qui permettent de décrire les paramètres d'affichage de plusieurs objets. Le gain d'efficacité se trouve du coté du driver qui ne réalise qu'une seule préparation et soumet toutes les commandes d'affichage à la carte graphique en une seule fois.</p>
<p>Le principe est relativement simple, les paramètres de chaque commande d'affichage sont décrits par une structure, et un tableau de structures est passé en paramètre à MultiDraw(). </p><div class="fragment"><div class="line"><span class="comment">// parametres pour MultiDrawArraysIndirect</span></div>
<div class="line"><span class="keyword">struct </span>ArraysParam</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vertex_count;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> instance_count;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vertex_base;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> instance_base;</div>
<div class="line">};</div>
</div><!-- fragment --><p>cette structure permet de décrire les paramétres de glDrawArrays(), glDrawArraysInstanced|BaseInstance(). En gros, voila ce que fait MultiDrawArraysIndirect( ) : </p><div class="fragment"><div class="line">MultiDrawArraysIndirect( GLenum primitives, std::vector&lt;ArraysParam&gt;&amp; params )</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i= 0; i &lt; params.size(); i++)</div>
<div class="line">        <span class="keywordflow">if</span>(params[i].instance_count &gt; 0)</div>
<div class="line">            <span class="comment">// draw instancie</span></div>
<div class="line">            glDrawArraysInstancedBaseInstance(primitives, params[i].vertex_base, params[i].vertex_count, params[i].instance_count, params[i].instance_base);</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">            <span class="comment">// draw normal</span></div>
<div class="line">            glDrawArray(primitives, params[i].vertex_base, params[i].vertex_count);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Pour glDrawElements(), glDrawElementsInstanced(), y compris les variantes permettant de préciser les indices de la première instance et du premier sommet, cf <a class="el" href="group__draw.html">glDraw( ) et la famille</a> glDrawElementsBaseVertex() et glDrawElementsInstancedBaseVertexBaseInstance() (!!) la structure est : </p><div class="fragment"><div class="line"><span class="comment">// parametres pour MultiDrawElementsIndirect</span></div>
<div class="line"><span class="keyword">struct </span>ElementsParam</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index_count;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> instance_count;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> first_index;       <span class="comment">// cf parametre offset de glDrawElements()</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vertex_base;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> instance_base;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Dernier détail, le tableau de structures doit être dans un buffer sélectionné sur <code>GL_DRAW_INDIRECT_BUFFER</code>.</p>
<p>Le code d'exemple <a class="el" href="tuto__mdi_8cpp.html">tuto_mdi.cpp</a> + <a class="el" href="indirect_8glsl_source.html">indirect.glsl</a> transfere un tableau de ~1000 draws et permet de comparer le temps d'excécution des 2 solutions. Voici les temps mesurés :</p><ul>
<li>afficher ~1000 bigguy, avec 1000 glDrawArrays() : 10ms pour le cpu, &lt;2ms pour le gpu,</li>
<li>glMultiDrawArraysIndirect(), 50us pour le cpu, &lt;2ms pour le gpu...</li>
</ul>
<p>L'utilisation la plus interressante de MultiDraw() est de remplir le buffer directement sur la carte graphique avec un shader, ce qui évite de le transférer à chaque affichage. Le (compute) shader peut, par exemple, faire quelques tests de visibilité et déterminer s'il est nécessaire de dessiner chaque objet.</p>
<p>Mais, dans ce cas, un problème se pose : il faut connaitre, dans l'application, le nombre de commandes / d'objets à dessiner pour utiliser glMultiDrawArraysIndirect( )... La solution est fournie par une variante de MultiDraw() : <code>glMultiDrawArraysIndirectCountARB( )</code>. Le nombre de commandes / d'objets à dessiner se trouve dans (une variable d) un buffer sélectionné sur <code>GL_PARAMETER_BUFFER_ARB</code>. Cette fonction n'est pas encore standard, mais elle est disponible sur toutes les cartes graphiques. C'est l'extension <code>GL_ARB_indirect_parameters</code> qui permet de l'utiliser.</p>
<p>cf <a class="el" href="tuto__mdi__count_8cpp.html">tuto_mdi_count.cpp</a> + <a class="el" href="indirect__cull_8glsl_source.html">indirect_cull.glsl</a> + <a class="el" href="indirect__remap_8glsl_source.html">indirect_remap.glsl</a> pour un exemple complet, avec un compute shader qui décide de dessiner un objet, ou pas, et qui comptabilise les objets à dessiner par <code>glMultiDrawArraysIndirectCountARB( )</code>.</p>
<p><b>remarque :</b> vérifier que l'extension est bien disponible avant de l'utiliser, sinon c'est segfault, la librairie GLEW utilisée par gKit permet d'écrire directement le test </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;glcore.h&quot;</span> <span class="comment">// deja inclut par window.h, app.h, etc.</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="shader__kit_8cpp.html#a72fad2bb274e5f3b6d190bd860ea63b5">init</a>( ) :</div>
<div class="line">    <span class="comment">// verifier la presence de l&#39;extension</span></div>
<div class="line">    if(GLEW_ARB_indirect_parameters == 0)</div>
<div class="line">        <span class="comment">// erreur, extension non disponible</span></div>
<div class="line">        return -1;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md133"></a>
organisation des données</h2>
<p>Le seul problème de la famille MultiDraw() est la nécessité d'organiser les données : par exemple, tous les objets que l'on souhaite dessiner avec un appel de MultiDraw() doivent être décrits par les mêmes buffers et le même VAO... toutes les textures nécessaires doivent être sélectionnées, les transformations, les uniforms, etc.</p>
<p>La variable gl_DrawIDARB de GLSL numérote les commandes, ce qui permet de retrouver toutes les informations de l'objet, mais il faut les organiser sous cette forme. En gros, les paramètres <code>uniform</code> deviennent des tableaux, indexés par gl_DrawIDARB. En pratique on utilisera des uniform buffers ou des storage buffers pour ne pas être bloqué par la limite de taille des uniforms.</p>
<p>De même, il faut concaténer les attributs des objets dans un (gros) buffer et configurer le vao correspondant. L'objectif n'est pas de dessiner toute la scène avec un seul MultiDraw(), mais de limiter leur nombre à une valeur raisonnable. Par exemple, les objets animés ne seront pas transformés par le même vertex shader que les objets statiques, les objets opaques ne seront pas dessinés avec le même fragment shader que les objets transparents... et comme il n'est pas possible de changer de shader program objet par objet avec MultiDraw(), il faudra nécessairement plusieurs appels pour afficher ces différents types d'objets.</p>
<p>Voici le vertex shader utilisé par l'exemple, cf <a class="el" href="indirect_8glsl_source.html">indirect.glsl</a> : </p><div class="fragment"><div class="line"><span class="preprocessor">#extension GL_ARB_shader_draw_parameters : require</span></div>
<div class="line"><span class="comment">// necessaire pour utiliser gl_DrawIDARB</span></div>
<div class="line"> </div>
<div class="line">layout(location= 0) in <a class="code" href="structvec3.html">vec3</a> position;</div>
<div class="line"> </div>
<div class="line">uniform mat4 vpMatrix;      <span class="comment">// projection * view</span></div>
<div class="line">uniform mat4 model[1000];   <span class="comment">// model</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main( )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// recupere la transformation model de l&#39;objet et transforme le sommet...</span></div>
<div class="line">    gl_Position= vpMatrix * model[gl_DrawIDARB] * <a class="code" href="structvec4.html">vec4</a>(position, 1);</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>remarque :</b> la variable gl_DrawID n'est pas encore inclue dans une version standard d'openGL, il faut donc utiliser une extension GLSL. Il suffit d'ajouter, dans le source du shader, une ligne donnant le nom de chaque extension nécessaire : </p><div class="fragment"><div class="line"><span class="preprocessor">#extension GL_ARB_shader_draw_parameters : require</span></div>
</div><!-- fragment --><p>Pour etre complet, il faut aussi vérifier la présence de l'extension openGL dans l'init de l'application : </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;glcore.h&quot;</span> <span class="comment">// deja inclut par window.h, app.h, etc.</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="shader__kit_8cpp.html#a72fad2bb274e5f3b6d190bd860ea63b5">init</a>( ) :</div>
<div class="line">    <span class="comment">// verifier la presence de l&#39;extension</span></div>
<div class="line">    if(GLEW_ARB_shader_draw_parameters == 0)</div>
<div class="line">        <span class="comment">// erreur, extension non disponible</span></div>
<div class="line">        return -1;</div>
</div><!-- fragment --> </div><!-- contents -->
<div class="ttc" id="ashader__kit_8cpp_html_a72fad2bb274e5f3b6d190bd860ea63b5"><div class="ttname"><a href="shader__kit_8cpp.html#a72fad2bb274e5f3b6d190bd860ea63b5">init</a></div><div class="ttdeci">int init(std::vector&lt; const char * &gt; &amp;options)</div><div class="ttdef"><b>Definition:</b> <a href="shader__kit_8cpp_source.html#l00094">shader_kit.cpp:94</a></div></div>
<div class="ttc" id="astructvec3_html"><div class="ttname"><a href="structvec3.html">vec3</a></div><div class="ttdoc">vecteur generique, utilitaire.</div><div class="ttdef"><b>Definition:</b> <a href="vec_8h_source.html#l00144">vec.h:144</a></div></div>
<div class="ttc" id="astructvec4_html"><div class="ttname"><a href="structvec4.html">vec4</a></div><div class="ttdoc">vecteur generique 4d, ou 3d homogene, utilitaire.</div><div class="ttdef"><b>Definition:</b> <a href="vec_8h_source.html#l00166">vec.h:166</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 9 2019 15:39:11 for gKit2 light by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
