<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gKit2 light: afficher plusieurs triangles, modifier les paramètres uniform d&#39;un shader program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">gKit2 light
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">afficher plusieurs triangles, modifier les paramètres uniform d'un shader program</div>  </div>
</div><!--header-->
<div class="contents">
<p>cf <a class="el" href="tuto3GL_8cpp.html">tuto3GL.cpp</a></p>
<p>pour pouvoir dessiner quelque chose, il faut commencer par configurer le pipeline openGL, repassez dans <a class="el" href="group__intro3d.html">introduction api 3d, openGL et pipeline graphique</a> si nécessaire.</p>
<p>la configuration minimale est :</p><ul>
<li>le pipeline "fixe", des options :<ul>
<li>l'image dans laquelle dessiner, cf glBindFramebuffer() et glDrawBuffer(),</li>
<li>les dimensions de l'image, cf glViewport( ),</li>
<li>la couleur par défaut de l'image, cf glClearColor( ),</li>
<li>la profondeur par défaut du zbuffer, cf glClearDepthf( ),</li>
<li>le test de profondeur, cf glEnable/Disable(GL_DEPTH_TEST),</li>
<li>l'orientation des faces <em>avant</em>, cf glFrontFace(),</li>
<li>l'élimination des faces <em>arrière</em>, cf glEnable/Disable(GL_CULL_FACE),</li>
<li>la description des attributs des sommets, sélectionner un vertex array, cf glBindVertexArray( ),</li>
</ul>
</li>
<li>le pipeline programmable, les shaders :<ul>
<li>un shader program, sélectionner un shader program, cf glUseProgram( )</li>
</ul>
</li>
</ul>
<p>glClearColor() et glClearDepthf() définissent les valeurs par défaut utilisées pour "éffacer" l'image et le zbuffer, avec glClear( ). la taille de l'image est fournie par glViewport( ). Les images associées à la fenêtre s'appellent GL_BACK et GL_FRONT, c'est GL_FRONT qui est affichée dans la fenêtre, on dessine donc dans GL_BACK. pour une application simple, il suffit de fixer les valeurs une seule fois dans <a class="el" href="shader__kit_8cpp.html#a72fad2bb274e5f3b6d190bd860ea63b5">init( )</a> : </p><div class="fragment"><div class="line">glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0);</div>
<div class="line">glDrawBuffer(GL_BACK);</div>
<div class="line"> </div>
<div class="line">glViewport(0, 0, <a class="code" href="group__application.html#gae3a7daacf8fe05cc4e57d8557ec4e475">window_width</a>(), <a class="code" href="group__application.html#ga4d0b205b70f38973c8c5395f31f77baf">window_height</a>());</div>
<div class="line"> </div>
<div class="line">glClearColor(0.2f, 0.2f, 0.2f);</div>
<div class="line">glClearDepthf(1.0f);</div>
</div><!-- fragment --><p><em>remarque :</em> si la fenetre de l'application change de dimension, il ne faut pas oublier de modifier glViewport(). si vous utilisez <a class="el" href="window_8cpp.html#a1f48b52d1bd46a5b48fdbb44a53a15a2" title="boucle de gestion des evenements de l&#39;application.">run( )</a> de <a class="el" href="window_8h.html">window.h</a>, c'est fait automatiquement.</p>
<p>puis effacer l'image et le zbuffer au début de draw( ): </p><div class="fragment"><div class="line">glClear(GL_COLOR_BUFFER_BIT);   <span class="comment">// effacer l&#39;image</span></div>
<div class="line">glClear(GL_DEPTH_BUFFER_BIT);   <span class="comment">// effacer le zbuffer, si nécessaire</span></div>
</div><!-- fragment --><p> on peut combiner les deux, avec un OU binaire : </p><div class="fragment"><div class="line">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); <span class="comment">// effacer l&#39;image et le zbuffer</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md70"></a>
ztest et zbuffer</h2>
<p>pour obtenir une visibilité correcte lorsque plusieurs triangles se dessinent sur le même pixel, il faut indiquer lequel garder, celui dont la profondeur est la plus petite, ou la plus grande, ou égale, etc. </p><div class="fragment"><div class="line">glDepthFunc(GL_LESS);           <span class="comment">// conserver le triangle le plus proche, </span></div>
<div class="line">glDepthFunc(GL_GREATER);        <span class="comment">// conserver le triangle le plus loin, </span></div>
<div class="line">glDepthFunc(GL_ALWAYS);         <span class="comment">// conserver le dernier triangle dessine </span></div>
</div><!-- fragment --><p><em>remarque :</em> pour conserver le triangle le plus loin, avec glDepthFunc(GL_GREATER), il faut initialiser le zbuffer correctement : avec la profondeur la plus petite, c'est à dire 0, dans le repère image, cf <a class="el" href="group__intro3d.html">introduction api 3d, openGL et pipeline graphique</a>.</p>
<p>glDepthFunc() permet de choisir le test, mais il faut aussi l'activer (ou le désactiver) : </p><div class="fragment"><div class="line">glEnable(GL_DEPTH_TEST);        <span class="comment">// activer le ztest</span></div>
<div class="line">glDisable(GL_DEPTH_TEST);       <span class="comment">// desactiver le ztest</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md71"></a>
élimination des faces arrières / back face culling</h2>
<p>lorsque les triangles décrivent la surface d'un objet opaque, les triangles à l'arrière de l'objet ne sont pas visibles, il est assez simple de les détecter, cf <a class="el" href="group__intro3d.html">introduction api 3d, openGL et pipeline graphique</a>, par contre, il faut donner l'orientation normale des faces, sens trigo ou horaire, et choisir lesquelles on veut supprimer (avant ou arrière) et enfin, activer le test :</p>
<div class="fragment"><div class="line">glFrontFace(GL_CCW);            <span class="comment">// les faces visibles / avant sont dans le sens trigo / counter clockwise</span></div>
<div class="line">glFrontFace(GL_CW);             <span class="comment">// les faces visibles / avant sont dans le sens horaire / clockwise</span></div>
</div><!-- fragment --> <div class="fragment"><div class="line">glCullFace(GL_BACK);            <span class="comment">// eliminer les faces arrieres</span></div>
<div class="line">glCullFace(GL_FRONT);           <span class="comment">// ou les faces avant ?</span></div>
</div><!-- fragment --><div class="fragment"><div class="line">glEnable(GL_CULL_FACE);         <span class="comment">// activer le test</span></div>
<div class="line">glDisable(GL_CULL_FACE);        <span class="comment">// desactiver le test</span></div>
</div><!-- fragment --><p>le test standard s'écrit : </p><div class="fragment"><div class="line">glFrontFace(GL_CCW);</div>
<div class="line">glCullFace(GL_BACK);</div>
<div class="line">glEnable(GL_CULL_FACE);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md72"></a>
attributs de sommets, vertex array object, vao</h2>
<p>pour dessiner des triangles, il faut décrire les informations associées aux sommets, indiquer ou les trouver, leur organisation mémoire, et indiquer à quelles entrées du vertex shader elles sont associées.</p>
<p>le cas général est présenté dans <a class="el" href="group__tuto4GL.html">configurer un format de sommet, vertex array object</a>, pour l'instant, la solution la plus simple est d'utiliser un tableau uniform déclaré par le vertex shader, sans description de format de sommet. c'est un objet openGL, appelé vertex array object qui stocke la description du format de sommets. il suffit donc de créer un vertex array object vide / par défaut.</p>
<p>la création des objets openGL utilise des fonctions de la forme glGenXXX( int n, GLuint *names ). cette famille de fonctions permet de créer plusieurs objets en même temps et renvoye un tableau d'identifiants des nouveaux objets. pour en créer un seul, on peut utiliser : </p><div class="fragment"><div class="line">GLuint vao;</div>
<div class="line">glGenVertexArrays(1, &amp;vao);</div>
</div><!-- fragment --><p>il ne reste plus qu'à le sélectionner pour configurer le pipeline : </p><div class="fragment"><div class="line">glBindVertexArray(vao);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md73"></a>
uniforms et shader program</h2>
<p>après avoir compilé et linké un shader program, cf <a class="el" href="group__tuto2GL.html">compiler et linker un shader program</a>, il faut le sélectionner pour configurer le pipeline : </p><div class="fragment"><div class="line">GLuint program= ... ;</div>
<div class="line">glUseProgram(program);</div>
</div><!-- fragment --><p>avant de pouvoir dessiner, il faut affecter une valeur à tous les uniforms utilisés par le shader program. l'affectation se fait en 2 étapes :</p><ul>
<li>récupérer l'identifiant du paramètre uniform, cf glGetUniformLocation( ),</li>
<li>affecter une valeur en utilisant la bonne fonction de la (grande) famille glUniform( ),</li>
</ul>
<p><b>attention :</b> ne pas oublier que glUniform() affecte une valeur à un uniform du program actuellement sélectionné par glUseProgram()...</p>
<p><a class="el" href="tuto3GL_8glsl_source.html">tuto3GL.glsl</a> déclare 3 uniforms :</p><ul>
<li>uniform float time;</li>
<li>uniform <a class="el" href="structvec4.html" title="vecteur generique 4d, ou 3d homogene, utilitaire.">vec4</a> color;</li>
<li>uniform <a class="el" href="structvec3.html" title="vecteur generique, utilitaire.">vec3</a> positions[36];</li>
</ul>
<p>la démarche est identique dans les 3 cas, même pour le tableau. par contre, il faut utiliser la bonne version de glUniform() à chaque fois.</p>
<p>pour time, 1 float, il faut utiliser glUniform1f() pour l'affectation (cf <a class="el" href="group__interfaceC.html">interface C openGL</a> pour les conventions de nommage) : </p><div class="fragment"><div class="line">GLint location= glGetUniformLocation(program, <span class="stringliteral">&quot;time&quot;</span>);</div>
<div class="line">glUniform1f(location, 12);</div>
</div><!-- fragment --><p>pour color, 4 float, il faut utiliser... glUniform4f() : </p><div class="fragment"><div class="line">GLint location= glGetUniformLocation(program, <span class="stringliteral">&quot;color&quot;</span>);</div>
<div class="line">glUniform4f(location, 1, 1, 1, 1);</div>
</div><!-- fragment --><p>pour le tableau positions, les éléments du tableau sont des <a class="el" href="structvec3.html" title="vecteur generique, utilitaire.">vec3</a>. pour un seul <a class="el" href="structvec3.html" title="vecteur generique, utilitaire.">vec3</a>, on utiliserait glUniform3f( ), pour un tableau, les valeurs sont passées par pointeur, et c'est la variante glUniform3fv(location, count, data) qu'il faut utiliser. <em>count</em> indique le nombre d'élements <a class="el" href="structvec3.html" title="vecteur generique, utilitaire.">vec3</a> à transférer.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="vec_8h.html">vec.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="structvec3.html">vec3</a> data[36]= { ... };</div>
<div class="line"> </div>
<div class="line">GLint location= glGetUniformLocation(program, <span class="stringliteral">&quot;positions&quot;</span>);</div>
<div class="line">glUniform3fv(location, <span class="comment">/* count */</span> 36, data);</div>
</div><!-- fragment --><p><em>remarque :</em> on peut utiliser les variantes pointeurs pour une valeur unique, il suffit de donner 1 comme nombre d'éléments à affecter. par exemple : </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> data= 12;</div>
<div class="line">GLint location= glGetUniformLocation(program, <span class="stringliteral">&quot;time&quot;</span>);</div>
<div class="line">glUniform1fv(location, <span class="comment">/* count */</span> 1, &amp;data);</div>
</div><!-- fragment --><p> ou encore </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="color_8h.html">color.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="structColor.html">Color</a> data= <a class="code" href="structColor.html">Color</a>(1, 1, 1);</div>
<div class="line">GLint location= glGetUniformLocation(program, <span class="stringliteral">&quot;color&quot;</span>);</div>
<div class="line">glUniform4fv(location,  <span class="comment">/* count */</span> 1, &amp;data);</div>
</div><!-- fragment --><p>pour un uniform, ou un tableau, de type matrice 4x4, comme les <a class="el" href="structTransform.html" title="representation d&#39;une transformation, une matrice 4x4, organisee par ligne / row major.">Transform</a>, par exemple, il faut utiliser glUniformMatrix4fv(). <a class="el" href="structTransform.html" title="representation d&#39;une transformation, une matrice 4x4, organisee par ligne / row major.">Transform</a> represente les matrices par 16 floats, organises par ligne, mais openGL utilise l'autre organisation, par colonne, il faut donc transposer les matrices avant de les affecter à un uniform, c'est le role du parametre <em>transpose</em> de glUniformMatrix().</p>
<div class="fragment"><div class="line"><a class="code" href="structTransform.html">Transform</a> t;</div>
<div class="line">GLint location= glGetUniformLocation(program, <span class="stringliteral">&quot;matrix&quot;</span>);        <span class="comment">// cf declaration dans un shader : uniform mat4 matrix;</span></div>
<div class="line">glUniformMatrix4fv(location, <span class="comment">/* count */</span> 1, <span class="comment">/* transpose */</span> GL_TRUE, t.<a class="code" href="structTransform.html#a7c33b582a7671c45d37dc3b15f1676bb">buffer</a>());</div>
</div><!-- fragment --><p><a class="el" href="uniforms_8h.html">uniforms.h</a> définit plusieurs surcharges de la famille glUniform() pour les types les plus courants. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="uniforms_8h.html">uniforms.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="group__openGL.html#ga4464cbf6223da0a918e0d81c55b2c05b">program_uniform</a>(program, <span class="stringliteral">&quot;time&quot;</span>, <span class="keywordtype">float</span>(12));</div>
<div class="line"><a class="code" href="group__openGL.html#ga4464cbf6223da0a918e0d81c55b2c05b">program_uniform</a>(program, <span class="stringliteral">&quot;color&quot;</span>, <a class="code" href="structColor.html">Color</a>(1, 1, 1));</div>
<div class="line"><a class="code" href="group__openGL.html#ga4464cbf6223da0a918e0d81c55b2c05b">program_uniform</a>(program, <span class="stringliteral">&quot;matrix&quot;</span>, <a class="code" href="structTransform.html">Transform</a>());</div>
</div><!-- fragment --><p><b>attention :</b> vérifiez que la bonne surchage soit utilisee, si l'uniform est un scalaire : int, uint ou float, n'hesitez pas utiliser les notations litterales ou les constructeurs explicites :</p><ul>
<li><code>12.5f</code> ou <code>float(12.5)</code> ou <code>(float) 12.5</code>,</li>
<li><code>4</code> ou <code>int(4)</code> ou <code>(int) 4</code>,</li>
<li><code>6u</code> ou <code>unsigned(6)</code> ou <code>(unsigned) 6</code>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md74"></a>
glDraw( )</h2>
<p>on peut enfin dessiner les 12 triangles, c'est à dire les indices de 0 à 36.</p>
<div class="fragment"><div class="line">glDrawArrays(GL_TRIANGLES, 0, 36);</div>
</div><!-- fragment --><p>l'exemple complet est dans <a class="el" href="tuto3GL_8cpp.html">tuto3GL.cpp</a></p>
<h1><a class="anchor" id="autotoc_md75"></a>
résumé : configuration du pipeline</h1>
<p>il faut fixer les paramètres, pour les applications simples, une seule fois dans <a class="el" href="shader__kit_8cpp.html#a72fad2bb274e5f3b6d190bd860ea63b5">init( )</a> : </p><div class="fragment"><div class="line"><span class="comment">// choisir dans quelle image dessiner, celle qui n&#39;est pas affichée, GL_BACK</span></div>
<div class="line">glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0);</div>
<div class="line">glDrawBuffer(GL_BACK);</div>
<div class="line"><span class="comment">// definir la taille de l&#39;image a dessiner, </span></div>
<div class="line">glViewport(0, 0, width, height);    </div>
<div class="line"><span class="comment">// fait par run( ) de window.h</span></div>
<div class="line"> </div>
<div class="line">glClearColor(0.2, 0.2, 0.2, 1);     <span class="comment">// definir la couleur par defaut</span></div>
<div class="line">glClearDepthf(1.f);                 <span class="comment">// profondeur par defaut</span></div>
<div class="line"> </div>
<div class="line">glDepthFunc(GL_LESS);               <span class="comment">// ztest, conserver l&#39;intersection la plus proche de la camera</span></div>
<div class="line">glEnable(GL_DEPTH_TEST);            <span class="comment">// activer le ztest</span></div>
<div class="line"> </div>
<div class="line">glFrontFace(GL_CCW);                <span class="comment">// description des faces dans le sens trigo</span></div>
<div class="line">glCullFace(GL_BACK);                <span class="comment">// eliminer les faces arrieres</span></div>
<div class="line">glEnable(GL_CULL_FACE);             <span class="comment">// activer le test</span></div>
</div><!-- fragment --><p>et pour dessiner, dans draw( ), il faut au minimum : </p><div class="fragment"><div class="line">glBindVertexArray(vao);             <span class="comment">// un vertex array object</span></div>
<div class="line">glUseProgram(program);              <span class="comment">// un shader program</span></div>
<div class="line"> </div>
<div class="line">glUniform(...);                     <span class="comment">// donner une valeur a tous les uniforms du program</span></div>
<div class="line"> </div>
<div class="line">glDrawArrays(...);</div>
</div><!-- fragment --><p>éventuellement, on peut vérifier que tous les uniforms utilisés par le program ont bien une valeur ou vérifier que les attributs déclarés par le vertex shader sont bien paramétrés, cf <a class="el" href="group__shader__reflect.html">récupérer les uniforms et les attributs utilisés par un shader program</a>. </p>
</div><!-- contents -->
<div class="ttc" id="agroup__openGL_html_ga4464cbf6223da0a918e0d81c55b2c05b"><div class="ttname"><a href="group__openGL.html#ga4464cbf6223da0a918e0d81c55b2c05b">program_uniform</a></div><div class="ttdeci">void program_uniform(const GLuint program, const char *uniform, const unsigned int v)</div><div class="ttdoc">affecte une valeur a un uniform du shader program. uint.</div><div class="ttdef"><b>Definition:</b> <a href="uniforms_8cpp_source.html#l00068">uniforms.cpp:68</a></div></div>
<div class="ttc" id="astructvec3_html"><div class="ttname"><a href="structvec3.html">vec3</a></div><div class="ttdoc">vecteur generique, utilitaire.</div><div class="ttdef"><b>Definition:</b> <a href="vec_8h_source.html#l00144">vec.h:144</a></div></div>
<div class="ttc" id="agroup__application_html_ga4d0b205b70f38973c8c5395f31f77baf"><div class="ttname"><a href="group__application.html#ga4d0b205b70f38973c8c5395f31f77baf">window_height</a></div><div class="ttdeci">int window_height()</div><div class="ttdoc">renvoie la hauteur de la fenetre de l'application.</div><div class="ttdef"><b>Definition:</b> <a href="window_8cpp_source.html#l00037">window.cpp:37</a></div></div>
<div class="ttc" id="astructTransform_html_a7c33b582a7671c45d37dc3b15f1676bb"><div class="ttname"><a href="structTransform.html#a7c33b582a7671c45d37dc3b15f1676bb">Transform::buffer</a></div><div class="ttdeci">const float * buffer() const</div><div class="ttdoc">renvoie l'adresse de la premiere valeur de la matrice.</div><div class="ttdef"><b>Definition:</b> <a href="mat_8h_source.html#l00053">mat.h:53</a></div></div>
<div class="ttc" id="avec_8h_html"><div class="ttname"><a href="vec_8h.html">vec.h</a></div></div>
<div class="ttc" id="acolor_8h_html"><div class="ttname"><a href="color_8h.html">color.h</a></div></div>
<div class="ttc" id="astructTransform_html"><div class="ttname"><a href="structTransform.html">Transform</a></div><div class="ttdoc">representation d'une transformation, une matrice 4x4, organisee par ligne / row major.</div><div class="ttdef"><b>Definition:</b> <a href="mat_8h_source.html#l00020">mat.h:20</a></div></div>
<div class="ttc" id="auniforms_8h_html"><div class="ttname"><a href="uniforms_8h.html">uniforms.h</a></div></div>
<div class="ttc" id="agroup__application_html_gae3a7daacf8fe05cc4e57d8557ec4e475"><div class="ttname"><a href="group__application.html#gae3a7daacf8fe05cc4e57d8557ec4e475">window_width</a></div><div class="ttdeci">int window_width()</div><div class="ttdoc">renvoie la largeur de la fenetre de l'application.</div><div class="ttdef"><b>Definition:</b> <a href="window_8cpp_source.html#l00033">window.cpp:33</a></div></div>
<div class="ttc" id="astructColor_html"><div class="ttname"><a href="structColor.html">Color</a></div><div class="ttdoc">representation d'une couleur (rgba) transparente ou opaque.</div><div class="ttdef"><b>Definition:</b> <a href="color_8h_source.html#l00013">color.h:13</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 9 2019 15:39:11 for gKit2 light by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
