<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gKit2 light: textures, samplers et pipeline</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">gKit2 light
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">textures, samplers et pipeline</div>  </div>
</div><!--header-->
<div class="contents">
<p>cf <a class="el" href="tuto5GL_8cpp.html">tuto5GL.cpp</a></p>
<p>pour modifier l'apparence d'un objet, il est relativement simple de plaquer une image à la surface des triangles. l'objectif est de modifier la couleur des pixels qui sont utilisés pour dessiner l'objet. et l'idée est d'associer un pixel de la texture à chaque pixel utilisé pour dessiner les triangles de l'objet.</p>
<p>il y a plusieurs choses à faire :</p><ul>
<li>les sommets des triangles ont une information supplémentaire, leur position dans l'image / la texture (en plus de leur position dans le repère local, etc). il faut stocker ces informations dans un buffer et modifier le format des sommets, cf <a class="el" href="group__tuto4GL.html">configurer un format de sommet, vertex array object</a>,</li>
<li>"donner" l'image à openGL pour qu'il puisse l'utiliser, cf créer un objet openGL texture,</li>
<li>écrire le fragment shader qui change la couleur du pixel en fonction de la couleur d'un pixel de la texture,</li>
<li>configurer le pipeline avant le draw, pour que tout fonctionne...</li>
</ul>
<div class="image">
<img src="bigguy_notexture.png" alt=""/>
<div class="caption">
pas de texture</div></div>
 <div class="image">
<img src="bigguy_texspace.png" alt=""/>
<div class="caption">
à gauche : les sommets dans la texture, à droite : la texture, chaque face de l'objet est associé à un morceau de la texture</div></div>
 <div class="image">
<img src="mesh_kit.png" alt=""/>
<div class="caption">
bigguy texturé</div></div>
<h2><a class="anchor" id="autotoc_md79"></a>
pipeline graphique et textures</h2>
<p>c'est le fragment shader qui donne sa couleur à un pixel de l'image. si l'on souhaite utiliser la couleur d'un pixel de la texture, il faut que le fragment shader puisse lire cette couleur. 2 informations sont nécessaires : la texture elle même et les coordonnées du pixel dans la texture.</p>
<p><em>comment connaitre les coordonnées du pixel dans la texture ?</em> lorsque l'on dessine un triangle, les coordonnées de ses sommets (connues dans le repère de création de l'objet) sont transformées pour déterminer sur quels pixels de l'image résultat se projettent les 3 sommets. puis le pipeline interpole ces coordonnées pixel par pixel pour calculer la profondeur de chaque fragment du triangle (cf. <a class="el" href="group__intro3d.html">introduction api 3d, openGL et pipeline graphique</a> / partie plusieurs triangles). les coordonnées des sommets dans la texture sont eux aussi interpolés, en même temps, et le fragment shader connait les coordonnées du pixel de la texture correspondant au pixel de l'image. il ne reste plus qu'à lire la couleur dans la texture et à l'utiliser pour colorier le pixel de l'image.</p>
<p><em>mais il reste un détail à régler :</em> comme précisé dans <a class="el" href="group__intro3d.html">introduction api 3d, openGL et pipeline graphique</a>, les informations des sommets, les attributs, ne sont pas interpolés automatiquement, il le dire à openGL en déclarant explicitement un varying, une sortie optionnelle du vertex shader et en déclarant l'entrée correspondante dans le fragment shader. plus de détails dans écrire les shaders.</p>
<p><em>autre explication</em> : le fragment shader ne peut pas accéder aux attributs de sommets, il ne sont connus que du vertex shader, il faut donc créer un varying en sortie du vertex shader pour que le fragment shader récupère cette information (associée aux sommets). et les varyings sont interpolés par le pipeline.</p>
<h2><a class="anchor" id="autotoc_md80"></a>
une texture</h2>
<p>on commence par le cas simple, utiliser une seule texture. première étape, charger une image et créer un objet openGL texture qui stocke l'image sous une forme utilisable par les shaders.</p>
<h3><a class="anchor" id="autotoc_md81"></a>
charger une image, créer un objet texture openGL</h3>
<p>pour créer un objet texture, il faut utiliser glGenTextures( ), la démarche est la même que pour les autres objets openGL : </p><div class="fragment"><div class="line">GLuint texture;</div>
<div class="line">glGenTextures(1, &amp;texture);</div>
</div><!-- fragment --><p>maintenant que l'objet est créé, il faut le configurer : quelle type de texture, quelles données, etc, cf la famille de fonctions glTexImage(). mais avant, il faut sélectioner l'objet, cf glBindTexture( ) en fonction du type de texture. les textures les plus courantes sont les textures 2d, GL_TEXTURE_2D, qui correspondent à des images classiques : </p><div class="fragment"><div class="line">glBindTexture(GL_TEXTURE_2D, texture);</div>
</div><!-- fragment --><p>il ne reste plus qu'à définir les dimensions de la texture, largeur et hauteur, ainsi que le type de ses pixels, combien de canaux couleurs et représentés par des float ou des entiers. le cas classique qui correspond aux images stockées aux formats jpg, png, tga, bmp, etc. est 3 ou 4 canaux couleurs stockés sur des octets (non signés) : </p><div class="fragment"><div class="line">glTexImage2D(GL_TEXTURE_2D, </div>
<div class="line">    <span class="comment">/* level */</span> 0,</div>
<div class="line">    <span class="comment">/* texel format */</span> GL_RGBA, </div>
<div class="line">    <span class="comment">/* width, height, border */</span> width, height, 0,</div>
<div class="line">    <span class="comment">/* data format */</span> GL_RGBA, <span class="comment">/* data type */</span> GL_UNSIGNED_BYTE,</div>
<div class="line">    <span class="comment">/* data */</span> pixels);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// nombre de niveaux de la texture : 1 seul, cf level 0</span></div>
<div class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 0);</div>
</div><!-- fragment --><p>en résumé :</p><ul>
<li>le paramètre level est utilisé pour décrire les textures filtrées, cf section texture filtrée et mipmaps, par défaut c'est 0,</li>
<li>le paramètre texel format, désigne le nombre de canaux pour représenter une couleur : 3, GL_RGB pour une couleur opaque et 4, GL_RGBA, pour une couleur semi-transparente,</li>
<li>les paramètres data format, data type, décrivent le format des données transmises à openGL qui est capable de faire plusieurs conversions. par exemple ajouter ou enlever le canal alpha qui décrit des couleurs semi transparentes. les 2 formats ne sont pas nécessairement identiques.</li>
</ul>
<p><b>attention :</b> <code>glTexParameter( )</code> permet de régler plusieurs paramètres modifiant l'accès à la texture. l'exemple ne fournit que les données du level 0. par défaut, openGL utilise plusieurs versions de l'image pour la filtrer : mipmap levels / couches de mipmaps, cf section filtrage et mipmaps. si la ligne <code>glTexParameter(.... GL_TEXTURE_MAX_LEVEL ...)</code> n'est pas présente, vous aurez une texture <b>noire</b>.</p>
<p><em>remarque :</em> il y plusieurs solutions pour régler ce problème, le plus simple est de continuer à lire le tuto...</p>
<p>en pratique, on charge l'image en utilisant une librairie et selon le type des pixels de l'image, il faut configurer correctement le format des données transmises à openGL. gKit utilise SDL2_image pour charger les images et renvoie une structure simplifiée qui contient : largeur, hauteur, nombre de canaux couleurs et les données, cf la classe <a class="el" href="structImageData.html" title="stockage temporaire des donnees d&#39;une image.">ImageData</a> dans <a class="el" href="image__io_8h.html">image_io.h</a>.</p>
<p>du coup, un code pour charger une texture avec gKit ressemble à ça : </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="image__io_8h.html">image_io.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="shader__kit_8cpp.html#a72fad2bb274e5f3b6d190bd860ea63b5">init</a>( )</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">    <a class="code" href="structImageData.html">ImageData</a> image= <a class="code" href="group__image.html#ga1c97c430bfab185be3cb7f01beb3230f">read_image_data</a>(<span class="stringliteral">&quot;toto.png&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// format des données de l&#39;image, couleurs avec 3 canaux, ou 4</span></div>
<div class="line">    GLenum data_format;</div>
<div class="line">    <span class="keywordflow">if</span>(image.channels == 4)</div>
<div class="line">        data_format= GL_RGBA;</div>
<div class="line">    <span class="keywordflow">if</span>(image.channels == 3)</div>
<div class="line">        data_format= GL_RGB;</div>
<div class="line">    <span class="comment">// les formats d&#39;image classiques utilisent tous des octets pour représenter les couleurs.</span></div>
<div class="line">    GLenum data_type= GL_UNSIGNED_BYTE; </div>
<div class="line">    </div>
<div class="line">    <span class="comment">// selectionner la texture, si necessaire</span></div>
<div class="line">    <span class="comment">// glBindTexture(GL_TEXTURE_2D, texture);</span></div>
<div class="line">    </div>
<div class="line">    glTexImage2D(GL_TEXTURE_2D, 0,</div>
<div class="line">        GL_RGBA,</div>
<div class="line">        image.width, image.height, 0,</div>
<div class="line">        data_format, data_type,</div>
<div class="line">        image.buffer());</div>
<div class="line">    </div>
<div class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 0);</div>
<div class="line">    ...</div>
</div><!-- fragment --><p>et comme c'est toujours la même chose, <code><a class="el" href="group__openGL.html#ga1eca5a39194ea7d085b92af57f2f8884">make_texture( )</a></code> et <code><a class="el" href="group__openGL.html#gab752f06d2afe33f1e865d7c4dce5fa4f">read_texture( )</a></code> de <a class="el" href="texture_8h.html">texture.h</a> font exactement ça.</p>
<h3><a class="anchor" id="autotoc_md82"></a>
décrire les coordonnées de texture des sommets de l'objet</h3>
<p>deuxième étape : fournir les coordonnées dans la texture des sommets de l'objet, il faut les stocker dans un vertex buffer et décrire correctement le format de sommet (cf <a class="el" href="group__tuto4GL.html">configurer un format de sommet, vertex array object</a>).</p>
<p>le cas simple est de créer un nouveau buffer pour stocker les coordonnées : </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="shader__kit_8cpp.html#a72fad2bb274e5f3b6d190bd860ea63b5">init</a>( )</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">    <a class="code" href="classMesh.html">Mesh</a> mesh= { ... };</div>
<div class="line"> </div>
<div class="line">    GLuint texcoord_buffer;</div>
<div class="line">    glGenBuffers(1, &amp;texcoord_buffer);</div>
<div class="line">    glBindBuffer(GL_ARRAY_BUFFER);</div>
<div class="line">    glBufferData(GL_ARRAY_BUFFER, mesh.<a class="code" href="classMesh.html#a06943d2f4e1a6c64c62d37945c3b3fa8">texcoord_buffer_size</a>(), mesh.<a class="code" href="classMesh.html#a9bced8c208ebf7c0beea03f48d77eead">texcoord_buffer</a>(), GL_STATIC_DRAW);</div>
<div class="line">    ...</div>
</div><!-- fragment --><p>et d'ajouter cet attribut au format de sommet : </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="shader__kit_8cpp.html#a72fad2bb274e5f3b6d190bd860ea63b5">init</a>( )</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">    GLuint vao= { ... };</div>
<div class="line">    GLuint program= { ... };</div>
<div class="line">    GLuint texcoord_buffer= { ... };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// selectionner le vertex array object, si necessaire</span></div>
<div class="line">    <span class="comment">// glBindVertexArray(vao);</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// recupere l&#39;identifiant de l&#39;attribut declare dans le vertex shader</span></div>
<div class="line">    GLint texcoord_attribute= glGetAttribLocation(program, <span class="stringliteral">&quot;texcoord&quot;</span>);</div>
<div class="line">    <span class="keywordflow">if</span>(texcoord_attribute &lt; 0)</div>
<div class="line">        <span class="comment">// probleme, l&#39;attribut n&#39;existe pas</span></div>
<div class="line">        </div>
<div class="line">    <span class="comment">// selectionner le buffer, si necessaire</span></div>
<div class="line">    <span class="comment">// glBindBuffer(GL_ARRAY_BUFFER, texcoord_buffer);</span></div>
<div class="line">    glVertexAttribPointer(texcoord_attribute, 2, GL_FLOAT, GL_FALSE, 0, 0);</div>
<div class="line">    glEnableVertexAttribArray(texcoord_attribute);</div>
<div class="line">    ...</div>
</div><!-- fragment --><p><em>remarque :</em> les coordonnées dans la texture sont en 2d, comme on peut s'y attendre, cf 2, GL_FLOAT pour openGL et <a class="el" href="structvec2.html" title="vecteur generique, utilitaire.">vec2</a> pour GLSL (les shaders) pour les représenter.</p>
<p><em>attention :</em> l'api openGL et le langage des shaders, GLSL, n'appellent pas les types de la même manière, un <a class="el" href="structvec2.html" title="vecteur generique, utilitaire.">vec2</a> GLSL est décrit comme 2, GL_FLOAT dans l'application pour l'api openGL. un <a class="el" href="structvec3.html" title="vecteur generique, utilitaire.">vec3</a> GLSL, est décrit par 3, GL_FLOAT, etc.</p>
<h3><a class="anchor" id="autotoc_md83"></a>
écrire le fragment shader (et le vertex shader)</h3>
<p>troisième étape, les shaders !</p>
<p>première chose à faire, modifier le vertex shader pour qu'il récupère les coordonnées de texture et les transmette au fragment shader.</p>
<p>le vertex shader déclare un attribut, texcoord par exemple et un varying, une sortie optionnelle, vertex_texcoord : (repassez dans <a class="el" href="group__intro3d.html">introduction api 3d, openGL et pipeline graphique</a> et <a class="el" href="group__glsl.html">shaders et GLSL</a>, si nécessaire)</p>
<div class="fragment"><div class="line"><span class="comment">// vertex shader</span></div>
<div class="line"><span class="preprocessor">#version 330</span></div>
<div class="line"> </div>
<div class="line">in <a class="code" href="structvec2.html">vec2</a> texcoord;   <span class="comment">// attribut </span></div>
<div class="line"> </div>
<div class="line">out <a class="code" href="structvec2.html">vec2</a> vertex_texcoord;   <span class="comment">// varying, sortie du vertex shader</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main( )</div>
<div class="line">{</div>
<div class="line">    ... </div>
<div class="line">    <span class="comment">// transmettre les coordonnees de texture au fragment shader</span></div>
<div class="line">    vertex_texcoord= texcoord;</div>
<div class="line">}</div>
</div><!-- fragment --><p>de son coté, le fragment shader récupère les coordonnées avec le varying vertex_texcoord : </p><div class="fragment"><div class="line"><span class="comment">// fragment shader</span></div>
<div class="line"><span class="preprocessor">#version 330</span></div>
<div class="line"> </div>
<div class="line">in <a class="code" href="structvec2.html">vec2</a> vertex_texcoord;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main( )</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>il ne reste plus qu'à lire la couleur de la texture aux coordonnées stockées dans vertex_texcoord... c'est la famille de fonctions texture( ) de GLSL qui permet de le faire. le premier paramètre de texture( ) est un paramètre uniform dont le type dépend du type de la texture : pour une texture 2D, c'est sampler2D. texture( ) renvoie un <a class="el" href="structvec4.html" title="vecteur generique 4d, ou 3d homogene, utilitaire.">vec4</a> qui correspond aux 4 canaux de la couleur : rgb et a.</p>
<p><em>remarque :</em> même si la texture ne contient pas 4 canaux pour décrire une couleur, la fonction texture() renvoie toujours un <a class="el" href="structvec4.html" title="vecteur generique 4d, ou 3d homogene, utilitaire.">vec4</a>, les composantes non utilisées ont une valeur par défaut (0 pour rgb et 1 pour a). exemple : une texture GL_RG, qui ne contient que 2 canaux, renverra <code><a class="el" href="structvec4.html" title="vecteur generique 4d, ou 3d homogene, utilitaire.">vec4(r, g, 0, 1)</a>;</code></p>
<p><em>remarque :</em> <code>texture( )</code> suppose que les coordonnées de texture sont normalisées entre 0 et 1, ce qui permet d'oublier les dimensions de l'image... les coordonnées stockées dans les fichiers <code>.obj</code> sont normalisées, en général. mais il existe d'autres fonctions, comme <code>texelFetch()</code> qui utilisent directement les dimensions de l'image.</p>
<div class="fragment"><div class="line"><span class="comment">// fragment shader</span></div>
<div class="line"><span class="preprocessor">#version 330</span></div>
<div class="line"> </div>
<div class="line">in <a class="code" href="structvec2.html">vec2</a> vertex_texcoord;</div>
<div class="line"> </div>
<div class="line">uniform sampler2D diffuse_color;    <span class="comment">// declare une texture 2d</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main( )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// recupere la couleur dans la texture diffuse_color aux coordonnées vertex_texcoord</span></div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a> color= texture(diffuse_color, vertex_texcoord);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// renvoie la couleur du fragment</span></div>
<div class="line">    gl_FragColor= color;</div>
<div class="line">}</div>
</div><!-- fragment --><p>au final, les 2 shaders ressemblent à ça : </p><div class="fragment"><div class="line"><span class="preprocessor">#version 330</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef VERTEX_SHADER</span></div>
<div class="line"><span class="comment">// vertex shader</span></div>
<div class="line"> </div>
<div class="line">in <a class="code" href="structvec3.html">vec3</a> position;</div>
<div class="line">in <a class="code" href="structvec2.html">vec2</a> texcoord;</div>
<div class="line"> </div>
<div class="line">uniform mvpMatrix;</div>
<div class="line"> </div>
<div class="line">out <a class="code" href="structvec2.html">vec2</a> vertex_texcoord;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main( )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// transformation des coordonnees (spatiales) du sommet</span></div>
<div class="line">    gl_Position= mvpMatrix * <a class="code" href="structvec4.html">vec4</a>(position, 1.0);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// transmet les coordonnees de texture au fragment shader</span></div>
<div class="line">    vertex_texcoord= texcoord;</div>
<div class="line">}</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef FRAGMENT_SHADER</span></div>
<div class="line"><span class="comment">// fragment shader</span></div>
<div class="line"> </div>
<div class="line">in <a class="code" href="structvec2.html">vec2</a> vertex_texcoord;</div>
<div class="line"> </div>
<div class="line">uniform sampler2D diffuse_color;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main( )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// recupere la couleur dans la texture diffuse_color aux coordonnées vertex_texcoord</span></div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a> color= texture(diffuse_color, vertex_texcoord);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// renvoie la couleur du fragment</span></div>
<div class="line">    gl_FragColor= color;</div>
<div class="line">}</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p>il ne reste plus qu'à configurer le pipeline pour dessiner un objet texturé !</p>
<h3><a class="anchor" id="autotoc_md84"></a>
configurer le pipeline</h3>
<p>quatrième étape, configurer le pipeline :</p><ul>
<li>vertex array object, configuration du format de sommet, cf glBindVertexArray( ),</li>
<li>shader program, cf glUseProgram( ),</li>
<li>uniforms du program, cf glUniform(),</li>
<li>texture utilisée par le fragment shader, cf glBindTexture( ),</li>
<li>glDraw( )</li>
</ul>
<p>qu'est qui a changé ?</p><ul>
<li>le vao contient plus d'informations, mais son utilisation ne change pas : <code>glBindVertexArray(vao);</code></li>
<li>le shader program aussi à changé, mais pas son utilisation : <code>glUseProgram(program);</code></li>
<li>par contre, il y a un uniform de plus à configurer : le sampler2D du fragment shader: <code>glUniform1i(location, value);</code></li>
<li>et bien sur, il faut sélectionner la texture qui doit être lue par le fragment shader, <code>glBindTexture(GL_TEXTURE_2D, texture);</code></li>
<li>glDraw(), rien n'a changé.</li>
</ul>
<p>pour sélectionner la texture, c'est glBindTexture(), comme lors de sa création. l'uniform est un peu particulier, pour le shader c'est un <code>sampler2D</code> et pour l'application c'est un <code>int</code> qui représente l'indice de l'unité de texture. par défaut, lorsque l'application n'utilise qu'une texture, c'est 0.</p>
<p>au final : configurer le pipeline pour utiliser une texture dans le fragment shader ressemble à ça : </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> draw( )</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">    glBindVertexArray(vao);</div>
<div class="line">    glUseProgram(program);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// configurer les uniforms habituels, matrices, etc :</span></div>
<div class="line">    { ... }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// configurer le sampler :</span></div>
<div class="line">    GLint location= glGetUniformLocation(program, <span class="stringliteral">&quot;diffuse_color&quot;</span>);</div>
<div class="line">    glUniform1i(location, 0);   <span class="comment">// une seule texture utilisee, 0 dans ce cas</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// selectionner la texture :</span></div>
<div class="line">    glBindTexture(GL_TEXTURE_2D, texture);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// go</span></div>
<div class="line">    glDrawArrays(GL_TRIANGLES, 0, count);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
</div><!-- fragment --><p>le code complet ressemble a <a class="el" href="tuto5GL_8cpp.html">tuto5GL.cpp</a></p>
<h2><a class="anchor" id="autotoc_md85"></a>
texture filtrée et mipmaps...</h2>
<p>comme suggéré dans la section création des textures, une texture est composée de plusieurs niveaux / couches... <em>pourquoi ?</em></p>
<p>lorsqu'on observe un triangle "à la bonne distance", un pixel de l'image correspond à un pixel de la texture. dans ce cas, l'affichage est propre.</p>
<p>par contre, si on s'éloigne, plusieurs pixels de la texture se projettent sur un pixel de l'image. quelle couleur donner au pixel de l'image ? la bonne réponse est : la moyenne des couleurs des pixels de la texture qui se projettent dans le même pixel de l'image. mais cette solution pose un gros problème : plus l'objet est loin, plus il faut de pixels de la texture pour calculer la moyenne, et plus le calcul est long. pour éviter ce ralentissement en fonction de la distance, on peut précalculer les moyennes à des résolutions différentes : pour des blocs de 2x2 pixels, de 4x4, de 8x8, de 16x16, etc. et choisir la bonne taille de bloc qui contient la moyenne précalculée. openGL appelle ces versions <em>pré-filtrées</em> ou pré-calculées de la texture des mipmaps.</p>
<p>pour décrire complètement une texture à openGL, il faut donner toutes ces versions pré-calculées de l'image, donc plusieurs levels pour une résolution de base. pour une image 1024x1024, il faudra les versions 512x512, 256x256, 128x128, etc. jusqu'a 1x1. c'est un peu long à écrire, mais pas difficile : </p><div class="fragment"><div class="line"><a class="code" href="structImageData.html">ImageData</a> image= <a class="code" href="group__image.html#ga1c97c430bfab185be3cb7f01beb3230f">read_image_data</a>( <span class="stringliteral">&quot;...&quot;</span> );</div>
<div class="line"> </div>
<div class="line">GLenum data_type= GL_UNSIGNED_BYTE; </div>
<div class="line">GLenum data_format= GL_RGBA;</div>
<div class="line"><span class="keywordflow">if</span>(image.channels == 3)</div>
<div class="line">    data_format= GL_RGB;</div>
<div class="line"> </div>
<div class="line">GLuint texture;</div>
<div class="line">glGenTextures(1, &amp;texture);</div>
<div class="line">glBindTexture(GL_TEXTURE_2D, texture);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// determine le nombre de niveaux en fonction des dimensions de l&#39;image </span></div>
<div class="line"><span class="keywordtype">int</span> levels= <a class="code" href="group__openGL.html#gacbb61fabb4b3d5d9cfada3223c609f67">miplevels</a>(image.width, image.height);   </div>
<div class="line"> </div>
<div class="line"><span class="comment">// calculer les versions pre filtrées d&#39;une texture </span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i= 0; i &lt; levels; i++)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// calcule le niveau i de l&#39;image</span></div>
<div class="line">    <a class="code" href="structImageData.html">ImageData</a> level= make_miplevel(image, i);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// transmet la version pre filtree</span></div>
<div class="line">    glTexImage2D(GL_TEXTURE_2D, i,</div>
<div class="line">        GL_RGBA, level.width, level.height, 0,</div>
<div class="line">        data_format, data_type, levelbuffer());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// nombre de mipmaps initialisés</span></div>
<div class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, levels);</div>
</div><!-- fragment --><p><em>remarque :</em> pour une image rectangulaire, par exemple 1024x512, les versions sont 512x256, 256x128, etc. 2x1 et 1x1</p>
<p><em>remarque :</em> le niveau 0 est l'image complète, le niveau 1 l'image pré filtrée dont la résolution est divisée par 2 sur chaque axe, etc. en résumé, le niveau level à des dimensions : \( \mbox{width}= \mbox{image.width} / 2^{level} \), et \( \mbox{height}= \mbox{image.height} / 2^{level} \). ce qui s'écrit directement : </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> width= <a class="code" href="group__math.html#ga5e9f1c9053edf88cc41f28c98a077f55">std::max</a>(1, image.width / (1 &lt;&lt; level));         <span class="comment">// la notation (1 &lt;&lt; n) calcule 2^n, pourquoi ?</span></div>
<div class="line"><span class="keywordtype">int</span> height= <a class="code" href="group__math.html#ga5e9f1c9053edf88cc41f28c98a077f55">std::max</a>(1, image.height / (1 &lt;&lt; level));</div>
</div><!-- fragment --><p><em>remarque :</em> on peut écrire la fonction <a class="el" href="group__openGL.html#gacbb61fabb4b3d5d9cfada3223c609f67" title="renvoie le nombre de mipmap d&#39;une image width x height.">miplevels()</a> simplement avec une boucle : </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="group__openGL.html#gacbb61fabb4b3d5d9cfada3223c609f67">miplevels</a>( <span class="keyword">const</span> <span class="keywordtype">int</span> width, <span class="keyword">const</span> <span class="keywordtype">int</span> height )</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> w= width;</div>
<div class="line">    <span class="keywordtype">int</span> h= height;</div>
<div class="line">    <span class="keywordtype">int</span> levels= 1;</div>
<div class="line">    <span class="keywordflow">while</span>(w &gt; 1 || h &gt; 1)</div>
<div class="line">    {</div>
<div class="line">        w= <a class="code" href="group__math.html#ga5e9f1c9053edf88cc41f28c98a077f55">std::max</a>(w / 2, 1);</div>
<div class="line">        h= <a class="code" href="group__math.html#ga5e9f1c9053edf88cc41f28c98a077f55">std::max</a>(h / 2, 1);</div>
<div class="line">        levels= levels + 1;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> levels;</div>
<div class="line">}</div>
</div><!-- fragment --><p><em>exercice :</em> ecrivez la fonction <code>make_miplevel( const ImageData&amp; image, const int level )</code>.</p>
<p>mais il y a encore plus simple, il suffit de demander à openGL de faire les pré-calculs ! cf glGenerateMipmap( ) : </p><div class="fragment"><div class="line"><a class="code" href="structImageData.html">ImageData</a> image= <a class="code" href="group__image.html#ga1c97c430bfab185be3cb7f01beb3230f">read_image_data</a>( <span class="stringliteral">&quot;...&quot;</span> );</div>
<div class="line"> </div>
<div class="line">GLenum data_type= GL_UNSIGNED_BYTE; </div>
<div class="line">GLenum data_format= GL_RGBA;</div>
<div class="line"><span class="keywordflow">if</span>(image.channels == 3)</div>
<div class="line">    data_format= GL_RGB;</div>
<div class="line"> </div>
<div class="line">GLuint texture;</div>
<div class="line">glGenTextures(1, &amp;texture);</div>
<div class="line">glBindTexture(GL_TEXTURE_2D, texture);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// transmet uniquement l&#39;image pleine resolution, level 0</span></div>
<div class="line">glTexImage2D(GL_TEXTURE_2D, 0,</div>
<div class="line">    GL_RGBA, image.width, image.height, 0,</div>
<div class="line">    data_format, data_type, image.buffer());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// precalcule les autres nvieaux </span></div>
<div class="line">glGenerateMipmap(GL_TEXTURE_2D);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// optionnel ? à vérifier</span></div>
<div class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, <a class="code" href="group__openGL.html#gacbb61fabb4b3d5d9cfada3223c609f67">miplevels</a>(image.wdith, image.height));</div>
</div><!-- fragment --><p>comme ces niveaux de mipmaps ne sont qu'une approximation du vrai calcul, il y a des manières différentes de les utiliser et il faut donc configurer le pipeline... et comme il y a pas mal d'options, elles sont regroupées dans un objet openGL, un sampler, qu'il faut créer, cf glGenSamplers() et configurer, cf glSamplerParameter( ).</p>
<p>voici les paramètres par défaut qu'utilise openGL ; </p><div class="fragment"><div class="line">GLuint sampler;</div>
<div class="line">glGenSamplers(1, &amp;sampler);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// minification filter : quel niveau de mipmap choisir (l&#39;interpolation des 2 plus proches) et quel pixel choisir (ou l&#39;interpolation des 4 voisins)</span></div>
<div class="line">glSamplerParameteri(sampler, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// magnification filter : interpoler (GL_LINEAR) ou pas (GL_NEAREST) les 4 pixels voisins</span></div>
<div class="line">glSamplerParameteri(sampler, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// quoi faire si les 4 pixels voisins sont, en partie, sur le bord de la texture, utiliser la couleur de la bordure, noir par defaut</span></div>
<div class="line"><span class="comment">// pour l&#39;axe s, vers la gauche (ou x)</span></div>
<div class="line">glSamplerParameteri(sampler, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);</div>
<div class="line"><span class="comment">// pour l&#39;axe t, vers le haut (ou y)</span></div>
<div class="line">glSamplerParameteri(sampler, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);</div>
</div><!-- fragment --><p>il faut aussi configurer le pipeline lors du glDraw( ), cf glBindSampler( ). lorsqu'il n'y a qu'une seule texture : </p><div class="fragment"><div class="line">glBindSampler(0, sampler);</div>
</div><!-- fragment --><p>au final, le code complet ressemble à <a class="el" href="tuto5GL__sampler_8cpp.html">tuto5GL_sampler.cpp</a></p>
<h2><a class="anchor" id="autotoc_md86"></a>
plusieurs textures</h2>
<p>lorsqu'un fragment shader veut utiliser plusieurs textures en même temps pour calculer la couleur d'un pixel, openGL utilise le même principe que pour les attributs de sommets : elles sont numérotées. les textures et leurs paramètres de filtrage (sampler) sont décrits dans plusieurs <em>unités de textures</em>. le fragment shader est configuré (l'uniform sampler2D déclaré par le shader) avec l'indice de l'unité sur laquelle est sélectionnée la texture et ses paramètres de filtrage.</p>
<p>openGL définit entre 16 et 32 unités de texture, il suffit de les sélectionner avec glActiveTexture( ) et de les configurer 'normalement' avec glBindTexture( ), et glBindSampler( ). </p><div class="fragment"><div class="line"><span class="comment">// selectionne l&#39;unite 0</span></div>
<div class="line">glActiveTexture(GL_TEXTURE0);</div>
<div class="line"> </div>
<div class="line">glBindTexture(GL_TEXTURE_2D, base_texture); <span class="comment">// selectionne la texture sur l&#39;unite 0</span></div>
<div class="line">glBindSampler(0, sampler);                  <span class="comment">// selectionne un sampler (paramètres de filtrage) sur l&#39;unité 0    </span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// selectionne l&#39;unite 1</span></div>
<div class="line">glActiveTexture(GL_TEXTURE1);</div>
<div class="line">glBindTexture(GL_TEXTURE_2D, detail_texture);</div>
<div class="line">glBindSampler(1, sampler)</div>
<div class="line">...</div>
</div><!-- fragment --><p><b>attention :</b> la numérotation des unités de texture n'est pas très cohérente, c'est <code>GL_TEXTURE0</code>, <code>GL_TEXTURE1</code>, etc. pour <code>glActiveTexture( )</code> et <code>0</code>, <code>1</code> pour <code>glBindSampler( )</code></p>
<p>exemple : </p><div class="fragment"><div class="line"><span class="preprocessor">#version 330</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef FRAGMENT_SHADER  </span></div>
<div class="line"><span class="comment">// fragment shader</span></div>
<div class="line"> </div>
<div class="line">in <a class="code" href="structvec2.html">vec2</a> vertex_texcoord;</div>
<div class="line"> </div>
<div class="line">uniform sampler2D base_texture;</div>
<div class="line">uniform sampler2D detail_texture;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main( )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// exemple : detail module la couleur de base...</span></div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a> color= texture(base_texture, vertex_texcoord);</div>
<div class="line">    color= color * texture(detail_texture, vertex_texcoord);</div>
<div class="line">    </div>
<div class="line">    gl_FragColor= color;</div>
<div class="line">}</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p>et dans l'application, il faut bien sur créer les 2 textures, créer au moins un sampler, puis configurer le pipeline pour le draw.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="texture_8h.html">texture.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line">GLuint base_texture;</div>
<div class="line">GLuint detail_texture;</div>
<div class="line">GLuint sampler;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="shader__kit_8cpp.html#a72fad2bb274e5f3b6d190bd860ea63b5">init</a>( )</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">    <span class="comment">// cree la texture sur l&#39;unite 0</span></div>
<div class="line">    base_texture= <a class="code" href="group__openGL.html#gab752f06d2afe33f1e865d7c4dce5fa4f">read_texture</a>(0, <span class="stringliteral">&quot;...&quot;</span>);</div>
<div class="line">    <span class="comment">// cree la texture sur l&#39;unite 0</span></div>
<div class="line">    detail_texture= <a class="code" href="group__openGL.html#gab752f06d2afe33f1e865d7c4dce5fa4f">read_texture</a>(0, <span class="stringliteral">&quot;...&quot;</span>);</div>
<div class="line">    ...</div>
<div class="line">    <span class="comment">// cree le sampler</span></div>
<div class="line">    glGenSamplers(1, &amp;sampler);</div>
<div class="line">    glSamplerParameteri(sampler, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);</div>
<div class="line">    glSamplerParameteri(sampler, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</div>
<div class="line">    glSamplerParameteri(sampler, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);</div>
<div class="line">    glSamplerParameteri(sampler, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);</div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keywordtype">int</span> draw( )</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">    <span class="comment">/* configuration du pipeline </span></div>
<div class="line"><span class="comment">        vertex array</span></div>
<div class="line"><span class="comment">        program</span></div>
<div class="line"><span class="comment">        uniforms &quot;classiques&quot;, matrices, etc.</span></div>
<div class="line"><span class="comment">        uniform sampler</span></div>
<div class="line"><span class="comment">        unites de textures</span></div>
<div class="line"><span class="comment">        draw( )</span></div>
<div class="line"><span class="comment">      */</span></div>
<div class="line">    glBindVertexArray(vao);</div>
<div class="line">    glUseProgram(program);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// uniforms classiques</span></div>
<div class="line">    { ... }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// uniform samplers</span></div>
<div class="line">    GLint location;</div>
<div class="line">    location= glGetUniformLocation(program, <span class="stringliteral">&quot;base_texture&quot;</span>);</div>
<div class="line">    glUniform1i(location, 0);   <span class="comment">// utilise la texture selectionnee sur l&#39;unite 0</span></div>
<div class="line">    </div>
<div class="line">    location= glGetUniformLocation(program, <span class="stringliteral">&quot;detail_texture&quot;</span>);</div>
<div class="line">    glUniform1i(location, 1);   <span class="comment">// utilise la texture selectionnee sur l&#39;unite 1</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// configure l&#39;unite 0</span></div>
<div class="line">    glAciveTexture(GL_TEXTURE0);</div>
<div class="line">    glBindTexture(GL_TEXTURE_2D, base_texture);</div>
<div class="line">    glBindSampler(0, sampler);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// configure l&#39;unite 1</span></div>
<div class="line">    glAciveTexture(GL_TEXTURE0 + 1);</div>
<div class="line">    glBindTexture(GL_TEXTURE_2D, detail_texture);</div>
<div class="line">    glBindSampler(1, sampler);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// go</span></div>
<div class="line">    glDrawArrays(GL_TRIANGLES, 0, vertex_count);</div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>code complet dans <a class="el" href="tuto5GL__multi_8cpp.html">tuto5GL_multi.cpp</a> </p>
</div><!-- contents -->
<div class="ttc" id="agroup__image_html_ga1c97c430bfab185be3cb7f01beb3230f"><div class="ttname"><a href="group__image.html#ga1c97c430bfab185be3cb7f01beb3230f">read_image_data</a></div><div class="ttdeci">ImageData read_image_data(const char *filename)</div><div class="ttdoc">charge les donnees d'un fichier png. renvoie une image initialisee par defaut en cas d'echec.</div><div class="ttdef"><b>Definition:</b> <a href="image__io_8cpp_source.html#l00139">image_io.cpp:139</a></div></div>
<div class="ttc" id="agroup__openGL_html_gacbb61fabb4b3d5d9cfada3223c609f67"><div class="ttname"><a href="group__openGL.html#gacbb61fabb4b3d5d9cfada3223c609f67">miplevels</a></div><div class="ttdeci">int miplevels(const int width, const int height)</div><div class="ttdoc">renvoie le nombre de mipmap d'une image width x height.</div><div class="ttdef"><b>Definition:</b> <a href="texture_8cpp_source.html#l00010">texture.cpp:10</a></div></div>
<div class="ttc" id="ashader__kit_8cpp_html_a72fad2bb274e5f3b6d190bd860ea63b5"><div class="ttname"><a href="shader__kit_8cpp.html#a72fad2bb274e5f3b6d190bd860ea63b5">init</a></div><div class="ttdeci">int init(std::vector&lt; const char * &gt; &amp;options)</div><div class="ttdef"><b>Definition:</b> <a href="shader__kit_8cpp_source.html#l00094">shader_kit.cpp:94</a></div></div>
<div class="ttc" id="astructvec3_html"><div class="ttname"><a href="structvec3.html">vec3</a></div><div class="ttdoc">vecteur generique, utilitaire.</div><div class="ttdef"><b>Definition:</b> <a href="vec_8h_source.html#l00144">vec.h:144</a></div></div>
<div class="ttc" id="astructvec2_html"><div class="ttname"><a href="structvec2.html">vec2</a></div><div class="ttdoc">vecteur generique, utilitaire.</div><div class="ttdef"><b>Definition:</b> <a href="vec_8h_source.html#l00129">vec.h:129</a></div></div>
<div class="ttc" id="aclassMesh_html_a06943d2f4e1a6c64c62d37945c3b3fa8"><div class="ttname"><a href="classMesh.html#a06943d2f4e1a6c64c62d37945c3b3fa8">Mesh::texcoord_buffer_size</a></div><div class="ttdeci">std::size_t texcoord_buffer_size() const</div><div class="ttdoc">renvoie la taille (en octets) du texcoord buffer.</div><div class="ttdef"><b>Definition:</b> <a href="mesh_8h_source.html#l00271">mesh.h:271</a></div></div>
<div class="ttc" id="aimage__io_8h_html"><div class="ttname"><a href="image__io_8h.html">image_io.h</a></div></div>
<div class="ttc" id="aclassMesh_html"><div class="ttname"><a href="classMesh.html">Mesh</a></div><div class="ttdoc">representation d'un objet / maillage.</div><div class="ttdef"><b>Definition:</b> <a href="mesh_8h_source.html#l00108">mesh.h:108</a></div></div>
<div class="ttc" id="agroup__openGL_html_gab752f06d2afe33f1e865d7c4dce5fa4f"><div class="ttname"><a href="group__openGL.html#gab752f06d2afe33f1e865d7c4dce5fa4f">read_texture</a></div><div class="ttdeci">GLuint read_texture(const int unit, const char *filename, const GLenum texel_type)</div><div class="ttdef"><b>Definition:</b> <a href="texture_8cpp_source.html#l00098">texture.cpp:98</a></div></div>
<div class="ttc" id="atexture_8h_html"><div class="ttname"><a href="texture_8h.html">texture.h</a></div></div>
<div class="ttc" id="astructvec4_html"><div class="ttname"><a href="structvec4.html">vec4</a></div><div class="ttdoc">vecteur generique 4d, ou 3d homogene, utilitaire.</div><div class="ttdef"><b>Definition:</b> <a href="vec_8h_source.html#l00166">vec.h:166</a></div></div>
<div class="ttc" id="agroup__math_html_ga5e9f1c9053edf88cc41f28c98a077f55"><div class="ttname"><a href="group__math.html#ga5e9f1c9053edf88cc41f28c98a077f55">max</a></div><div class="ttdeci">Point max(const Point &amp;a, const Point &amp;b)</div><div class="ttdoc">renvoie la plus grande composante de chaque point. x, y, z= max(a.x, b.x), max(a.y,...</div><div class="ttdef"><b>Definition:</b> <a href="vec_8cpp_source.html#l00035">vec.cpp:35</a></div></div>
<div class="ttc" id="aclassMesh_html_a9bced8c208ebf7c0beea03f48d77eead"><div class="ttname"><a href="classMesh.html#a9bced8c208ebf7c0beea03f48d77eead">Mesh::texcoord_buffer</a></div><div class="ttdeci">const float * texcoord_buffer() const</div><div class="ttdoc">renvoie l'adresse des coordonnees de textures du premier sommet. par convention, c'est un vec2,...</div><div class="ttdef"><b>Definition:</b> <a href="mesh_8h_source.html#l00269">mesh.h:269</a></div></div>
<div class="ttc" id="astructImageData_html"><div class="ttname"><a href="structImageData.html">ImageData</a></div><div class="ttdoc">stockage temporaire des donnees d'une image.</div><div class="ttdef"><b>Definition:</b> <a href="image__io_8h_source.html#l00023">image_io.h:23</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 9 2019 15:39:11 for gKit2 light by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
