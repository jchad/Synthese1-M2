<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gKit2 light: openGL 4.3 : compute shaders</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">gKit2 light
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">openGL 4.3 : compute shaders</div>  </div>
</div><!--header-->
<div class="contents">
<h3><a class="anchor" id="autotoc_md17"></a>
compute shader ? qu'est ce que c'est ?</h3>
<p>des shaders qui calculent ensemble ? ils ne font pas parti du pipeline graphique classique, mais ils utilisent aussi des buffers, et des textures pour lire les donnéees et écrire les résultats. La principale différence avec les fragment shaders est qu'ils peuvent communiquer et échanger des données.</p>
<h3><a class="anchor" id="autotoc_md18"></a>
comment ça marche ?</h3>
<p>les compute shaders s'exécutent par groupe, chaque shader peut être vu comme un thread, et un groupe de threads est mis en exécution sur un processeur graphique. Chaque thread peut communiquer avec les autres threads de son groupe, ils partagent des ressources (mémoire commune, unités de texture, cache de données, etc.)</p>
<p>chaque thread est numéroté : globalement et dans son groupe, et connaissant son numero, il peut décider de la tâche à exécuter. Ce type d'organisation correspond au parallélisme de données... la même tâche est réalisée sur un ensemble de données, et chaque donnée est traitée par un thread.</p>
<p>exemple : transformer les N sommets d'un maillage. le code séquentiel est sans surprises : </p><div class="fragment"><div class="line"><a class="code" href="structvec4.html">vec4</a> positions[N]</div>
<div class="line"><a class="code" href="structvec4.html">vec4</a> output[N]</div>
<div class="line">mat4 mvp</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> <span class="keywordtype">id</span>= 0; <span class="keywordtype">id</span> &lt; N; <span class="keywordtype">id</span>++)</div>
<div class="line">    output[<span class="keywordtype">id</span>]= mvp * positions[<span class="keywordtype">id</span>]</div>
</div><!-- fragment --><p>la version compute shader est différente, chaque thread traite un seul sommet et il faut ordonnancer l'exécution de N threads. <code>GlobalID</code> est le numéro (global) du thread : </p><div class="fragment"><div class="line"><a class="code" href="structvec4.html">vec4</a> positions[N]</div>
<div class="line"><a class="code" href="structvec4.html">vec4</a> output[N]</div>
<div class="line">mat4 mvp</div>
<div class="line"> </div>
<div class="line">layout(local_size= 64)</div>
<div class="line">void main( )</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keywordtype">id</span>= GlobalID</div>
<div class="line">    <span class="keywordflow">if</span>(<span class="keywordtype">id</span> &lt; N)</div>
<div class="line">        output[id]= mvp * positions[id]</div>
<div class="line">}</div>
</div><!-- fragment --><p>l'exécution du shader est controlée par l'application qui demande à exécuter suffisament de groupes de shaders pour transformer tous les sommets, et c'est le shader qui déclare la taille d'un groupe, cf <code>layout(local_size= ...)</code>. Il est donc fréquent de provoquer l'exécution de quelques shaders de trop, à cause de l'arrondi à la taille du groupe, ce qui explique le <code>if(id &lt; N)</code>... </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> N= ...;</div>
<div class="line"><span class="keywordtype">int</span> groups= (N + 64) / 64   <span class="comment">// faux pour les multiples de 64...</span></div>
<div class="line">Dispatch(groups)</div>
</div><!-- fragment --><p><b>remarque :</b> les processeurs graphiques sont conçus pour exécuter efficacement plusieurs millions de threads...</p>
<p>Pour vérifier, il est possible de récupérer le nombre max de threads par groupe et le nombre max de groupes : </p><div class="fragment"><div class="line">GLint threads_max= 0;</div>
<div class="line">glGetIntegerv(GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS, &amp;threads_max);</div>
</div><!-- fragment --><div class="fragment"><div class="line">GLint groups_max[3]= { };</div>
<div class="line">glGetIntegeri_v(GL_MAX_COMPUTE_WORK_GROUP_COUNT, 0, &amp;groups_max[0]);</div>
<div class="line">glGetIntegeri_v(GL_MAX_COMPUTE_WORK_GROUP_COUNT, 1, &amp;groups_max[1]);</div>
<div class="line">glGetIntegeri_v(GL_MAX_COMPUTE_WORK_GROUP_COUNT, 2, &amp;groups_max[2]);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md19"></a>
parallélisme de données</h3>
<p>Tous les algorithmes ne sont pas aussi simples que transformer tous les sommets d'un maillage, calculer une couleur pour tous les pixels d'une image. Dans ces 2 cas, il y a le même nombre de résultats que de données et chaque thread n'écrit qu'un seul résultat et la place du résultat de chaque thread est connue à l'avance. Il n'y a pas partage des données ou des résultats.</p>
<p>Souvent le nombre de résultats est différent du nombre d'entrées. Dans ce cas, une solution consiste à ne créer qu'un thread par résultat, pour conserver la séparation des données. Mais ce n'est pas toujours efficace. Par exemple, calculer la plus petite valeur d'un ensemble.... un seul thread ne permet pas de paralléliser le calcul. La solution est classique, il suffit de découper le problème, de paralléliser l'exécution de chaque sous problème et de fusionner les résultats partiels. Ce type d'algorithme, cette décomposition, s'appelle une réduction. Chaque groupe de threads peut calculer la plus petite valeur d'un sous-ensemble des données et ensuite les différents groupes calculent la plus petite valeur des résultats intermédiaires.</p>
<p>exemple : chaque thread compare 2 valeurs et écrit la plus petite dans un tableau intermédiaire </p><div class="fragment"><div class="line"><span class="comment">// etape 1 : pour N valeurs, executer N/2 threads</span></div>
<div class="line"><span class="keywordtype">int</span> input[N]</div>
<div class="line"><span class="keywordtype">int</span> output</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> tmp[N/2]</div>
<div class="line"> </div>
<div class="line">layout(local_size= 64)</div>
<div class="line">void main( )</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keywordtype">id</span>= GlobalID</div>
<div class="line">    <span class="keywordflow">if</span>(<span class="keywordtype">id</span> &lt; N/2)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">int</span> a= input[<span class="keywordtype">id</span>*2]</div>
<div class="line">        <span class="keywordtype">int</span> b= input[<span class="keywordtype">id</span>*2+1]</div>
<div class="line">        tmp[id]= <a class="code" href="group__math.html#ga9d00581637de555de475cc00762a1eff">min</a>(a, b)</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>mais il faut recommencer pour N/4, N/8, etc. l'algo complet comporte donc une boucle qui traite de moins en moins de données avec de moins en moins de threads...</p>
<div class="fragment"><div class="line"><span class="comment">// etape 2 : pour N valeurs, comparer N/2 paires, puis N/4, puis N/8, etc.</span></div>
<div class="line"><span class="keywordtype">int</span> input[N]</div>
<div class="line"><span class="keywordtype">int</span> output</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> tmp[N/2]</div>
<div class="line"> </div>
<div class="line">layout(local_size= 64)</div>
<div class="line">void main( )</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keywordtype">id</span>= GlobalID</div>
<div class="line">    <span class="keywordflow">if</span>(<span class="keywordtype">id</span> &lt; N/2)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">int</span> a= input[<span class="keywordtype">id</span>*2]</div>
<div class="line">        <span class="keywordtype">int</span> b= input[<span class="keywordtype">id</span>*2+1]</div>
<div class="line">        tmp[id]= <a class="code" href="group__math.html#ga9d00581637de555de475cc00762a1eff">min</a>(a, b)</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> n= N/2; n &gt; 1; n= n / 2)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span>(<span class="keywordtype">id</span> &lt; n)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordtype">int</span> a= tmp[<span class="keywordtype">id</span>*2]</div>
<div class="line">            <span class="keywordtype">int</span> b= tmp[<span class="keywordtype">id</span>*2+1]</div>
<div class="line">            tmp[id]= <a class="code" href="group__math.html#ga9d00581637de555de475cc00762a1eff">min</a>(a, b)</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// dernier détail, il faut encore copier le résultat de tmp[0] dans output...</span></div>
<div class="line">    <span class="keywordflow">if</span>(<span class="keywordtype">id</span> == 0)</div>
<div class="line">        output= tmp[0]</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>problème :</b> cet algorithme ne fonctionnera pas sur un processeur graphique...</p><ul>
<li>l'ordonnancement des threads, géré automatiquement par le matériel, ne garanti pas que tous les groupes progressent à la même vitesse / de manière synchronisée. Entre chaque itération du <code>for(n ...)</code>, il faut attendre que tous les threads de tous les groupes aient écrits leur résultat dans <code>tmp[]</code> avant de pouvoir le relire à l'itération suivante, avec des threads / groupes différents.</li>
<li>autre problème, cet algorithme suppose que les threads s'exécutent dans l'ordre de leur numero, c'est qui n'est pas non plus le cas... <code>tmp[id]</code> doit contenir le résultat de l'itération précédente pour que l'algorithme fonctionne. Pour corriger ce problème, il suffit de lire et d'écrire dans des tableaux différents (ou des zones différentes du même tableau).</li>
</ul>
<p>pour mieux visualiser le problème, on peut reformuler l'algorithme de manière séquentielle / classique : </p><div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> n= N/2; n &gt; 1; n = n / 2 )</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> <span class="keywordtype">id</span>= 0; <span class="keywordtype">id</span> &lt; n; <span class="keywordtype">id</span>++) <span class="comment">// if(id &lt; n)</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">int</span> a= tmp[<span class="keywordtype">id</span>*2]</div>
<div class="line">        <span class="keywordtype">int</span> b= tmp[<span class="keywordtype">id</span>*2+1]</div>
<div class="line">        tmp[id]= <a class="code" href="group__math.html#ga9d00581637de555de475cc00762a1eff">min</a>(a, b)</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>que se passe-t-il si <code>id</code> est choisi au hasard parmi les <code>n</code> valeurs possibles au lieu de respecter l'ordre 0, 1, 2, etc. ?</p>
<p>Une solution simple consiste à écrire les résultats dans un autre tableau, mais cette solution n'est pas très pratique, le nombre de tableaux accessibles à un shader est limité à une valeur assez faible, 8 ou 16, par exemple. Une solution pratique consiste à créer un tableau <code>tmp[]</code> plus grand et à écrire les résultats dans des parties non utilisées du tableau. Par exemple, allouer N valeurs pour <code>tmp[]</code>. la première itération stocke N/2 comparaisons, la suivante N/4, etc. en gros, chaque itération peut utiliser la moitié du tableau encore disponible.</p>
<p>Pour N=16, on peut représenter l'organisation schèmatiquement : </p><div class="fragment"><div class="line">tmp[16]= . . .. .... ........</div>
<div class="line"><span class="comment">// iteration 0, 8 valeurs, stockees dans [8..16[</span></div>
<div class="line">tmp[16]= . . .. .... 00000000</div>
<div class="line"><span class="comment">// iteration 1, 4 valeurs, stockees dans [4..8[</span></div>
<div class="line">tmp[16]= . . .. 1111 00000000</div>
<div class="line"><span class="comment">// iteration 2, 2 valeurs, stockees dans [2..4[</span></div>
<div class="line">tmp[16]= . . 22 1111 00000000</div>
<div class="line"><span class="comment">// iteration 3, 1 valeur, stockee dans [1..2[</span></div>
<div class="line">tmp[16]= . 3 22 1111 00000000</div>
</div><!-- fragment --><p> Le résultat final se trouvera dans <code>tmp[1]</code>.</p>
<p>GLSL fournit 2 types de synchronisation pour écrire ce type de shader, <code>barrier()</code> et <code>memoryBarrier()</code> qui permettent de synchroniser l'exécution <em>interne</em> et les accès mémoire des threads d'un groupe, et openGL fournit <code>glMemoryBarrier( )</code> qui permet à l'application de contrôler l'exécution <em>externe</em> / <em>globale</em> et les accès mémoire de tous les groupes, entre 2 <code>dispatch</code>.</p>
<p>Au final la solution complète ressemble à : </p><div class="fragment"><div class="line"><span class="comment">// shader</span></div>
<div class="line"><span class="keywordtype">int</span> data[N]</div>
<div class="line"><span class="keywordtype">int</span> tmp[N]</div>
<div class="line"> </div>
<div class="line">uniform uint N      <span class="comment">// nombre de valeurs à traiter pour l&#39;iteration 0, comparer les valeurs de data et ecrire dans tmp</span></div>
<div class="line">uniform uint n      <span class="comment">// nombre de valeurs à traiter pour les autres iterations, comparer les valeurs de tmp et les ecrire dans une partie libre de tmp</span></div>
<div class="line"> </div>
<div class="line">layout(local_size= 1024)</div>
<div class="line">void main( )</div>
<div class="line">{</div>
<div class="line">    uint <span class="keywordtype">id</span>= GlobalID;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span>(<span class="keywordtype">id</span> &lt; N/2)</div>
<div class="line">        <span class="comment">// uniquement pour la premiere iteration</span></div>
<div class="line">        tmp[N/2+id]= <a class="code" href="group__math.html#ga9d00581637de555de475cc00762a1eff">min</a>(data[<span class="keywordtype">id</span>*2], data[<span class="keywordtype">id</span>*2+1]);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span>(<span class="keywordtype">id</span> &lt; n/2)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// pour les autres iterations </span></div>
<div class="line">        tmp[n/2+id]= <a class="code" href="group__math.html#ga9d00581637de555de475cc00762a1eff">min</a>(tmp[n+<span class="keywordtype">id</span>*2], tmp[n+<span class="keywordtype">id</span>*2+1]);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// application</span></div>
<div class="line"><span class="keywordtype">int</span> N= ...;</div>
<div class="line"><span class="keywordtype">int</span> groups= (N + 1024) / 1024;</div>
<div class="line">Dispatch(groups, N, n=0);   <span class="comment">// premiere iteration</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/*  la syntaxe correcte, pour fixer les valeurs des uniforms est la meme que d&#39;habitude, cf</span></div>
<div class="line"><span class="comment">    glUniform1i( glUniformLocation(program, &quot;N&quot;), N);</span></div>
<div class="line"><span class="comment">    glUniform1i( glUniformLocation(program, &quot;n&quot;), 0);</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// iterations suivantes</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> n= N/2; n &gt; 1; n= n /2)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// attendre que les résultats soient écrits</span></div>
<div class="line">    MemoryBarrier();</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">int</span> groups= (n + 1024) / 1024;</div>
<div class="line">    Dispatch(groups, N= 0, n)</div>
<div class="line">}</div>
</div><!-- fragment --><p>Au final cette version de l'algorithme est quand même moins directe que la version séquentielle, est ce que c'est interressant ? voici une illustration des temps d'exécution sur cpu et gpu pour N= 2, 4, 8, 16, ...</p>
<div class="image">
<img src="min_data.png" alt=""/>
<div class="caption">
temps d'execution (ms) pour N= 2, 4, 8, 16, ...</div></div>
<p>globalement, à part la premiere exécution qui mesure aussi le temps de compilation du shader et la réorganisation des buffers en mémoire, c'est plutot interressant...</p>
<p>exemple complet <a class="el" href="min__data_8cpp.html">min_data.cpp</a></p>
<h3><a class="anchor" id="autotoc_md20"></a>
synchronisation et opérations atomiques</h3>
<p><code>barrier()</code> et <code>memoryBarrier()</code> permettent de synchroniser l'exécution des threads d'un groupe, mais il est quand même très fréquent de devoir synchroniser les groupes entre eux. La synchronisation externe par l'application fonctionne mais reste une solution très lourde. Un autre solution existe : les shaders peuvent utiliser des opérations <em>atomiques</em> pour synchroniser leurs écritures/lectures mémoire.</p>
<p><em>opération atomique ?</em> Modifier une valeur en mémoire, se décompose de manière générale en 3 opérations, lire la valeur actuellement en mémoire, modifier la valeur et écrire la nouvelle valeur en mémoire. par exemple, pour calculer <code>tmp[i]++</code> ou <code>tmp[i]= tmp[i] +1</code>, il faut lire tmp[i], calculer l'addition et écrire le résultat dans tmp[i]. Lorsque plusieurs threads font cette opération en même temps sur la même variable, le résultat est faux; si N threads ajoutent 1 à une variable, on devrait obtenir N comme résultat, ce qui ne sera pas le cas. Les opérations atomiques permettent de sérialiser / synchroniser l'exécution des opérations pour obtenir le "bon" résultat. Mais l'exécution des threads n'est plus parallèle, elle (re-) devient séquentielle...</p>
<p>Du coup, calculer la plus petite valeur d'un ensemble peut s'écrire d'une manière beaucoup plus directe... </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> data[N]</div>
<div class="line"><span class="keywordtype">int</span> tmp</div>
<div class="line"> </div>
<div class="line">layout(local_size= 1024)</div>
<div class="line">void main( )</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keywordtype">id</span>= GlobalID;</div>
<div class="line">    <span class="keywordflow">if</span>(<span class="keywordtype">id</span> &lt; N)</div>
<div class="line">    {</div>
<div class="line">        atomicMin(tmp, data[<span class="keywordtype">id</span>])</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Les opérations atomiques suivantes sont disponibles : atomicMin, atomicMax, atomicOr, atomicXor, atomicAnd, atomicAdd, ainsi que atomicExchange et atomicCompSwap (compare and swap) qui permettent de construire des spinlocks.</p>
<p>Au final, cette solution, qui détruit complètement la parallélisation, reste tout de même plus efficace (à peu près 2 fois dans ce cas) que la solution précédente avec une synchronisation externe. Une meilleure solution consiste à conserver le plus de parallélisme possible sans utiliser la synchronisation externe, en limitant le nombre de threads manipulant la même variable avec des opérations atomiques. L'idée est de créer une variable atomique par groupe puis de fusionner les résultats. Cette hiérarchie est expliquée sur gpuopen.com cf <a href="http://gpuopen.com/fast-compaction-with-mbcnt/">http://gpuopen.com/fast-compaction-with-mbcnt/</a>.</p>
<h3><a class="anchor" id="autotoc_md21"></a>
mémoire partagée</h3>
<p>Les compute shaders ont également accès à la mémoire partagée des processeurs. C'est une zone de mémoire dédiée, locale à chaque processeur qui est beaucoup plus rapide d'accès que la mémoire video, mais seuls 32Ko ou 64Ko sont disponibles. Une variable ou un tableau partagé se déclare dans le shader avec le mot clé <code>shared</code>. </p><div class="fragment"><div class="line">shared <span class="keywordtype">int</span> <a class="code" href="group__application.html#ga5363b2eb1b788164e07359d4ca15d5c9">value</a>;</div>
<div class="line">shared <span class="keywordtype">int</span> values[128];</div>
</div><!-- fragment --><p>La quantitié disponible est accessible directement : </p><div class="fragment"><div class="line">GLint size= 0;</div>
<div class="line">glGetIntegerv(GL_MAX_COMPUTE_SHARED_MEMORY_SIZE, &amp;size);</div>
</div><!-- fragment --><p>L'accès <em>parallèle</em> à cette mémoire est également soumis à conditions : les threads doivent y accéder de manière cohérente, sinon les accès sont sérialisés. Un accès est cohérent lorsque les threads accèdent à une séquence d'adresses contiguees, ou à une séquence de cellules d'un tableau. Par exemple, les threads d'un groupe accèdent à <code>tmp[LocalID]</code>, le thread 0 du groupe lit la cellule 0, le thread 1 lit la cellule 1, etc.</p>
<p>Selon les architectures (AMD, Intel, Nvidia), d'autres accès peuvent être cohérents : par exemple lorsque tous les threads lisent la même cellule d'un tableau partagé.</p>
<p>L'utilisation de la mémoire partagée permet de lire une seule fois les données depuis la mémoire video, ce qui très (très) lent, mais permet ensuite d'accéder aux données de manière efficace. Par exemple, sur AMD GCN, la mémoire partagée n'est que 4 fois plus lente que l'accès à un registre et bien plus rapide que l'accès aux caches, qui sont eux mếmes largement plus rapides que l'accès à la mémoire video.</p>
<p>L'utilisation de la mémoire partagée n'est pas obligatoire, mais pour les algorithmes qui relisent plusieurs fois leurs données, c'est en général très efficace, par exemple, des filtres pour flouter/débruiter/analyser une image, des opérations sur des matrices, etc.</p>
<h2><a class="anchor" id="autotoc_md22"></a>
et on peut faire quoi avec tout ca ?</h2>
<p>Pour utiliser un compute shader, il faut, comme d'habitude, le compiler, le linker pour obtenir un programme et le paramétrer, donner des valeurs à ses uniforms, sélectionner des buffers, des textures, etc. avant de pouvoir l'exécuter avec <code>glComputeDispatch( )</code>.</p>
<h3><a class="anchor" id="autotoc_md23"></a>
compiler un compute shader</h3>
<p>c'est la même chose qu'un shader program "classique", mais il n'y a qu'un seul shader de type GL_COMPUTE_SHADER dans le program.</p>
<div class="fragment"><div class="line"><span class="comment">// charger les sources</span></div>
<div class="line">std::string source= read( <span class="stringliteral">&quot;compute.glsl&quot;</span> );</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *strings[]= { source.c_str() };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// creer et compiler le shader</span></div>
<div class="line">GLuint shader= glCreateShader(GL_COMPUTE_SHADER);</div>
<div class="line">glShaderSource(shader, 1, strings, NULL);</div>
<div class="line">glCompileShader(shader);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// creer et linker le program</span></div>
<div class="line">GLuint program= glCreateProgram();</div>
<div class="line">glAttachShader(program, shader);</div>
<div class="line">glLinkProgram(program);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// verifier</span></div>
<div class="line">GLint status;</div>
<div class="line">glGetProgramiv(program, GL_LINK_STATUS, &amp;status);</div>
<div class="line"><span class="keywordflow">if</span>(status == GL_TRUE)</div>
<div class="line">    <span class="comment">// pas d&#39;erreur de link, le program est pret a etre utilise !</span></div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">    <span class="comment">// erreurs ...</span></div>
</div><!-- fragment --><p>vous pouvez aussi utiliser <code><a class="el" href="group__openGL.html#ga2d6e7b012b252577cc04bf9abdc4c5ba">read_program( )</a></code> et <code><a class="el" href="group__openGL.html#ga873fe3eb898a9ffe19c8274f83116b8a" title="affiche les erreurs de compilation.">program_print_errors()</a></code> de <a class="el" href="program_8h.html">program.h</a>, le source du shader doit être dans un bloc <code>#ifdef COMPUTE_SHADER / #endif</code>.</p>
<h3><a class="anchor" id="autotoc_md24"></a>
paramétrer un compute shader</h3>
<p>Les compute shaders ont les mêmes entrées que les autres shaders, des uniforms, des buffers, des textures et des samplers. c'est exactement la même chose. Par contre, ils ne s'exécutent pas dans le pipeline graphique, donc ils n'écrivent pas leurs résultats automatiquement, il faut décrire ou stocker les résultats.</p>
<p>les shaders peuvent écrire dans 2 types d'objets openGL :</p><ul>
<li>des buffers, plus précisement des storage buffers, cf <a class="el" href="group__storage.html">openGL 4.3 : storage buffers</a>, déclarés <code>writeonly</code> ou <code>coherent</code> si les shaders écrivent et relisent les données du buffer,</li>
<li>des textures, plus précisement des texture images, cf <a class="el" href="group__storage__texture.html">openGL 4.3 : storage textures / images</a>, déclarées <code>writeonly</code> ou <code>coherent</code> si les shaders écrivent et relisent les données de la texture.</li>
</ul>
<p><b>remarque :</b> les opérations atomiques lisent et écrivent dans les buffers (<code>atomicAdd()</code>, <code>atomicMin()</code>, etc.) et/ou les textures (<code>imageAtomicAdd()</code>, <code>imageAtomicMin()</code>, etc.).</p>
<h3><a class="anchor" id="autotoc_md25"></a>
exécuter un compute shader</h3>
<p>c'est <code>glComputeDispatch()</code> qui provoque l'exécution des shaders. Il faut fournir le nombre de groupes de shaders à lancer. Dernière précision, le nombre de groupes est un ivec3, les shaders peuvent être organisés en 1d, 2d ou en 3d, selon la dimension des données à manipuler.</p>
<div class="fragment"><div class="line"><span class="comment">// selectionner le program, si necessaire</span></div>
<div class="line"><span class="comment">// glUseProgram(program);</span></div>
<div class="line"> </div>
<div class="line">glComputeDispatch(groups_x, 1, 1);          <span class="comment">// execution 1d</span></div>
<div class="line">glComputeDispatch(groups_x, groups_y, 1);       <span class="comment">// execution 2d</span></div>
<div class="line">glComputeDispatch(groups_x, groups_y, groups_z);    <span class="comment">// execution 3d</span></div>
</div><!-- fragment --><p>Il est possible de récupérer le nombre de shaders par groupe déclaré dans le shader : </p><div class="fragment"><div class="line">GLint threads[3]= { };</div>
<div class="line">glGetProgramiv(program, GL_COMPUTE_WORK_GROUP_SIZE, threads);</div>
</div><!-- fragment --><p>et de calculer le nombre de groupes à lancer en fonction du nombre de données à traiter. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> N= { ... };</div>
<div class="line"><span class="keywordtype">int</span> groups= N / threads[0];</div>
<div class="line"><span class="keywordflow">if</span>(N % threads[0] &gt; 0) </div>
<div class="line">    groups= groups +1;  <span class="comment">// un groupe supplémentaire, si N n&#39;est pas un multiple de threads[0]</span></div>
<div class="line"> </div>
<div class="line">glComputeDispatch(groups, 1, 1);</div>
</div><!-- fragment --><p>Les shaders sont numérotés globalement en fonction de l'indice de leur groupe et localement, dans leur groupe. Plusieurs variables sont prédéfinies pour identifier un thread :</p><ul>
<li><code>uvec3 gl_LocalInvocationID</code>, et <code>uvec3 gl_GlobalInvocationID</code>,</li>
<li><code>uvec3 gl_WorkGroupID</code>, l'identifiant d'un groupe, compris entre 0 et <code>gl_NumWorkGroups.xyz</code>,</li>
<li><code>uvec3 gl_NumWorkGroups</code>, le nombre de groupes de threads en cours d'exécution, cf <code>glComputeDispatch()</code>,</li>
<li><code>uint gl_LocalInvocationIndex</code>, l'identifiant 1d d'un thread : <br  />
 <code>gl_LocalInvocationID.z * gl_WorkGroupSize.x * gl_WorkGroupSize.y</code> <br  />
 <code>+ gl_LocalInvocationID.y * gl_WorkGroupSize.x</code> <br  />
 <code>+ gl_LocalInvocationID.x</code></li>
</ul>
<h3><a class="anchor" id="autotoc_md26"></a>
attendre les résultats</h3>
<p>En général, les résultats calculés par un compute shader sont utilisés par un autre shader, et il faut explicitement attendre que les résultats soient disponibles avant d'exécuter le shader suivant, c'est <code>glMemoryBarrier()</code> qui permet de le faire.</p>
<p>Il existe plusieurs types de d'attente / de barrière, en fonction de la méthode utilisée pour relire les résultats :</p><ul>
<li>si les résultats sont écrits dans un (storage) buffer et que le cpu va relire ces données avec <code>glGetBufferSubData()</code>, il faut utiliser <code>glMemoryBarrier(GL_BUFFER_UPDATE_BARRIER_BIT)</code>,</li>
<li>si les résultats sont écrits dans un (storage) buffer et qu'un shader va relire ces données, il faut utiliser <code>glMemoryBarrier(GL_SHADER_STORAGE_BARRIER_BIT)</code>,</li>
<li>si les résultats sont écrits dans une (storage) texture et que le cpu va relire ces données avec <code>glGetTexImage()</code>, il faut utiliser <code>glMemoryBarrier(GL_TEXTURE_UPDATE_BARRIER_BIT)</code>,</li>
<li>si les résultats sont écrits dans une (storage) texture et qu'un shader va relire ces données avec un sampler, il faut utiliser <code>glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT)</code></li>
</ul>
<p>En cas de problèmes de synchronisation, il est possible d'utiliser une barrière globale, <code>glMemoryBarrier(GL_ALL_BARRIER_BITS)</code>.</p>
<p>exemple complet <a class="el" href="min__data_8cpp.html">min_data.cpp</a></p>
<p>exemple complet <a class="el" href="tuto__vertex__compute_8cpp.html">tuto_vertex_compute.cpp</a>, illustration des principes : passe 1. compute shader, synchronisation, passe 2. pipeline graphique.</p>
<h2><a class="anchor" id="autotoc_md27"></a>
notions d'exécution cohérente</h2>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>Les groupes de threads ne sont pas ordonnancés directement par le matériel, ils sont découpés en sous-groupes de gl_SubgroupSize... et l'exécution des threads des sous groupes est synchrone, ils exécutent tous la mếme instruction en même temps et peuvent communiquer directement sans passer par la mémoire partagée...</dd></dl>
<p>cf les extensions standard GL_ARB_shader_ballot, GL_ARB_shader_group_vote</p>
<p>et les extensions constructeurs :</p><ul>
<li>AMD GL_AMD_shader_ballot</li>
<li>nvidia GL_NV_shader_thread_group, GL_NV_shader_thread_shuffle</li>
</ul>
<h2><a class="anchor" id="autotoc_md28"></a>
limites d'ordonnancement</h2>
<p>Les ressources disponibles par processeur graphique sont limitées : le nombre de registres, la quantité de mémoire partagée, le nombre de groupes gérés par l'ordonnanceur matériel.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md29"></a>
un peu de lecture</h2>
<p>pour plus de détails et une introduction plus complète, M. Chajdas / AMD a rédigé :</p><ul>
<li><a href="https://anteru.net/blog/2018/intro-to-compute-shaders/index.html">intro to compute shader</a></li>
<li><a href="https://anteru.net/blog/2018/more-compute-shaders/index.html">more compute shaders</a></li>
<li><a href="https://anteru.net/blog/2018/even-more-compute-shaders/index.html">even more compute shaders</a> </li>
</ul>
</div><!-- contents -->
<div class="ttc" id="agroup__math_html_ga9d00581637de555de475cc00762a1eff"><div class="ttname"><a href="group__math.html#ga9d00581637de555de475cc00762a1eff">min</a></div><div class="ttdeci">Point min(const Point &amp;a, const Point &amp;b)</div><div class="ttdoc">renvoie la plus petite composante de chaque point. x, y, z= min(a.x, b.x), min(a.y,...</div><div class="ttdef"><b>Definition:</b> <a href="vec_8cpp_source.html#l00030">vec.cpp:30</a></div></div>
<div class="ttc" id="agroup__application_html_ga5363b2eb1b788164e07359d4ca15d5c9"><div class="ttname"><a href="group__application.html#ga5363b2eb1b788164e07359d4ca15d5c9">value</a></div><div class="ttdeci">bool value(Widgets &amp;w, const char *label, int &amp;value, const int value_min, const int value_max, const int value_step)</div><div class="ttdoc">valeur editable par increment.</div><div class="ttdef"><b>Definition:</b> <a href="widgets_8cpp_source.html#l00191">widgets.cpp:191</a></div></div>
<div class="ttc" id="astructvec4_html"><div class="ttname"><a href="structvec4.html">vec4</a></div><div class="ttdoc">vecteur generique 4d, ou 3d homogene, utilitaire.</div><div class="ttdef"><b>Definition:</b> <a href="vec_8h_source.html#l00166">vec.h:166</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 9 2019 15:39:11 for gKit2 light by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
