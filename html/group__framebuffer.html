<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gKit2 light: rendu multi-passes : shadow maps, post process</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">gKit2 light
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">rendu multi-passes : shadow maps, post process</div>  </div>
</div><!--header-->
<div class="contents">
<p>cf <a class="el" href="tuto__framebuffer_8cpp.html">tuto_framebuffer.cpp</a></p>
<p>Dans plusieurs cas, il est nécessaire de "récupérer" le résultat d'un rendu pour le modifier avant l'affichage final. par exemple, on peut vouloir filtrer l'image brute avant de l'afficher. ou ajuster les couleurs pour produire une ambiance chaude ou froide, ajouter un grain dans l'image, etc. il faut donc pouvoir recupérer le color buffer et éventuellement le zbuffer qui sont habituellement affichés directement dans la fenêtre de l'application.</p>
<p>De manière générale, certaines méthodes de rendu sont trop complexes pour être réalisées avec une seule exécution du pipeline graphique. une solution est de découper le rendu complet en plusieurs étapes, chaque étape utilisant l'image produite par l'étape précédente, jusqu'à obtenir le résultat final que l'on peut afficher.</p>
<p>Ce sont des objets openGL, des framebuffer objects, notés FBO, qui permettent de configurer le pipeline pour stocker les résultats des fragment shaders dans des textures crées par l'application, au lieu de les afficher directement.</p>
<p>Leur utilisation est semblable aux autres objets "complexes" d'openGL (comme les vertex array objects, VAO) :</p><ul>
<li>création, cf glGenFramebuffers( ),</li>
<li>sélection, cf glBindFramebuffer( ),</li>
<li>sélection des textures sur les sorties du framebuffer, cf glFramebufferTexture( ),</li>
<li>association des sorties du fragment shader aux sorties du framebuffer, cf glDrawBuffers( ).</li>
</ul>
<p>mais bien sur, il faut commencer par créer un objet framebuffer et le sélectionner pour le configurer : </p><div class="fragment"><div class="line">GLuint framebuffer;</div>
<div class="line">glGenFramebuffers(1, &amp;framebuffer);</div>
<div class="line"> </div>
<div class="line">glBindFramebuffer(GL_DRAW_FRAMEBUFFER, framebuffer);</div>
</div><!-- fragment --><p>ensuite, il n'y a plus qu'à indiquer quelles textures vont stocker les résultats exportés par le fragment shader et le pipeline. Les sorties d'un fragment shader sont une ou plusieurs couleurs, ainsi que la profondeur du fragment. ces différentes sorties sont identifiées par :</p><ul>
<li>GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1 ... GL_COLOR_ATTACHMENT7, pour les color buffers, les couleurs,</li>
<li>GL_DEPTH_ATTACHMENT, pour le zbuffer, la profondeur du fragment.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// selectionner le framebuffer a configurer, si necessaire</span></div>
<div class="line"><span class="comment">// glBindFramebuffer(GL_DRAW_FRAMEBUFFER, framebuffer);</span></div>
<div class="line"> </div>
<div class="line">GLuint color_texture;</div>
<div class="line"><span class="comment">// creer la texture couleur aux dimensions de la fenetre</span></div>
<div class="line">{ ... }</div>
<div class="line"> </div>
<div class="line"><span class="comment">// associer la texture à une sortie du framebuffer</span></div>
<div class="line">glFramebufferTexture(GL_DRAW_FRAMEBUFFER, <span class="comment">/* attachment */</span> GL_COLOR_ATTACHMENT0, <span class="comment">/* texture */</span> color_texture, <span class="comment">/* mipmap level */</span> 0);</div>
</div><!-- fragment --><p>reste une dernière option dans la configuration, récupérer l'identifiant d'une sortie déclarée dans le fragment shader et l'associer à une sortie du framebuffer, cf glDrawBuffers( ). il faut lui transmettre un tableau d'identifiants GL_NONE, GL_COLOR_ATTACHMENTxx indexé par l'identifiant de la sortie du fragment shader.</p>
<p>si le fragment shader ne déclare qu'une seule sortie, son identifiant est 0 par convention, il suffit de remplir un tableau contenant la sortie configurée dans le framebuffer à l'indice 0 : </p><div class="fragment"><div class="line"><span class="comment">// selectionner le framebuffer a configurer, si necessaire</span></div>
<div class="line"><span class="comment">// glBindFramebuffer(GL_DRAW_FRAMEBUFFER, framebuffer);</span></div>
<div class="line"> </div>
<div class="line">GLenum <a class="code" href="mesh__buffer_8cpp.html#af9c01c4285fe2a34523e5041abf7a86c">buffers</a>[]= { GL_COLOR_ATTACHMENT0 };</div>
<div class="line">glDrawBuffers(1, <a class="code" href="mesh__buffer_8cpp.html#af9c01c4285fe2a34523e5041abf7a86c">buffers</a>);</div>
</div><!-- fragment --><p><b>remarque :</b> on peut configurer n'importe quel attachment dans le fbo : </p><div class="fragment"><div class="line"><span class="comment">// selectionner le framebuffer a configurer, si necessaire</span></div>
<div class="line"><span class="comment">// glBindFramebuffer(GL_DRAW_FRAMEBUFFER, framebuffer);</span></div>
<div class="line">glFramebufferTexture(GL_DRAW_FRAMEBUFFER, <span class="comment">/* attachment */</span> GL_COLOR_ATTACHMENT4, <span class="comment">/* texture */</span> color_texture, <span class="comment">/* mipmap level */</span> 0);</div>
<div class="line"> </div>
<div class="line">GLenum <a class="code" href="mesh__buffer_8cpp.html#af9c01c4285fe2a34523e5041abf7a86c">buffers</a>[]= { GL_COLOR_ATTACHMENT4 };</div>
<div class="line">glDrawBuffers(1, <a class="code" href="mesh__buffer_8cpp.html#af9c01c4285fe2a34523e5041abf7a86c">buffers</a>);</div>
</div><!-- fragment --><p>pour "décoder" la configuration de fbo, le plus simple est de partir de la sortie dans le fragment shader : son identifiant est 0, donc la valeur sera écrite dans l'attachment d'indice 0 passé à glDrawBuffers(). et la texture stockant la valeur est celle sélectionnée par glFramebufferTexture( ) sur l'attachment correspondant.</p>
<h2><a class="anchor" id="autotoc_md99"></a>
dessiner dans un framebuffer</h2>
<p>il suffit de sélectionner le framebuffer sur GL_DRAW_FRAMEBUFFER avec glBindFramebuffer( ) avant de dessiner quelquechose : </p><div class="fragment"><div class="line">GLuint framebuffer= { ... };</div>
<div class="line">glBindFramebuffer(GL_DRAW_FRAMEBUFFER, framebuffer);</div>
<div class="line"> </div>
<div class="line">glBindVertexArray( ... );</div>
<div class="line">glUseProgram( ... );</div>
<div class="line">glUniform( ... );</div>
<div class="line"> </div>
<div class="line">glDrawArrays(GL_TRIANGLES, ... );</div>
</div><!-- fragment --><p><b>attention :</b> glDraw() utilise <em>implicitement</em> plusieurs paramètres : les dimensions du viewport, par exemple (et le framebuffer sélectionné, bien sur). il faudra donc penser à utiliser <code>glViewport()</code> si les dimensions des textures ne sont pas les memes que celles de la fenetre de l'application.</p>
<p><em>remarque :</em> effacer le framebuffer avant de dessiner : </p><div class="fragment"><div class="line">GLuint framebuffer= { ... };</div>
<div class="line">glBindFramebuffer(GL_DRAW_FRAMEBUFFER, framebuffer);</div>
<div class="line">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</div>
</div><!-- fragment --><p><code>Clear( COLOR_BUFFER_BIT ... )</code> copie la couleur par défaut dans toutes les textures associées aux <code>COLOR_ATTACHMENTxx</code> et <code>Clear( DEPTH_BUFFER_BIT ... )</code> copie la profondeur par défaut dans la texture associée à <code>DEPTH_ATTACHMENT</code>.</p>
<p><code>Clear( )</code> utilise <em>implicitement</em> les dimensions fournies par glViewport( ), donc il faut penser à configurer le viewport avant...</p>
<p>si l'on souhaite utiliser des valeurs / couleurs différentes selon le buffer, il faut utiliser glClearBuffer(). par exemple pour "effacer", le buffer 0 : </p><div class="fragment"><div class="line">GLuint framebuffer= { ... };</div>
<div class="line">glBindFramebuffer(GL_DRAW_FRAMEBUFFER, framebuffer);</div>
<div class="line">glFramebufferTexture(GL_DRAW_FRAMEBUFFER, <span class="comment">/* attachment */</span> GL_COLOR_ATTACHMENT0, <span class="comment">/* texture */</span> color_texture, <span class="comment">/* mipmap level */</span> 0);</div>
<div class="line"> </div>
<div class="line">GLenum <a class="code" href="mesh__buffer_8cpp.html#af9c01c4285fe2a34523e5041abf7a86c">buffers</a>[]= { GL_COLOR_ATTACHMENT0 };</div>
<div class="line">glDrawBuffers(1, <a class="code" href="mesh__buffer_8cpp.html#af9c01c4285fe2a34523e5041abf7a86c">buffers</a>);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="structColor.html">Color</a> color(1, 0, 0);</div>
<div class="line">glClearBufferfv(GL_COLOR, <span class="comment">/* draw buffer */</span> 0, <span class="comment">/* value */</span> &amp;color.x);</div>
</div><!-- fragment --><p><code>DRAW_BUFFER0</code> est l'indice dans le tableau <code>buffers</code>, <code>buffers[0]</code> contient <code>COLOR_ATTACHMENT0</code>, et c'est la texture <code>color_texture</code> qui sera finalement modifiée / effacée.</p>
<h2><a class="anchor" id="autotoc_md100"></a>
et glViewport( ) ?</h2>
<p>il faut aussi configurer le pipeline en fonction des dimensions des textures associées au framebuffer. </p><div class="fragment"><div class="line">GLuint framebuffer= { ... };</div>
<div class="line">glBindFramebuffer(GL_DRAW_FRAMEBUFFER, framebuffer);</div>
<div class="line">glViewport(0, 0, framebuffer_width, framebuffer_height);</div>
<div class="line"> </div>
<div class="line">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</div>
</div><!-- fragment --><p>glClear( ) et glDraw( ) utilisent <em>implicitement</em> les dimensions fournies par glViewport( ), donc il faut configurer viewport avant clear et draw...</p>
<h2><a class="anchor" id="autotoc_md101"></a>
dessiner dans la fenetre ? (framebuffer par défaut)</h2>
<p>il suffit de sélectionner le framebuffer 0 avant de dessiner : </p><div class="fragment"><div class="line">glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0);</div>
<div class="line">glViewport(0, 0, <a class="code" href="group__application.html#gae3a7daacf8fe05cc4e57d8557ec4e475">window_width</a>(), <a class="code" href="group__application.html#ga4d0b205b70f38973c8c5395f31f77baf">window_height</a>());</div>
<div class="line">glClear(GL_COLOR_BUFFER_BIt |&amp;nbsp;GL_DEPTH_BUFFER_BIT);</div>
<div class="line"> </div>
<div class="line">glBindVertexArray( ... );</div>
<div class="line">glUseProgram( ... );</div>
<div class="line">glUniform( ... );</div>
<div class="line"> </div>
<div class="line">glDrawArrays(GL_TRIANGLES, ... );</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md102"></a>
récupérer l'identifiant d'une sortie du fragment shader</h2>
<p>c'est glGetFragDataLocation( ) qui renvoie l'identifiant du varying déclaré par le fragment shader : </p><div class="fragment"><div class="line">GLuint program= ... ;</div>
<div class="line"> </div>
<div class="line">GLint location= glGetFragDataLocation(program, <span class="stringliteral">&quot;fragment_color&quot;</span>);</div>
</div><!-- fragment --><p>et on peut utiliser cette valeur pour configurer le framebuffer, cf glDrawBuffers() : </p><div class="fragment"><div class="line">GLuint program= ... ;</div>
<div class="line">GLuint framebuffer = .... ;</div>
<div class="line">GLenum <a class="code" href="mesh__buffer_8cpp.html#af9c01c4285fe2a34523e5041abf7a86c">buffers</a>[8]= { GL_NONE, GL_NONE, GL_NONE, GL_NONE, GL_NONE, GL_NONE, GL_NONE, GL_NONE };</div>
<div class="line">GLint location= glGetFragDataLocation(program, <span class="stringliteral">&quot;fragment_color&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span>(location &gt;= 0)</div>
<div class="line">    <a class="code" href="mesh__buffer_8cpp.html#af9c01c4285fe2a34523e5041abf7a86c">buffers</a>[location]= GL_COLOR_ATTCHMENT0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// selectionner le fbo, si necessaire</span></div>
<div class="line"><span class="comment">// glBindFamebuffer(GL_DRAW_FRAMEBUFFER, framebuffer);</span></div>
<div class="line"> </div>
<div class="line">glDrawBuffers(8, <a class="code" href="mesh__buffer_8cpp.html#af9c01c4285fe2a34523e5041abf7a86c">buffers</a>); </div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md103"></a>
créer une texture de profondeur / zbuffer</h1>
<p>Jusqu'à présent cf <a class="el" href="group__tuto5GL.html">textures, samplers et pipeline</a>, les textures peuvent stocker des couleurs (dont les valeurs sont comprises entre 0 et 1) sur plusieurs canaux r, g, b (et alpha, éventuellement). il est aussi possible de créer des textures pour stocker une valeur de profondeur par texel avec le format <code>GL_DEPTH_COMPONENT</code> (un entier normalise entre 0 et 1) :</p>
<div class="fragment"><div class="line">GLuint zubffer;</div>
<div class="line">glGenTextures(1, &amp;zbuffer);</div>
<div class="line">glBindTexture(GL_TEXTURE_2D, zbuffer);</div>
<div class="line"> </div>
<div class="line">glTexImage2D(GL_TEXTURE_2D, 0,</div>
<div class="line">    GL_DEPTH_COMPONENT, width, height, 0,</div>
<div class="line">    GL_DEPTH_COMPONENT, GL_UNSIGNED_INT, <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --><p>ou <code>GL_DEPTH_COMPONENT32F</code> (un réel 32bits, un <code>float</code> classique) : </p><div class="fragment"><div class="line">GLuint zubffer;</div>
<div class="line">glGenTextures(1, &amp;zbuffer);</div>
<div class="line">glBindTexture(GL_TEXTURE_2D, zbuffer);</div>
<div class="line"> </div>
<div class="line">glTexImage2D(GL_TEXTURE_2D, 0,</div>
<div class="line">    GL_DEPTH_COMPONENT32F, width, height, 0,</div>
<div class="line">    GL_DEPTH_COMPONENT, GL_FLOAT, <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md104"></a>
utiliser une texture attachée à un framebuffer</h1>
<p>Dessiner dans un framebuffer, et dans les textures associées, ne modifie que le niveau de mipmap attaché au framebuffer, cf glFramebufferTexture( ... level), le mipmap 0, le plus souvent. Mais lorsque l'on utilise cette texture dans l'étape suivante, ses autres mipmaps n'ont pas changés de valeurs. Et selon le mode filtrage utilsé par le shader pour accéder à la texture, les résultats peuvent être surprenants...</p>
<p>par exemple, les paramètres par défaut de filtrage, cf <code>LINEAR_MIPMAP_LINEAR</code>, interpolent 2 mipmaps et 4 texels par mipmap, mais seul le mipmap 0 a ete modifie, et le résultat sera faux.</p>
<p>il y a 2 solutions, soit utiliser un filtrage <code>NEAREST_MIPMAP_LINEAR</code> et <code>MAX_LEVEL</code> = 0 qui n'utilise que le mipmap 0, soit recalculer tous les mipmaps de la texture, cf glGenerateMipmap( ).</p>
<p><em>remarque :</em> pour les textures de profondeur, il n'est pas possible d'utiliser glGenerateMipmap(), donc il faut utiliser un mode de filtrage (cf GL_NEAREST) qui n'accède qu'aux données disponibles : le niveau de mipmap dans lequel on vient de dessiner.</p>
<div class="fragment"><div class="line"><span class="comment">// selectionner l&#39;unite de texture a modifier, si necessaire</span></div>
<div class="line"><span class="comment">// glActiveTExture(GL_TEXTURE0 + unit);</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// desactiver le filtrage (pour les textures de profondeur, mais pas que... )</span></div>
<div class="line"><span class="comment">// acces direct aux donnes sans interpolation :</span></div>
<div class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</div>
<div class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// equivalent, avec un sampler, à utiliser avec glBindSampler(unit, sampler);</span></div>
<div class="line">GLuint sampler= { ... };</div>
<div class="line">glSamplerParameteri(sampler, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</div>
<div class="line">glSamplerParameteri(sampler, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md105"></a>
attention</h3>
<p>Autre subtilité, si une texture est active sur une unité de texture et attachée en même temps au framebuffer actif, glDraw() génèrera une erreur : le pipeline ne peut pas lire et écrire la même texture en même temps. il faut donc bien penser à nettoyer les unités de texture pour eviter ce problème...</p>
<div class="fragment"><div class="line">GLuint color= { ... };</div>
<div class="line">GLuint framebuffer= { ... };</div>
<div class="line"> </div>
<div class="line"><a class="code" href="shader__kit_8cpp.html#a72fad2bb274e5f3b6d190bd860ea63b5">init</a>( )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// configuration framebuffer / texture</span></div>
<div class="line">    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, framebuffer);</div>
<div class="line">    glFramebufferTexture(GL_DRAW_FRAMEBUFFER, <span class="comment">/* attachment */</span> GL_COLOR_ATTACHMENT0, <span class="comment">/* texture */</span> color, <span class="comment">/* mipmap level */</span> 0);</div>
<div class="line"> </div>
<div class="line">    GLenum <a class="code" href="mesh__buffer_8cpp.html#af9c01c4285fe2a34523e5041abf7a86c">buffers</a>[]= { GL_COLOR_ATTACHMENT0 };</div>
<div class="line">    glDrawBuffers(1, <a class="code" href="mesh__buffer_8cpp.html#af9c01c4285fe2a34523e5041abf7a86c">buffers</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// nettoyage</span></div>
<div class="line">    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">render( )</div>
<div class="line">{</div>
<div class="line"><span class="comment">// passe 1, dessiner dans la texture color, attachee au framebuffer</span></div>
<div class="line">    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, framebuffer);</div>
<div class="line">    glViewport( ... );</div>
<div class="line">    glClear( ... );</div>
<div class="line"> </div>
<div class="line">    glBindVertexArray( ... );</div>
<div class="line">    glUseProgram( ... );</div>
<div class="line">    glUniform( ... );</div>
<div class="line">    glDraw( ... );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// passe 2, utiliser la texture de la passe 1 et dessiner dans la fenetre </span></div>
<div class="line">    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0);</div>
<div class="line">    glViewport( ... );</div>
<div class="line">    glClear( ... );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// mettre a jour les mipmaps de la texture</span></div>
<div class="line">    glBindTexture(GL_TEXTURE_2D, color);</div>
<div class="line">    glGenerateMipmap(GL_TEXTURE_2D);</div>
<div class="line"> </div>
<div class="line">    glBindVertexArray( ... );</div>
<div class="line">    glUseProgram( ... );</div>
<div class="line">    glUniform( ... );</div>
<div class="line">    glDraw( ... );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// nettoyage *obligatoire*, la texture color *ne doit pas* etre active sur une unite de texture et attachee au framebuffer selectionne</span></div>
<div class="line">    glBindTexture(GL_TEXTURE_2D, 0);</div>
<div class="line">}</div>
</div><!-- fragment --><p>exemple complet dans cf <a class="el" href="tuto__framebuffer_8cpp.html">tuto_framebuffer.cpp</a>.</p>
<h1><a class="anchor" id="autotoc_md106"></a>
et avec plusieurs textures ?</h1>
<p>dans certains cas, il est nécessaire de stocker plusieurs informations, en plus de la couleur et de la profondeur du fragment. la démarche est la meme, il suffit de déclarer les sorties dans le fragment shader (8 au maximum), de créer des textures pour stocker les résultats, de les attacher au framebuffer, et enfin de les associer aux sorties du fragment shader avec glDrawBuffers().</p>
<p>comme d'habitude, les différentes sorties sont numérotées. l'application peut choisir l'identifiant de chaque sortie avec glBindFragDataLocation(program, numero, varying ), mais il faut ensuite (re-) linker le shader program, ce qui n'est pas très pratique. il est aussi possible d'indiquer le numéro directement dans le source du fragment shader avec <code>layout(location= ...)</code>, ce qui est plus simple à manipuler (c'est la même chose pour les attributs des sommets dans le vertex shader).</p>
<div class="fragment"><div class="line"><span class="comment">// fragment shader</span></div>
<div class="line">layout(location= 0) out <a class="code" href="structvec4.html">vec4</a> fragment_color;        <span class="comment">// declare la sortie 0</span></div>
<div class="line">layout(location= 1) out <a class="code" href="structvec3.html">vec3</a> fragment_normal;       <span class="comment">// declare la sortie 1</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main( ) </div>
<div class="line">{</div>
<div class="line">    fragment_normal= { ... };</div>
<div class="line">    fragment_color= { ... };</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// application</span></div>
<div class="line">GLuint color_texture= { ... };</div>
<div class="line">GLuint normal_texture= { ... };</div>
<div class="line">GLuint depth_texture= { ... };</div>
<div class="line">GLuint framebuffer= { ... };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// selectionner le framebuffer, si necessaire</span></div>
<div class="line"><span class="comment">// glBindFramebuffer(GL_DRAW_FRAMEBUFFER, framebuffer);</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// attacher les textures au framebuffer</span></div>
<div class="line">glFramebufferTexture(GL_DRAW_FRAMEBUFFER,  <span class="comment">/* attachment */</span> GL_COLOR_ATTACHMENT0, <span class="comment">/* texture */</span> color_texture, <span class="comment">/* mipmap level */</span> 0);</div>
<div class="line">glFramebufferTexture(GL_DRAW_FRAMEBUFFER,  <span class="comment">/* attachment */</span> GL_COLOR_ATTACHMENT1, <span class="comment">/* texture */</span> normal_texture, <span class="comment">/* mipmap level */</span> 0);</div>
<div class="line">glFramebufferTexture(GL_DRAW_FRAMEBUFFER,  <span class="comment">/* attachment */</span> GL_DEPTH_ATTACHMENT, <span class="comment">/* texture */</span> depth_texture, <span class="comment">/* mipmap level */</span> 0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// associer les sorties du fragment shader aux textures attachees au framebuffer</span></div>
<div class="line">GLenum <a class="code" href="mesh__buffer_8cpp.html#af9c01c4285fe2a34523e5041abf7a86c">buffers</a>[]= { <span class="comment">/* sortie / location 0 */</span> GL_COLOR_ATTACHMENT0, <span class="comment">/* sortie / location 1 */</span> GL_COLOR_ATTACHMENT1 };</div>
<div class="line">glDrawBuffers(2, <a class="code" href="mesh__buffer_8cpp.html#af9c01c4285fe2a34523e5041abf7a86c">buffers</a>);</div>
</div><!-- fragment --><p>bien sur, on peut utiliser glGetFragDataLocation( ) pour récupérer l'identifiant d'une sortie du fragment shader, mais par construction, le résultat est la valeur que l'on a indiqué avec la déclaration <code>layout(location= ...)</code>.</p>
<p><em>rappel :</em> le paramètre attachment de glFramebufferTexture est libre, on obtient exactement le meme résultat de cette maniere : </p><div class="fragment"><div class="line"><span class="comment">// selectionner le framebuffer, si necessaire</span></div>
<div class="line"><span class="comment">// glBindFramebuffer(GL_DRAW_FRAMEBUFFER, framebuffer);</span></div>
<div class="line"><span class="comment">// attacher les textures au framebuffer</span></div>
<div class="line">glFramebufferTexture(GL_DRAW_FRAMEBUFFER,  <span class="comment">/* attachment */</span> GL_COLOR_ATTACHMENT4, <span class="comment">/* texture */</span> color_texture, <span class="comment">/* mipmap level */</span> 0);</div>
<div class="line">glFramebufferTexture(GL_DRAW_FRAMEBUFFER,  <span class="comment">/* attachment */</span> GL_COLOR_ATTACHMENT2, <span class="comment">/* texture */</span> normal_texture, <span class="comment">/* mipmap level */</span> 0);</div>
<div class="line">glFramebufferTexture(GL_DRAW_FRAMEBUFFER,  <span class="comment">/* attachment */</span> GL_DEPTH_ATTACHMENT, <span class="comment">/* texture */</span> depth_texture, <span class="comment">/* mipmap level */</span> 0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// associer les sorties du fragment shader aux textures attachees au framebuffer</span></div>
<div class="line">GLenum <a class="code" href="mesh__buffer_8cpp.html#af9c01c4285fe2a34523e5041abf7a86c">buffers</a>[]= { <span class="comment">/* sortie / location 0 */</span> GL_COLOR_ATTACHMENT4, <span class="comment">/* sortie / location 1 */</span> GL_COLOR_ATTACHMENT2 };</div>
<div class="line">glDrawBuffers(2, <a class="code" href="mesh__buffer_8cpp.html#af9c01c4285fe2a34523e5041abf7a86c">buffers</a>);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md107"></a>
vérifier la configuration du framebuffer</h2>
<p>pour vérifier que le framebuffer est correctement configuré et que le pipeline est capable d'écrire toutes les données aux formats demandés, on peut utiliser glCheckFramebufferStatus(GL_DRAW_FRAMEBUFFER).</p>
<div class="fragment"><div class="line"><span class="comment">// selectionner le framebuffer, si necessaire</span></div>
<div class="line"><span class="comment">// glBindFramebuffer(GL_DRAW_FRAMEBUFFER, framebuffer);</span></div>
<div class="line">GLenum code= glCheckFramebufferStatus(GL_DRAW_FRAMEBUFFER);</div>
<div class="line"><span class="keywordflow">switch</span>(code)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">case</span> GL_FRAMEBUFFER_COMPLETE; <span class="comment">/* ok */</span> <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER: <span class="comment">/* un draw buffer n&#39;a pas de texture associee */</span> <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> GL_FRAMEBUFFER_UNSUPPORTED: <span class="comment">/* cet ensemble de formats de textures n&#39;est pas compatible avec la carte graphique */</span> <span class="keywordflow">break</span>;</div>
<div class="line">    </div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>les autres erreurs possibles sont dans la doc openGL.</p>
<h1><a class="anchor" id="autotoc_md108"></a>
formats de textures pour stocker des données, profondeur, position, normale, etc.</h1>
<p>les textures couleurs classiques stockent des entiers sur 8bits re-normalisés entre 0 et 1. si on souhaite stocker des réels, il faut utiliser un format de texture avec assez de précision. les floats sur 16 bits (suffixe 16F) et sur 32 bits (suffixe 32F) sont supportés par la plupart des cartes graphiques. voila les formats courants :</p><ul>
<li>float : GL_R32F, GL_R16F</li>
<li><a class="el" href="structvec2.html" title="vecteur generique, utilitaire.">vec2</a> : GL_RG32F, GL_RG16F,</li>
<li><a class="el" href="structvec3.html" title="vecteur generique, utilitaire.">vec3</a> : GL_RGB32F, GL_RGB16F,</li>
<li><a class="el" href="structvec4.html" title="vecteur generique 4d, ou 3d homogene, utilitaire.">vec4</a> : GL_RGBA32F, GL_RGBA16F</li>
<li>zbuffer : GL_DEPTH_COMPONENT32F, GL_DEPTH_COMPONENT</li>
</ul>
<p><b>attention :</b> toutes les combinaisons de formats ne sont pas supportées par la carte graphique. vérifiez avec glCheckFramebufferStatus().</p>
<h1><a class="anchor" id="autotoc_md109"></a>
effacer le framebuffer / valeurs par défaut</h1>
<p>les framebuffers classiques sont "effacés" / (re-) initialisés par glClear() avec les valeurs fournies par glClearColor(), glClearDepthf(). lorsque plusieurs textures de formats différents sont utilisées et que l'on souhaite les initialiser avec des valeurs différentes, il faut utiliser la famille de fonctions glClearBuffer(). les formats de textures entiers utilisent glClearBufferiv(), les formats float, glClearBufferfv().</p>
<p>Les textures attachées au framebuffer ne sont pas identifiées directement, mais à travers leur association à une sortie du fragment shader, cf les paramètres passés à glDrawBuffers() lors de la configuration du framebuffer. Les valeurs par défaut sont toujours fournies par un <a class="el" href="structvec4.html" title="vecteur generique 4d, ou 3d homogene, utilitaire.">vec4</a>, même si la texture utilise un format avec moins de composantes. Le zbuffer est un cas particulier, il suffit de passer un seul float.</p>
<div class="fragment"><div class="line"><span class="comment">// couleur par défaut : gris, pour la texture associee à la sortie 0 du fragment shader</span></div>
<div class="line"><a class="code" href="structvec4.html">vec4</a> color= <a class="code" href="structvec4.html">vec4</a>(.2, .2, .2, 1);</div>
<div class="line">glClearBufferfv(GL_COLOR, <span class="comment">/* draw buffer / sortie / location */</span> 0, <span class="comment">/* const float[4] */</span> &amp;color.r);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// normale par défaut : vec3(0, 0, 0), pour la texture associee à la sortie 1 du framgent shader</span></div>
<div class="line"><a class="code" href="structvec4.html">vec4</a> normal= <a class="code" href="structvec4.html">vec4</a>(0, 0, 0, 0);</div>
<div class="line">glClearBufferfv(GL_COLOR, <span class="comment">/* draw buffer / sortie / location */</span> 1, <span class="comment">/* const float[4] */</span> &amp;normal.x);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// profondeur par defaut</span></div>
<div class="line"><span class="keywordtype">float</span> one= 1;</div>
<div class="line">glClearBufferfv(GL_DEPTH, <span class="comment">/* draw buffer 0 */</span> 0, <span class="comment">/* const float* */</span> &amp;one);</div>
</div><!-- fragment --> </div><!-- contents -->
<div class="ttc" id="amesh__buffer_8cpp_html_af9c01c4285fe2a34523e5041abf7a86c"><div class="ttname"><a href="mesh__buffer_8cpp.html#af9c01c4285fe2a34523e5041abf7a86c">buffers</a></div><div class="ttdeci">MeshBuffer buffers(const MeshData &amp;data)</div><div class="ttdoc">construction a partir des donnees d'un maillage.</div><div class="ttdef"><b>Definition:</b> <a href="mesh__buffer_8cpp_source.html#l00048">mesh_buffer.cpp:48</a></div></div>
<div class="ttc" id="ashader__kit_8cpp_html_a72fad2bb274e5f3b6d190bd860ea63b5"><div class="ttname"><a href="shader__kit_8cpp.html#a72fad2bb274e5f3b6d190bd860ea63b5">init</a></div><div class="ttdeci">int init(std::vector&lt; const char * &gt; &amp;options)</div><div class="ttdef"><b>Definition:</b> <a href="shader__kit_8cpp_source.html#l00094">shader_kit.cpp:94</a></div></div>
<div class="ttc" id="astructvec3_html"><div class="ttname"><a href="structvec3.html">vec3</a></div><div class="ttdoc">vecteur generique, utilitaire.</div><div class="ttdef"><b>Definition:</b> <a href="vec_8h_source.html#l00144">vec.h:144</a></div></div>
<div class="ttc" id="agroup__application_html_ga4d0b205b70f38973c8c5395f31f77baf"><div class="ttname"><a href="group__application.html#ga4d0b205b70f38973c8c5395f31f77baf">window_height</a></div><div class="ttdeci">int window_height()</div><div class="ttdoc">renvoie la hauteur de la fenetre de l'application.</div><div class="ttdef"><b>Definition:</b> <a href="window_8cpp_source.html#l00037">window.cpp:37</a></div></div>
<div class="ttc" id="astructvec4_html"><div class="ttname"><a href="structvec4.html">vec4</a></div><div class="ttdoc">vecteur generique 4d, ou 3d homogene, utilitaire.</div><div class="ttdef"><b>Definition:</b> <a href="vec_8h_source.html#l00166">vec.h:166</a></div></div>
<div class="ttc" id="agroup__application_html_gae3a7daacf8fe05cc4e57d8557ec4e475"><div class="ttname"><a href="group__application.html#gae3a7daacf8fe05cc4e57d8557ec4e475">window_width</a></div><div class="ttdeci">int window_width()</div><div class="ttdoc">renvoie la largeur de la fenetre de l'application.</div><div class="ttdef"><b>Definition:</b> <a href="window_8cpp_source.html#l00033">window.cpp:33</a></div></div>
<div class="ttc" id="astructColor_html"><div class="ttname"><a href="structColor.html">Color</a></div><div class="ttdoc">representation d'une couleur (rgba) transparente ou opaque.</div><div class="ttdef"><b>Definition:</b> <a href="color_8h_source.html#l00013">color.h:13</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 9 2019 15:39:11 for gKit2 light by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
